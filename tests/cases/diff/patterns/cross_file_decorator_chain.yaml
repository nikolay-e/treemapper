name: cross_file_decorator_chain
initial:
  decorators/logging.py: |
    import functools
    import logging

    logger = logging.getLogger(__name__)

    def log_calls(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            logger.info(f"Calling {func.__name__}")
            result = func(*args, **kwargs)
            logger.info(f"Finished {func.__name__}")
            return result
        return wrapper

    def retry(max_attempts=3):
        def decorator(func):
            @functools.wraps(func)
            def wrapper(*args, **kwargs):
                for attempt in range(max_attempts):
                    try:
                        return func(*args, **kwargs)
                    except Exception as e:
                        if attempt == max_attempts - 1:
                            raise
                        logger.warning(f"Attempt {attempt + 1} failed: {e}")
            return wrapper
        return decorator
  services/user_service.py: |
    from decorators.logging import log_calls

    class UserService:
        @log_calls
        def create_user(self, name: str, email: str):
            return {"name": name, "email": email}

        @log_calls
        def delete_user(self, user_id: int):
            return {"deleted": user_id}
  services/order_service.py: |
    from decorators.logging import log_calls, retry

    class OrderService:
        @log_calls
        @retry(max_attempts=3)
        def create_order(self, user_id: int, items: list):
            return {"user_id": user_id, "items": items}

        @log_calls
        def cancel_order(self, order_id: int):
            return {"cancelled": order_id}
changed:
  decorators/logging.py: |
    import functools
    import logging
    import time

    logger = logging.getLogger(__name__)

    def log_calls(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            start_time = time.time()
            logger.info(f"Calling {func.__name__} with args={args}, kwargs={kwargs}")
            try:
                result = func(*args, **kwargs)
                elapsed = time.time() - start_time
                logger.info(f"Finished {func.__name__} in {elapsed:.3f}s")
                return result
            except Exception as e:
                elapsed = time.time() - start_time
                logger.error(f"Failed {func.__name__} after {elapsed:.3f}s: {e}")
                raise
        return wrapper

    def retry(max_attempts=3):
        def decorator(func):
            @functools.wraps(func)
            def wrapper(*args, **kwargs):
                for attempt in range(max_attempts):
                    try:
                        return func(*args, **kwargs)
                    except Exception as e:
                        if attempt == max_attempts - 1:
                            raise
                        logger.warning(f"Attempt {attempt + 1} failed: {e}")
            return wrapper
        return decorator
assertions:
  must_include:
  - logging.py
  - log_calls
