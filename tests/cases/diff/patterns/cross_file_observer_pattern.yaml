name: cross_file_observer_pattern
initial:
  observer/subject.py: |
    from abc import ABC, abstractmethod
    from typing import List

    class Observer(ABC):
        @abstractmethod
        def update(self, subject: 'Subject') -> None:
            pass

    class Subject(ABC):
        def __init__(self):
            self._observers: List[Observer] = []

        def attach(self, observer: Observer) -> None:
            if observer not in self._observers:
                self._observers.append(observer)

        def detach(self, observer: Observer) -> None:
            self._observers.remove(observer)

        def notify(self) -> None:
            for observer in self._observers:
                observer.update(self)
  observer/stock.py: |
    from observer.subject import Subject

    class Stock(Subject):
        def __init__(self, symbol: str, price: float):
            super().__init__()
            self._symbol = symbol
            self._price = price

        @property
        def symbol(self) -> str:
            return self._symbol

        @property
        def price(self) -> float:
            return self._price

        @price.setter
        def price(self, value: float) -> None:
            self._price = value
            self.notify()
  observer/observers/price_alert.py: |
    from observer.subject import Observer, Subject

    class PriceAlertObserver(Observer):
        def __init__(self, threshold: float):
            self.threshold = threshold
            self.alerts: list[str] = []

        def update(self, subject: Subject) -> None:
            if hasattr(subject, 'price') and subject.price > self.threshold:
                self.alerts.append(
                    f"ALERT: {subject.symbol} exceeded {self.threshold}"
                )
changed:
  observer/subject.py: |
    from abc import ABC, abstractmethod
    from typing import List, Any
    from enum import Enum, auto

    class EventType(Enum):
        CREATED = auto()
        UPDATED = auto()
        DELETED = auto()

    class Observer(ABC):
        @abstractmethod
        def update(self, subject: 'Subject', event_type: EventType, data: Any = None) -> None:
            pass

    class Subject(ABC):
        def __init__(self):
            self._observers: List[Observer] = []
            self._event_filters: dict[Observer, set[EventType]] = {}

        def attach(self, observer: Observer, event_types: set[EventType] | None = None) -> None:
            if observer not in self._observers:
                self._observers.append(observer)
                self._event_filters[observer] = event_types or set(EventType)

        def detach(self, observer: Observer) -> None:
            self._observers.remove(observer)
            self._event_filters.pop(observer, None)

        def notify(self, event_type: EventType = EventType.UPDATED, data: Any = None) -> None:
            for observer in self._observers:
                allowed_events = self._event_filters.get(observer, set(EventType))
                if event_type in allowed_events:
                    observer.update(self, event_type, data)

        def get_observer_count(self) -> int:
            return len(self._observers)
assertions:
  must_include:
  - subject.py
  - notify
