name: rust_014_option_handling
initial:
  src/lib.rs: |
    pub mod finder;
    pub mod unrelated;
  src/finder.rs: |
    pub fn find_first(items: &[i32], target: i32) -> i32 {
        for item in items {
            if *item == target {
                return *item;
            }
        }
        -1
    }

    pub struct ItemFinder<T> {
        items: Vec<T>,
    }

    impl<T: PartialEq> ItemFinder<T> {
        pub fn new(items: Vec<T>) -> Self {
            Self { items }
        }

        pub fn contains(&self, target: &T) -> bool {
            self.items.contains(target)
        }
    }

    impl<T> Default for ItemFinder<T> {
        fn default() -> Self {
            Self { items: Vec::new() }
        }
    }
  src/unrelated/mod.rs: |
    pub mod csv;
    pub mod xml;
  src/unrelated/csv.rs: |
    // GARBAGE_RUST_CSV_001
    pub const GARBAGE_CSV_DELIMITER_002: char = ',';
    pub const GARBAGE_CSV_QUOTE_003: char = '"';

    pub struct GarbageCsvReader004 {
        delimiter: char,
        has_header: bool,
    }

    impl GarbageCsvReader004 {
        pub fn garbage_read_005(&self, path: &str) -> Result<Vec<Vec<String>>, String> {
            Err("GARBAGE_CSV_READ_ERROR_006".to_string())
        }

        pub fn garbage_parse_row_007(&self, line: &str) -> Vec<String> {
            line.split(self.delimiter).map(String::from).collect()
        }
    }

    pub struct GarbageCsvWriter008 {
        delimiter: char,
    }

    impl GarbageCsvWriter008 {
        pub fn garbage_write_009(&self, path: &str, data: &[Vec<String>]) -> Result<(), String> {
            Err("GARBAGE_CSV_WRITE_ERROR_010".to_string())
        }
    }
  src/unrelated/xml.rs: |
    // GARBAGE_RUST_XML_011
    pub const GARBAGE_XML_VERSION_012: &str = "1.0";

    pub struct GarbageXmlNode013 {
        name: String,
        attributes: Vec<(String, String)>,
        children: Vec<GarbageXmlNode013>,
    }

    impl GarbageXmlNode013 {
        pub fn garbage_parse_014(xml: &str) -> Result<Self, String> {
            Err("GARBAGE_XML_PARSE_ERROR_015".to_string())
        }

        pub fn garbage_to_string_016(&self) -> String {
            format!("<{}>GARBAGE_XML_CONTENT_017</{}>", self.name, self.name)
        }

        pub fn garbage_find_child_018(&self, name: &str) -> Option<&Self> {
            None
        }
    }
changed:
  src/finder.rs: |
    use std::cmp::PartialEq;

    pub fn find_first(items: &[i32], target: i32) -> Option<i32> {
        items.iter().find(|&&x| x == target).copied()
    }

    pub fn find_index(items: &[i32], target: i32) -> Option<usize> {
        items.iter().position(|&x| x == target)
    }

    pub fn find_or_default(items: &[i32], target: i32, default: i32) -> i32 {
        find_first(items, target).unwrap_or(default)
    }

    pub fn find_last(items: &[i32], target: i32) -> Option<i32> {
        items.iter().rev().find(|&&x| x == target).copied()
    }

    pub fn find_all(items: &[i32], target: i32) -> Vec<usize> {
        items.iter()
            .enumerate()
            .filter(|(_, &x)| x == target)
            .map(|(i, _)| i)
            .collect()
    }

    pub fn find_by<T, F>(items: &[T], predicate: F) -> Option<&T>
    where
        F: Fn(&T) -> bool,
    {
        items.iter().find(|item| predicate(item))
    }

    pub struct ItemFinder<T> {
        items: Vec<T>,
    }

    impl<T: PartialEq + Clone> ItemFinder<T> {
        pub fn new(items: Vec<T>) -> Self {
            Self { items }
        }

        pub fn contains(&self, target: &T) -> bool {
            self.items.contains(target)
        }

        pub fn find(&self, target: &T) -> Option<&T> {
            self.items.iter().find(|item| *item == target)
        }

        pub fn find_index(&self, target: &T) -> Option<usize> {
            self.items.iter().position(|item| item == target)
        }

        pub fn first(&self) -> Option<&T> {
            self.items.first()
        }

        pub fn last(&self) -> Option<&T> {
            self.items.last()
        }

        pub fn get(&self, index: usize) -> Option<&T> {
            self.items.get(index)
        }

        pub fn find_map<U, F>(&self, f: F) -> Option<U>
        where
            F: Fn(&T) -> Option<U>,
        {
            self.items.iter().find_map(f)
        }
    }

    impl<T> Default for ItemFinder<T> {
        fn default() -> Self {
            Self { items: Vec::new() }
        }
    }
assertions:
  must_include:
    - Option<i32>
    - Option<usize>
    - find_index
    - find_or_default
    - find_last
    - find_all
    - find_by
    - find_map
  must_not_include:
    - GARBAGE_RUST_CSV_001
    - GARBAGE_CSV_DELIMITER_002
    - GARBAGE_CSV_QUOTE_003
    - GarbageCsvReader004
    - garbage_read_005
    - GARBAGE_CSV_READ_ERROR_006
    - garbage_parse_row_007
    - GarbageCsvWriter008
    - garbage_write_009
    - GARBAGE_CSV_WRITE_ERROR_010
    - GARBAGE_RUST_XML_011
    - GARBAGE_XML_VERSION_012
    - GarbageXmlNode013
    - garbage_parse_014
    - GARBAGE_XML_PARSE_ERROR_015
    - garbage_to_string_016
    - GARBAGE_XML_CONTENT_017
    - garbage_find_child_018
options:
  commit_message: Return Option instead of sentinel values
