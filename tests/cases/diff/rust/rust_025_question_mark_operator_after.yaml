src/lib.rs: |
  pub mod errors;
  pub mod parser;
  pub mod unrelated;
src/errors.rs: |
  use std::fmt;

  #[derive(Debug)]
  pub enum AppError {
      IoError(std::io::Error),
      ParseError(String),
      NetworkError(String),
      ValidationError { field: String, message: String },
  }

  impl fmt::Display for AppError {
      fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
          match self {
              AppError::IoError(e) => write!(f, "IO error: {}", e),
              AppError::ParseError(s) => write!(f, "Parse error: {}", s),
              AppError::NetworkError(s) => write!(f, "Network error: {}", s),
              AppError::ValidationError { field, message } => {
                  write!(f, "Validation error in {}: {}", field, message)
              }
          }
      }
  }

  impl std::error::Error for AppError {}

  impl From<std::io::Error> for AppError {
      fn from(e: std::io::Error) -> Self {
          AppError::IoError(e)
      }
  }
src/parser.rs: |
  use crate::errors::AppError;
  use std::fs;

  pub fn parse_file(path: &str) -> Result<String, AppError> {
      let content = fs::read_to_string(path)?;
      if content.is_empty() {
          return Err(AppError::ParseError("File is empty".to_string()));
      }
      Ok(content.trim().to_string())
  }

  pub fn parse_config(path: &str) -> Result<Vec<String>, AppError> {
      let content = parse_file(path)?;
      let lines: Vec<String> = content.lines().map(|l| l.to_string()).collect();
      Ok(lines)
  }

  pub fn validate_and_parse(path: &str) -> Result<Vec<String>, AppError> {
      let lines = parse_config(path)?;
      for (i, line) in lines.iter().enumerate() {
          if line.contains('\0') {
              return Err(AppError::ValidationError {
                  field: format!("line_{}", i),
                  message: "Contains null byte".to_string(),
              });
          }
      }
      Ok(lines)
  }
src/unrelated/mod.rs: |
  pub mod notifier;
  pub mod archiver;
src/unrelated/notifier.rs: |
  // GARBAGE_RUST_025_NOTIFIER_A
  pub const GARBAGE_RUST_025_NOTIFY_CHANNEL_B: &str = "email";

  pub struct GarbageNotificationService025 {
      recipients: Vec<String>,
  }

  impl GarbageNotificationService025 {
      pub fn garbage_send_025(&self, msg: &str) -> bool {
          !self.recipients.is_empty() && !msg.is_empty()
      }

      pub fn garbage_broadcast_025(&self, msg: &str) -> usize {
          self.recipients.len()
      }
  }
src/unrelated/archiver.rs: |
  // GARBAGE_RUST_025_ARCHIVER_C
  pub const GARBAGE_RUST_025_ARCHIVE_FMT_D: &str = "tar.gz";

  pub struct GarbageFileArchiver025 {
      compression_level: u8,
  }

  impl GarbageFileArchiver025 {
      pub fn garbage_compress_025(&self, paths: &[&str]) -> Vec<u8> {
          vec![0u8; paths.len() * self.compression_level as usize]
      }

      pub fn garbage_extract_025(&self, data: &[u8]) -> Vec<String> {
          vec!["extracted".to_string(); data.len()]
      }
  }
