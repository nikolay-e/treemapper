src/lib.rs: |
  pub mod wrapper;
  pub mod usage;
  pub mod unrelated;
src/wrapper.rs: |
  use std::ops::{Deref, DerefMut};

  pub struct Wrapper<T> {
      value: T,
      label: String,
  }

  impl<T> Wrapper<T> {
      pub fn new(value: T, label: &str) -> Self {
          Self {
              value,
              label: label.to_string(),
          }
      }

      pub fn into_inner(self) -> T {
          self.value
      }

      pub fn label(&self) -> &str {
          &self.label
      }

      pub fn set_label(&mut self, label: &str) {
          self.label = label.to_string();
      }
  }

  impl<T> Deref for Wrapper<T> {
      type Target = T;

      fn deref(&self) -> &Self::Target {
          &self.value
      }
  }

  impl<T> DerefMut for Wrapper<T> {
      fn deref_mut(&mut self) -> &mut Self::Target {
          &mut self.value
      }
  }
src/usage.rs: |
  use crate::wrapper::Wrapper;

  pub fn use_wrapper() {
      let wrapped = Wrapper::new(String::from("hello"), "greeting");
      println!("Length: {}", wrapped.len());
      println!("Upper: {}", wrapped.to_uppercase());
  }

  pub fn modify_wrapper() {
      let mut wrapped = Wrapper::new(vec![1, 2, 3], "numbers");
      wrapped.push(4);
      println!("Label: {}", wrapped.label());
      println!("Items: {:?}", *wrapped);
  }
src/unrelated/mod.rs: |
  pub mod retry_policy;
  pub mod backoff_strategy;
src/unrelated/retry_policy.rs: |
  // GARBAGE_RUST_039_RETRY_POLICY_A
  pub const GARBAGE_RUST_039_MAX_RETRIES_B: u32 = 3;

  pub struct GarbageRetryPolicy039 {
      max_retries: u32,
      current: u32,
  }

  impl GarbageRetryPolicy039 {
      pub fn garbage_should_retry_039(&self) -> bool {
          self.current < self.max_retries
      }

      pub fn garbage_record_attempt_039(&mut self) {
          self.current += 1;
      }
  }
src/unrelated/backoff_strategy.rs: |
  // GARBAGE_RUST_039_BACKOFF_STRATEGY_C
  pub const GARBAGE_RUST_039_BASE_DELAY_D: u64 = 100;

  pub struct GarbageExponentialBackoff039 {
      base_ms: u64,
      attempt: u32,
  }

  impl GarbageExponentialBackoff039 {
      pub fn garbage_next_delay_039(&mut self) -> u64 {
          let delay = self.base_ms * 2u64.pow(self.attempt);
          self.attempt += 1;
          delay
      }

      pub fn garbage_reset_039(&mut self) {
          self.attempt = 0;
      }
  }
