src/lib.rs: |
  pub mod shared_state;
  pub mod unrelated;
src/shared_state.rs: |
  use std::sync::{Arc, Mutex, RwLock, Condvar};
  use std::thread;
  use std::time::Duration;

  #[derive(Debug)]
  pub struct Counter {
      value: Arc<Mutex<i32>>,
      history: Arc<RwLock<Vec<i32>>>,
      name: String,
  }

  impl Counter {
      pub fn new(name: &str) -> Self {
          Self {
              value: Arc::new(Mutex::new(0)),
              history: Arc::new(RwLock::new(vec![])),
              name: name.to_string(),
          }
      }

      pub fn increment(&self) {
          let mut val = self.value.lock().unwrap();
          *val += 1;
          let mut history = self.history.write().unwrap();
          history.push(*val);
      }

      pub fn decrement(&self) {
          let mut val = self.value.lock().unwrap();
          *val -= 1;
          let mut history = self.history.write().unwrap();
          history.push(*val);
      }

      pub fn get(&self) -> i32 {
          *self.value.lock().unwrap()
      }

      pub fn get_history(&self) -> Vec<i32> {
          self.history.read().unwrap().clone()
      }

      pub fn name(&self) -> &str {
          &self.name
      }

      pub fn reset(&self) {
          let mut val = self.value.lock().unwrap();
          *val = 0;
          let mut history = self.history.write().unwrap();
          history.clear();
      }
  }

  impl Clone for Counter {
      fn clone(&self) -> Self {
          Self {
              value: Arc::clone(&self.value),
              history: Arc::clone(&self.history),
              name: self.name.clone(),
          }
      }
  }

  pub fn increment_in_threads(counter: &Counter, num_threads: usize) {
      let handles: Vec<_> = (0..num_threads)
          .map(|_| {
              let c = counter.clone();
              thread::spawn(move || {
                  c.increment();
              })
          })
          .collect();

      for handle in handles {
          handle.join().unwrap();
      }
  }

  pub struct BoundedCounter {
      value: Arc<Mutex<i32>>,
      min: i32,
      max: i32,
      not_empty: Arc<Condvar>,
      not_full: Arc<Condvar>,
  }

  impl BoundedCounter {
      pub fn new(min: i32, max: i32) -> Self {
          Self {
              value: Arc::new(Mutex::new(min)),
              min,
              max,
              not_empty: Arc::new(Condvar::new()),
              not_full: Arc::new(Condvar::new()),
          }
      }

      pub fn increment_blocking(&self) {
          let mut val = self.value.lock().unwrap();
          while *val >= self.max {
              val = self.not_full.wait(val).unwrap();
          }
          *val += 1;
          self.not_empty.notify_one();
      }

      pub fn decrement_blocking(&self) {
          let mut val = self.value.lock().unwrap();
          while *val <= self.min {
              val = self.not_empty.wait(val).unwrap();
          }
          *val -= 1;
          self.not_full.notify_one();
      }

      pub fn try_increment(&self) -> bool {
          let mut val = self.value.lock().unwrap();
          if *val < self.max {
              *val += 1;
              self.not_empty.notify_one();
              true
          } else {
              false
          }
      }

      pub fn try_decrement(&self) -> bool {
          let mut val = self.value.lock().unwrap();
          if *val > self.min {
              *val -= 1;
              self.not_full.notify_one();
              true
          } else {
              false
          }
      }

      pub fn get(&self) -> i32 {
          *self.value.lock().unwrap()
      }
  }

  impl Clone for BoundedCounter {
      fn clone(&self) -> Self {
          Self {
              value: Arc::clone(&self.value),
              min: self.min,
              max: self.max,
              not_empty: Arc::clone(&self.not_empty),
              not_full: Arc::clone(&self.not_full),
          }
      }
  }

  pub trait SharedCounter: Send + Sync {
      fn inc(&self);
      fn dec(&self);
      fn value(&self) -> i32;
  }

  impl SharedCounter for Counter {
      fn inc(&self) {
          self.increment();
      }

      fn dec(&self) {
          self.decrement();
      }

      fn value(&self) -> i32 {
          self.get()
      }
  }

  impl SharedCounter for BoundedCounter {
      fn inc(&self) {
          self.try_increment();
      }

      fn dec(&self) {
          self.try_decrement();
      }

      fn value(&self) -> i32 {
          self.get()
      }
  }
src/unrelated/mod.rs: |
  pub mod database;
  pub mod cache;
  pub mod logging;
src/unrelated/database.rs: |
  // GARBAGE_RUST_DB_arc001
  use std::collections::HashMap;

  pub const GARBAGE_MAX_CONNECTIONS_arc002: usize = 100;
  pub const GARBAGE_TIMEOUT_MS_arc003: u64 = 30000;
  pub const GARBAGE_RETRY_COUNT_arc004: u32 = 3;

  #[derive(Debug, Clone)]
  pub enum GarbageDbError_arc005 {
      ConnectionFailed(String),
      QueryFailed(String),
      Timeout,
      PoolExhausted,
  }

  pub trait GarbageDatabase_arc006 {
      fn garbage_connect_arc007(&mut self) -> Result<(), GarbageDbError_arc005>;
      fn garbage_disconnect_arc008(&mut self);
      fn garbage_execute_arc009(&self, query: &str) -> Result<Vec<HashMap<String, String>>, GarbageDbError_arc005>;
      fn garbage_is_connected_arc010(&self) -> bool;
  }

  pub struct GarbagePostgresDb_arc011 {
      host: String,
      port: u16,
      database: String,
      connected: bool,
  }

  impl GarbagePostgresDb_arc011 {
      pub fn garbage_new_arc012(host: &str, port: u16, database: &str) -> Self {
          Self {
              host: host.to_string(),
              port,
              database: database.to_string(),
              connected: false,
          }
      }

      pub fn garbage_connection_string_arc013(&self) -> String {
          format!("postgres://{}:{}/{}", self.host, self.port, self.database)
      }
  }

  impl GarbageDatabase_arc006 for GarbagePostgresDb_arc011 {
      fn garbage_connect_arc007(&mut self) -> Result<(), GarbageDbError_arc005> {
          self.connected = true;
          Ok(())
      }

      fn garbage_disconnect_arc008(&mut self) {
          self.connected = false;
      }

      fn garbage_execute_arc009(&self, query: &str) -> Result<Vec<HashMap<String, String>>, GarbageDbError_arc005> {
          if !self.connected {
              return Err(GarbageDbError_arc005::ConnectionFailed("GARBAGE_NOT_CONNECTED_arc014".to_string()));
          }
          Ok(Vec::new())
      }

      fn garbage_is_connected_arc010(&self) -> bool {
          self.connected
      }
  }

  pub struct GarbageConnectionPool_arc015<D: GarbageDatabase_arc006> {
      connections: Vec<D>,
      max_size: usize,
  }

  impl<D: GarbageDatabase_arc006> GarbageConnectionPool_arc015<D> {
      pub fn garbage_new_arc016(max_size: usize) -> Self {
          Self {
              connections: Vec::new(),
              max_size,
          }
      }

      pub fn garbage_acquire_arc017(&mut self) -> Option<&mut D> {
          self.connections.first_mut()
      }
  }
src/unrelated/cache.rs: |
  // GARBAGE_RUST_CACHE_arc018
  use std::collections::HashMap;
  use std::time::{Duration, Instant};

  pub const GARBAGE_DEFAULT_TTL_arc019: u64 = 3600;
  pub const GARBAGE_MAX_ENTRIES_arc020: usize = 10000;

  pub struct GarbageCacheEntry_arc021<V> {
      value: V,
      created_at: Instant,
      ttl: Duration,
  }

  impl<V> GarbageCacheEntry_arc021<V> {
      pub fn garbage_new_arc022(value: V, ttl: Duration) -> Self {
          Self {
              value,
              created_at: Instant::now(),
              ttl,
          }
      }

      pub fn garbage_is_expired_arc023(&self) -> bool {
          self.created_at.elapsed() > self.ttl
      }

      pub fn garbage_value_arc024(&self) -> &V {
          &self.value
      }
  }

  pub trait GarbageCache_arc025<K, V> {
      fn garbage_get_arc026(&self, key: &K) -> Option<&V>;
      fn garbage_set_arc027(&mut self, key: K, value: V);
      fn garbage_remove_arc028(&mut self, key: &K) -> Option<V>;
      fn garbage_clear_arc029(&mut self);
  }

  pub struct GarbageLruCache_arc030<K, V> {
      entries: HashMap<K, GarbageCacheEntry_arc021<V>>,
      max_entries: usize,
  }

  impl<K: std::hash::Hash + Eq, V> GarbageLruCache_arc030<K, V> {
      pub fn garbage_new_arc031(max_entries: usize) -> Self {
          Self {
              entries: HashMap::new(),
              max_entries,
          }
      }

      pub fn garbage_len_arc032(&self) -> usize {
          self.entries.len()
      }

      fn garbage_evict_expired_arc033(&mut self) {
          self.entries.retain(|_, entry| !entry.garbage_is_expired_arc023());
      }
  }
src/unrelated/logging.rs: |
  // GARBAGE_RUST_LOG_arc034
  use std::fmt;

  pub const GARBAGE_LOG_BUFFER_SIZE_arc035: usize = 1024;

  #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
  pub enum GarbageLogLevel_arc036 {
      Trace,
      Debug,
      Info,
      Warn,
      Error,
  }

  impl fmt::Display for GarbageLogLevel_arc036 {
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          match self {
              GarbageLogLevel_arc036::Trace => write!(f, "TRACE"),
              GarbageLogLevel_arc036::Debug => write!(f, "DEBUG"),
              GarbageLogLevel_arc036::Info => write!(f, "INFO"),
              GarbageLogLevel_arc036::Warn => write!(f, "WARN"),
              GarbageLogLevel_arc036::Error => write!(f, "ERROR"),
          }
      }
  }

  pub trait GarbageLogger_arc037 {
      fn garbage_log_arc038(&self, level: GarbageLogLevel_arc036, message: &str);
      fn garbage_trace_arc039(&self, message: &str) {
          self.garbage_log_arc038(GarbageLogLevel_arc036::Trace, message);
      }
      fn garbage_debug_arc040(&self, message: &str) {
          self.garbage_log_arc038(GarbageLogLevel_arc036::Debug, message);
      }
      fn garbage_info_arc041(&self, message: &str) {
          self.garbage_log_arc038(GarbageLogLevel_arc036::Info, message);
      }
  }

  pub struct GarbageConsoleLogger_arc042 {
      min_level: GarbageLogLevel_arc036,
  }

  impl GarbageConsoleLogger_arc042 {
      pub fn garbage_new_arc043(min_level: GarbageLogLevel_arc036) -> Self {
          Self { min_level }
      }
  }

  impl GarbageLogger_arc037 for GarbageConsoleLogger_arc042 {
      fn garbage_log_arc038(&self, level: GarbageLogLevel_arc036, message: &str) {
          if level >= self.min_level {
              println!("[{}] {}", level, message);
          }
      }
  }
