src/lib.rs: |
  pub mod math;
  pub mod unrelated;
src/math.rs: |
  use std::ops::{Add, Sub};

  pub fn add(a: i64, b: i64) -> i64 {
      a + b
  }

  pub fn subtract(a: i64, b: i64) -> i64 {
      a - b
  }

  pub fn multiply(a: i64, b: i64) -> i64 {
      a * b
  }

  pub fn divide(a: i64, b: i64) -> Option<i64> {
      if b == 0 {
          None
      } else {
          Some(a / b)
      }
  }

  pub struct Calculator {
      precision: u8,
  }

  impl Calculator {
      pub fn new(precision: u8) -> Self {
          Self { precision }
      }

      pub fn add(&self, a: f64, b: f64) -> f64 {
          let result = a + b;
          self.round(result)
      }

      pub fn subtract(&self, a: f64, b: f64) -> f64 {
          let result = a - b;
          self.round(result)
      }

      fn round(&self, value: f64) -> f64 {
          let factor = 10_f64.powi(self.precision as i32);
          (value * factor).round() / factor
      }
  }

  impl Default for Calculator {
      fn default() -> Self {
          Self::new(2)
      }
  }
src/main.rs: |
  mod math;

  fn main() {
      let result = math::add(2, 3);
      println!("Result: {}", result);
  }
src/unrelated/mod.rs: |
  pub mod logging;
  pub mod cache;
src/unrelated/logging.rs: |
  // GARBAGE_RUST_LOGGING_001
  pub const GARBAGE_LOG_LEVEL_002: &str = "DEBUG";

  pub struct LoggerConfig {
      level: String,
      output_path: String,
  }

  impl LoggerConfig {
      pub fn garbage_logger_init_003() -> Self {
          Self {
              level: "INFO".to_string(),
              output_path: "/var/log".to_string(),
          }
      }

      pub fn garbage_log_method_004(&self, msg: &str) {
          println!("[{}] {}", self.level, msg);
      }
  }

  pub fn garbage_format_log_005(level: &str, msg: &str) -> String {
      format!("[{}] {}", level, msg)
  }
src/unrelated/cache.rs: |
  // GARBAGE_RUST_CACHE_006
  use std::collections::HashMap;

  pub const GARBAGE_CACHE_SIZE_007: usize = 1024;

  pub struct CacheEntry {
      pub key: String,
      pub value: Vec<u8>,
      pub ttl: u64,
  }

  pub struct GarbageCacheManager008 {
      entries: HashMap<String, CacheEntry>,
  }

  impl GarbageCacheManager008 {
      pub fn garbage_cache_get_009(&self, key: &str) -> Option<&CacheEntry> {
          self.entries.get(key)
      }
  }
