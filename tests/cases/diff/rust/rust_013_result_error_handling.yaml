name: rust_013_result_error_handling
initial:
  src/lib.rs: |
    pub mod parser;
    pub mod unrelated;
  src/parser.rs: |
    use std::str::FromStr;

    pub fn parse(s: &str) -> i32 {
        s.parse().unwrap()
    }

    pub fn parse_multiple(inputs: &[&str]) -> Vec<i32> {
        inputs.iter().map(|s| parse(s)).collect()
    }

    pub struct NumberParser {
        radix: u32,
    }

    impl NumberParser {
        pub fn new(radix: u32) -> Self {
            Self { radix }
        }

        pub fn parse(&self, s: &str) -> i32 {
            i32::from_str_radix(s, self.radix).unwrap()
        }
    }

    impl Default for NumberParser {
        fn default() -> Self {
            Self::new(10)
        }
    }
  src/unrelated/mod.rs: |
    pub mod image;
    pub mod audio;
  src/unrelated/image.rs: |
    // GARBAGE_RUST_IMAGE_001
    pub const GARBAGE_MAX_WIDTH_002: u32 = 4096;
    pub const GARBAGE_MAX_HEIGHT_003: u32 = 4096;

    pub struct GarbageImage004 {
        width: u32,
        height: u32,
        pixels: Vec<u8>,
    }

    impl GarbageImage004 {
        pub fn garbage_load_005(path: &str) -> Result<Self, String> {
            Err("GARBAGE_LOAD_ERROR_006".to_string())
        }

        pub fn garbage_resize_007(&mut self, new_width: u32, new_height: u32) {
            // GARBAGE_RESIZE_IMPL_008
        }

        pub fn garbage_save_009(&self, path: &str) -> Result<(), String> {
            Err("GARBAGE_SAVE_ERROR_010".to_string())
        }
    }

    pub trait GarbageImageFilter011 {
        fn garbage_apply_012(&self, image: &mut GarbageImage004);
    }
  src/unrelated/audio.rs: |
    // GARBAGE_RUST_AUDIO_013
    pub const GARBAGE_SAMPLE_RATE_014: u32 = 44100;
    pub const GARBAGE_BIT_DEPTH_015: u8 = 16;

    pub struct GarbageAudioBuffer016 {
        samples: Vec<f32>,
        channels: u8,
    }

    impl GarbageAudioBuffer016 {
        pub fn garbage_load_017(path: &str) -> Result<Self, String> {
            Err("GARBAGE_AUDIO_LOAD_ERROR_018".to_string())
        }

        pub fn garbage_mix_019(&mut self, other: &Self) {
            // GARBAGE_MIX_IMPL_020
        }

        pub fn garbage_normalize_021(&mut self) {
            // GARBAGE_NORMALIZE_IMPL_022
        }
    }
changed:
  src/parser.rs: |
    use std::num::ParseIntError;
    use std::str::FromStr;
    use std::fmt;

    #[derive(Debug)]
    pub enum ParseError {
        InvalidNumber(ParseIntError),
        EmptyInput,
        InvalidRadix(u32),
    }

    impl fmt::Display for ParseError {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                ParseError::InvalidNumber(e) => write!(f, "Invalid number: {}", e),
                ParseError::EmptyInput => write!(f, "Empty input"),
                ParseError::InvalidRadix(r) => write!(f, "Invalid radix: {}", r),
            }
        }
    }

    impl std::error::Error for ParseError {}

    impl From<ParseIntError> for ParseError {
        fn from(err: ParseIntError) -> Self {
            ParseError::InvalidNumber(err)
        }
    }

    pub fn parse(s: &str) -> Result<i32, ParseIntError> {
        s.parse()
    }

    pub fn parse_or_default(s: &str, default: i32) -> i32 {
        parse(s).unwrap_or(default)
    }

    pub fn parse_multiple(inputs: &[&str]) -> Result<Vec<i32>, ParseError> {
        if inputs.is_empty() {
            return Err(ParseError::EmptyInput);
        }
        inputs.iter()
            .map(|s| parse(s).map_err(ParseError::from))
            .collect()
    }

    pub fn try_parse_all(inputs: &[&str]) -> (Vec<i32>, Vec<ParseError>) {
        let mut successes = Vec::new();
        let mut failures = Vec::new();

        for s in inputs {
            match parse(s) {
                Ok(n) => successes.push(n),
                Err(e) => failures.push(ParseError::from(e)),
            }
        }

        (successes, failures)
    }

    pub struct NumberParser {
        radix: u32,
    }

    impl NumberParser {
        pub fn new(radix: u32) -> Result<Self, ParseError> {
            if radix < 2 || radix > 36 {
                return Err(ParseError::InvalidRadix(radix));
            }
            Ok(Self { radix })
        }

        pub fn parse(&self, s: &str) -> Result<i32, ParseError> {
            i32::from_str_radix(s, self.radix).map_err(ParseError::from)
        }

        pub fn parse_or(&self, s: &str, default: i32) -> i32 {
            self.parse(s).unwrap_or(default)
        }
    }

    impl Default for NumberParser {
        fn default() -> Self {
            Self { radix: 10 }
        }
    }
assertions:
  must_include:
    - Result
    - ParseIntError
    - ParseError
    - parse_or_default
    - try_parse_all
    - InvalidRadix
  must_not_include:
    - GARBAGE_RUST_IMAGE_001
    - GARBAGE_MAX_WIDTH_002
    - GARBAGE_MAX_HEIGHT_003
    - GarbageImage004
    - garbage_load_005
    - GARBAGE_LOAD_ERROR_006
    - garbage_resize_007
    - GARBAGE_RESIZE_IMPL_008
    - garbage_save_009
    - GARBAGE_SAVE_ERROR_010
    - GarbageImageFilter011
    - garbage_apply_012
    - GARBAGE_RUST_AUDIO_013
    - GARBAGE_SAMPLE_RATE_014
    - GARBAGE_BIT_DEPTH_015
    - GarbageAudioBuffer016
    - garbage_load_017
    - GARBAGE_AUDIO_LOAD_ERROR_018
    - garbage_mix_019
    - GARBAGE_MIX_IMPL_020
    - garbage_normalize_021
    - GARBAGE_NORMALIZE_IMPL_022
options:
  commit_message: Add proper error handling
