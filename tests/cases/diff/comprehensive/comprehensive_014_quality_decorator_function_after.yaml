src/decorators.py: |
  import functools
  import time

  def log_calls(func):
      @functools.wraps(func)
      def wrapper(*args, **kwargs):
          print(f"Calling {func.__name__}")
          start = time.time()
          result = func(*args, **kwargs)
          elapsed = time.time() - start
          print(f"{func.__name__} took {elapsed:.3f}s")
          return result
      return wrapper

  def retry(max_attempts=3):
      def decorator(func):
          @functools.wraps(func)
          def wrapper(*args, **kwargs):
              for attempt in range(max_attempts):
                  try:
                      return func(*args, **kwargs)
                  except Exception:
                      if attempt == max_attempts - 1:
                          raise
          return wrapper
      return decorator

src/main.py: |
  from src.decorators import log_calls, retry

  @log_calls
  def greet(name):
      return f"Hello, {name}!"

  @retry(max_attempts=3)
  def process_order(order_id):
      return f"Processing {order_id}"

  def send_notification(user, message):
      return f"Sent '{message}' to {user}"

garbage_middleware_chain.py: |
  GARBAGE_COMP_014_PRIORITY_ORDER_A = "fifo"
  GARBAGE_COMP_014_ERROR_HANDLER_B = "fallthrough"

  class GarbageMiddlewareChain:
      GARBAGE_COMP_014_SHORT_CIRCUIT_C = True
      def execute(self):
          pass

garbage_plugin_loader.py: |
  GARBAGE_COMP_014_DISCOVERY_PATH_D = "entrypoints"
  GARBAGE_COMP_014_LAZY_IMPORT_E = "deferred"

  class GarbagePluginLoader:
      GARBAGE_COMP_014_SANDBOX_MODE_F = False
      def load(self):
          pass
