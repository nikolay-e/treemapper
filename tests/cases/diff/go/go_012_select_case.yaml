name: go_012_select_case
initial:
  internal/mux/multiplexer.go: |
    package mux

    import (
        "context"
        "time"
    )

    type Event struct {
        Source  string
        Payload interface{}
    }

    type Multiplexer struct {
        inputs  []<-chan Event
        output  chan<- Event
        timeout time.Duration
    }

    func NewMultiplexer(output chan<- Event, timeout time.Duration) *Multiplexer {
        return &Multiplexer{
            output:  output,
            timeout: timeout,
        }
    }

    func (m *Multiplexer) AddInput(ch <-chan Event) {
        m.inputs = append(m.inputs, ch)
    }

    func (m *Multiplexer) Run(ctx context.Context) {
        for {
            select {
            case <-ctx.Done():
                return
            default:
                m.processInputs(ctx)
            }
        }
    }

    func (m *Multiplexer) processInputs(ctx context.Context) {
        for _, ch := range m.inputs {
            select {
            case evt := <-ch:
                m.output <- evt
            default:
            }
        }
    }

  internal/unrelated/router/fanout.go: |
    package router

    const GARBAGE_GO_ROUTER_FANOUT_001 = "router_garbage"

    type GARBAGE_GO_TYPE_FANOUT_002 struct {
        subscribers []chan interface{}
    }

    func GARBAGE_GO_FUNC_FANOUT_003() string {
        return "GARBAGE_GO_FANOUT_UNUSED_004"
    }

  internal/unrelated/router/loadbalancer.go: |
    package router

    const GARBAGE_GO_ROUTER_LB_005 = "loadbalancer_garbage"

    type GARBAGE_GO_TYPE_LB_006 struct {
        backends []string
    }

    func GARBAGE_GO_FUNC_LB_007() {
        println("GARBAGE_GO_LB_OUTPUT_008")
    }

changed:
  internal/mux/multiplexer.go: |
    package mux

    import (
        "context"
        "log"
        "sync"
        "time"
    )

    type Event struct {
        Source    string
        Payload   interface{}
        Timestamp time.Time
        Priority  int
    }

    type MultiplexerStats struct {
        Received  int64
        Forwarded int64
        Dropped   int64
        Timeouts  int64
    }

    type Multiplexer struct {
        inputs   []<-chan Event
        output   chan<- Event
        timeout  time.Duration
        done     chan struct{}
        logger   *log.Logger
        stats    MultiplexerStats
        mu       sync.RWMutex
    }

    func NewMultiplexer(output chan<- Event, timeout time.Duration, logger *log.Logger) *Multiplexer {
        return &Multiplexer{
            output:  output,
            timeout: timeout,
            done:    make(chan struct{}),
            logger:  logger,
        }
    }

    func (m *Multiplexer) AddInput(ch <-chan Event) {
        m.mu.Lock()
        defer m.mu.Unlock()
        m.inputs = append(m.inputs, ch)
    }

    func (m *Multiplexer) Run(ctx context.Context) {
        var wg sync.WaitGroup

        for i, ch := range m.inputs {
            wg.Add(1)
            go m.handleInput(ctx, ch, i, &wg)
        }

        wg.Wait()
        close(m.done)
    }

    func (m *Multiplexer) handleInput(ctx context.Context, ch <-chan Event, idx int, wg *sync.WaitGroup) {
        defer wg.Done()

        for {
            select {
            case evt, ok := <-ch:
                if !ok {
                    m.logger.Printf("Input %d closed", idx)
                    return
                }
                m.stats.Received++
                m.forward(ctx, evt)

            case <-ctx.Done():
                m.logger.Printf("Context cancelled for input %d", idx)
                return

            case <-m.done:
                return

            case <-time.After(m.timeout):
                m.stats.Timeouts++
                m.logger.Printf("Timeout on input %d", idx)
            }
        }
    }

    func (m *Multiplexer) forward(ctx context.Context, evt Event) {
        select {
        case m.output <- evt:
            m.stats.Forwarded++
        case <-ctx.Done():
            m.stats.Dropped++
        case <-time.After(100 * time.Millisecond):
            m.stats.Dropped++
            m.logger.Printf("Dropped event from %s: output full", evt.Source)
        }
    }

    func (m *Multiplexer) Stats() MultiplexerStats {
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.stats
    }

    func (m *Multiplexer) Stop() {
        close(m.done)
    }

assertions:
  must_include:
    - Multiplexer
    - MultiplexerStats
    - handleInput
    - forward
    - select
    - done
    - Timeouts
  must_not_include:
    - GARBAGE_GO_ROUTER_FANOUT_001
    - GARBAGE_GO_TYPE_FANOUT_002
    - GARBAGE_GO_FUNC_FANOUT_003
    - GARBAGE_GO_FANOUT_UNUSED_004
    - GARBAGE_GO_ROUTER_LB_005
    - GARBAGE_GO_TYPE_LB_006
    - GARBAGE_GO_FUNC_LB_007
    - GARBAGE_GO_LB_OUTPUT_008
    - fanout
    - loadbalancer
options:
  commit_message: Add stats tracking and graceful shutdown to multiplexer
