internal/logging/logger.go: |
  package logging

  import (
      "fmt"
      "log"
      "time"
  )

  type Level int

  const (
      DEBUG Level = iota
      INFO
      WARN
      ERROR
  )

  type Logger struct {
      level  Level
      prefix string
  }

  func NewLogger(prefix string, level Level) *Logger {
      return &Logger{prefix: prefix, level: level}
  }

  func (l *Logger) Log(level Level, format string, args ...interface{}) {
      if level < l.level {
          return
      }
      msg := fmt.Sprintf(format, args...)
      log.Printf("[%s] %s: %s", levelName(level), l.prefix, msg)
  }

  func levelName(level Level) string {
      switch level {
      case DEBUG:
          return "DEBUG"
      case INFO:
          return "INFO"
      case WARN:
          return "WARN"
      case ERROR:
          return "ERROR"
      }
      return "UNKNOWN"
  }
internal/app/application.go: |
  package app

  import (
      "context"
      "myproject/internal/logging"
      "time"
  )

  type Application struct {
      logger  *logging.Logger
      version string
      config  *Config
  }

  type Config struct {
      Name        string
      Environment string
      Debug       bool
  }

  func NewApplication(logger *logging.Logger, config *Config, version string) *Application {
      return &Application{
          logger:  logger,
          config:  config,
          version: version,
      }
  }

  func (a *Application) Run(ctx context.Context) error {
      a.logger.Log(logging.INFO, "Starting %s version %s in %s mode",
          a.config.Name, a.version, a.config.Environment)

      if a.config.Debug {
          a.logger.Log(logging.DEBUG, "Debug mode enabled")
      }

      return a.startServices(ctx)
  }

  func (a *Application) startServices(ctx context.Context) error {
      a.logger.Log(logging.INFO, "Initializing services...")

      services := []string{"database", "cache", "http"}
      for _, svc := range services {
          a.logger.Log(logging.DEBUG, "Starting service: %s", svc)
          time.Sleep(10 * time.Millisecond)
      }

      a.logger.Log(logging.INFO, "All %d services started successfully", len(services))
      return nil
  }

  func (a *Application) Shutdown(ctx context.Context) error {
      a.logger.Log(logging.INFO, "Shutting down %s...", a.config.Name)
      return nil
  }

  func (a *Application) LogMetrics(metrics ...interface{}) {
      a.logger.Log(logging.INFO, "Metrics: %v", metrics)
  }
internal/unrelated/metrics/collector.go: |
  package metrics

  const GARBAGE_GO_METRICS_COLLECT_001 = "metrics_garbage"

  type GARBAGE_GO_TYPE_METRICS_002 struct {
      endpoint string
  }

  func GARBAGE_GO_FUNC_METRICS_003() string {
      return "GARBAGE_GO_METRICS_UNUSED_004"
  }
internal/unrelated/metrics/exporter.go: |
  package metrics

  const GARBAGE_GO_METRICS_EXPORT_005 = "exporter_garbage"

  type GARBAGE_GO_TYPE_EXPORT_006 struct {
      format string
  }

  func GARBAGE_GO_FUNC_EXPORT_007() {
      println("GARBAGE_GO_EXPORT_OUTPUT_008")
  }
