name: go_020_method_value
initial:
  internal/notification/notifier.go: |
    package notification

    import "log"

    type Notifier struct {
        prefix string
        logger *log.Logger
    }

    func NewNotifier(prefix string, logger *log.Logger) *Notifier {
        return &Notifier{prefix: prefix, logger: logger}
    }

    func (n *Notifier) Notify(msg string) {
        n.logger.Printf("[%s] %s", n.prefix, msg)
    }

    func (n *Notifier) Alert(msg string) {
        n.logger.Printf("[ALERT][%s] %s", n.prefix, msg)
    }

    func (n *Notifier) Error(msg string) {
        n.logger.Printf("[ERROR][%s] %s", n.prefix, msg)
    }

  internal/dispatch/dispatcher.go: |
    package dispatch

    func Dispatch() {}

  internal/unrelated/email/smtp.go: |
    package email

    const GARBAGE_GO_EMAIL_SMTP_001 = "email_garbage"

    type GARBAGE_GO_TYPE_SMTP_002 struct {
        host string
    }

    func GARBAGE_GO_FUNC_SMTP_003() string {
        return "GARBAGE_GO_SMTP_UNUSED_004"
    }

  internal/unrelated/email/template.go: |
    package email

    const GARBAGE_GO_EMAIL_TEMPLATE_005 = "template_garbage"

    type GARBAGE_GO_TYPE_TEMPLATE_006 struct {
        path string
    }

    func GARBAGE_GO_FUNC_TEMPLATE_007() {
        println("GARBAGE_GO_TEMPLATE_OUTPUT_008")
    }

changed:
  internal/dispatch/dispatcher.go: |
    package dispatch

    import (
        "context"
        "log"
        "sync"
        "time"
    )

    type Callback func(string)

    type EventType string

    const (
        EventInfo  EventType = "info"
        EventAlert EventType = "alert"
        EventError EventType = "error"
    )

    type Dispatcher struct {
        callbacks map[EventType][]Callback
        logger    *log.Logger
        mu        sync.RWMutex
    }

    func NewDispatcher(logger *log.Logger) *Dispatcher {
        return &Dispatcher{
            callbacks: make(map[EventType][]Callback),
            logger:    logger,
        }
    }

    func (d *Dispatcher) Register(eventType EventType, callback Callback) {
        d.mu.Lock()
        defer d.mu.Unlock()
        d.callbacks[eventType] = append(d.callbacks[eventType], callback)
    }

    func (d *Dispatcher) Dispatch(eventType EventType, msg string) {
        d.mu.RLock()
        callbacks := d.callbacks[eventType]
        d.mu.RUnlock()

        for _, cb := range callbacks {
            cb(msg)
        }
    }

    func (d *Dispatcher) DispatchAsync(ctx context.Context, eventType EventType, msg string) {
        d.mu.RLock()
        callbacks := d.callbacks[eventType]
        d.mu.RUnlock()

        var wg sync.WaitGroup
        for _, cb := range callbacks {
            wg.Add(1)
            go func(callback Callback) {
                defer wg.Done()
                select {
                case <-ctx.Done():
                    return
                default:
                    callback(msg)
                }
            }(cb)
        }
        wg.Wait()
    }

    func (d *Dispatcher) DispatchWithTimeout(eventType EventType, msg string, timeout time.Duration) {
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()
        d.DispatchAsync(ctx, eventType, msg)
    }

    func SetupNotifications(dispatcher *Dispatcher, notifier interface {
        Notify(string)
        Alert(string)
        Error(string)
    }) {
        dispatcher.Register(EventInfo, notifier.Notify)
        dispatcher.Register(EventAlert, notifier.Alert)
        dispatcher.Register(EventError, notifier.Error)
    }

assertions:
  must_include:
    - Dispatcher
    - Dispatch
    - DispatchAsync
    - DispatchWithTimeout
    - SetupNotifications
    - Callback
    - EventType
    - Register
  must_not_include:
    - GARBAGE_GO_EMAIL_SMTP_001
    - GARBAGE_GO_TYPE_SMTP_002
    - GARBAGE_GO_FUNC_SMTP_003
    - GARBAGE_GO_SMTP_UNUSED_004
    - GARBAGE_GO_EMAIL_TEMPLATE_005
    - GARBAGE_GO_TYPE_TEMPLATE_006
    - GARBAGE_GO_FUNC_TEMPLATE_007
    - GARBAGE_GO_TEMPLATE_OUTPUT_008
    - smtp.go
    - template.go
options:
  commit_message: Add event dispatcher with method values as callbacks
