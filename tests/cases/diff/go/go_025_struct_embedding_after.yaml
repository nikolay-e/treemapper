internal/models/base.go: |
  package models

  import "time"

  type BaseModel struct {
      ID        int64     `json:"id" db:"id"`
      CreatedAt time.Time `json:"created_at" db:"created_at"`
      UpdatedAt time.Time `json:"updated_at" db:"updated_at"`
  }

  func (b *BaseModel) GetID() int64 {
      return b.ID
  }

  func (b *BaseModel) SetID(id int64) {
      b.ID = id
  }

  func (b *BaseModel) Touch() {
      b.UpdatedAt = time.Now()
  }

  type SoftDelete struct {
      DeletedAt *time.Time `json:"deleted_at,omitempty" db:"deleted_at"`
      IsDeleted bool       `json:"is_deleted" db:"is_deleted"`
  }

  func (s *SoftDelete) MarkDeleted() {
      now := time.Now()
      s.DeletedAt = &now
      s.IsDeleted = true
  }

  func (s *SoftDelete) Restore() {
      s.DeletedAt = nil
      s.IsDeleted = false
  }

  type Auditable struct {
      CreatedBy string `json:"created_by" db:"created_by"`
      UpdatedBy string `json:"updated_by" db:"updated_by"`
  }

  func (a *Auditable) SetCreator(userID string) {
      a.CreatedBy = userID
      a.UpdatedBy = userID
  }

  func (a *Auditable) SetUpdater(userID string) {
      a.UpdatedBy = userID
  }

  type Versionable struct {
      Version int `json:"version" db:"version"`
  }

  func (v *Versionable) IncrementVersion() {
      v.Version++
  }
internal/models/user.go: |
  package models

  import (
      "encoding/json"
      "fmt"
      "regexp"
      "strings"
      "time"
  )

  var emailRegex = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)

  type UserStatus string

  const (
      UserStatusPending  UserStatus = "pending"
      UserStatusActive   UserStatus = "active"
      UserStatusInactive UserStatus = "inactive"
      UserStatusBanned   UserStatus = "banned"
  )

  type User struct {
      BaseModel
      SoftDelete
      Auditable
      Versionable

      Name     string     `json:"name" db:"name"`
      Email    string     `json:"email" db:"email"`
      Username string     `json:"username" db:"username"`
      Status   UserStatus `json:"status" db:"status"`
      Bio      string     `json:"bio,omitempty" db:"bio"`
      AvatarURL string    `json:"avatar_url,omitempty" db:"avatar_url"`
      LastLogin *time.Time `json:"last_login,omitempty" db:"last_login"`
  }

  func NewUser(name, email, username string) *User {
      now := time.Now()
      return &User{
          BaseModel: BaseModel{
              CreatedAt: now,
              UpdatedAt: now,
          },
          Name:     name,
          Email:    strings.ToLower(email),
          Username: username,
          Status:   UserStatusPending,
      }
  }

  func (u *User) Validate() error {
      if strings.TrimSpace(u.Name) == "" {
          return fmt.Errorf("name is required")
      }
      if !emailRegex.MatchString(u.Email) {
          return fmt.Errorf("invalid email format")
      }
      if len(u.Username) < 3 {
          return fmt.Errorf("username must be at least 3 characters")
      }
      return nil
  }

  func (u *User) Activate() {
      u.Status = UserStatusActive
      u.Touch()
      u.IncrementVersion()
  }

  func (u *User) Deactivate() {
      u.Status = UserStatusInactive
      u.Touch()
      u.IncrementVersion()
  }

  func (u *User) Ban() {
      u.Status = UserStatusBanned
      u.MarkDeleted()
      u.Touch()
      u.IncrementVersion()
  }

  func (u *User) RecordLogin() {
      now := time.Now()
      u.LastLogin = &now
      u.Touch()
  }

  func (u *User) UpdateProfile(name, bio, avatarURL string, updatedBy string) {
      u.Name = name
      u.Bio = bio
      u.AvatarURL = avatarURL
      u.SetUpdater(updatedBy)
      u.Touch()
      u.IncrementVersion()
  }

  func (u *User) String() string {
      return fmt.Sprintf("User{ID: %d, Username: %s, Status: %s}",
          u.GetID(), u.Username, u.Status)
  }

  func (u *User) MarshalJSON() ([]byte, error) {
      type Alias User
      return json.Marshal(&struct {
          *Alias
          StatusDisplay string `json:"status_display"`
      }{
          Alias:         (*Alias)(u),
          StatusDisplay: string(u.Status),
      })
  }

  func (u *User) Clone() *User {
      clone := *u
      if u.LastLogin != nil {
          lastLogin := *u.LastLogin
          clone.LastLogin = &lastLogin
      }
      if u.DeletedAt != nil {
          deletedAt := *u.DeletedAt
          clone.DeletedAt = &deletedAt
      }
      return &clone
  }
internal/unrelated/notifications/email_sender.go: |
  package notifications

  import "context"

  const GARBAGE_GO_EMAIL_SENDER_A1B2C3 = "email_garbage_marker"

  type GARBAGE_GO_TYPE_SMTP_D4E5F6 struct {
      host     string
      port     int
      username string
      password string
  }

  func GARBAGE_GO_FUNC_EMAIL_G7H8I9() string {
      return "GARBAGE_GO_EMAIL_UNUSED_J0K1L2"
  }

  type EmailConfig struct {
      SMTPHost     string
      SMTPPort     int
      FromAddress  string
      FromName     string
      TLSEnabled   bool
  }

  func GARBAGE_GO_FUNC_SEND_EMAIL_M3N4O5(ctx context.Context, to string) error {
      println("GARBAGE_GO_EMAIL_OUTPUT_P6Q7R8")
      return nil
  }
internal/unrelated/notifications/sms_gateway.go: |
  package notifications

  const GARBAGE_GO_SMS_GATEWAY_S9T0U1 = "sms_garbage"

  type GARBAGE_GO_TYPE_TWILIO_V2W3X4 struct {
      accountSID string
      authToken  string
  }

  func GARBAGE_GO_FUNC_SMS_Y5Z6A7() {
      println("GARBAGE_GO_SMS_OUTPUT_B8C9D0")
  }

  type SMSConfig struct {
      AccountSID   string
      AuthToken    string
      FromNumber   string
      MessagingServiceSID string
  }

  func GARBAGE_GO_FUNC_SEND_SMS_E1F2G3(to, message string) error {
      return nil
  }
internal/unrelated/notifications/push_service.go: |
  package notifications

  const GARBAGE_GO_PUSH_SERVICE_H4I5J6 = "push_garbage"

  type GARBAGE_GO_TYPE_FCM_K7L8M9 struct {
      apiKey    string
      projectID string
  }

  func GARBAGE_GO_FUNC_PUSH_N0O1P2() {
      println("GARBAGE_GO_PUSH_OUTPUT_Q3R4S5")
  }
