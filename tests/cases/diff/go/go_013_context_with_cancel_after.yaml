internal/service/processor.go: |
  package service

  import (
      "context"
      "errors"
      "log"
      "sync"
      "time"
  )

  var (
      ErrProcessingTimeout = errors.New("processing timeout")
      ErrMaxRetriesExceeded = errors.New("max retries exceeded")
  )

  type ProcessorConfig struct {
      Timeout       time.Duration
      MaxRetries    int
      BatchSize     int
      RetryDelay    time.Duration
      EnableMetrics bool
  }

  type ProcessorMetrics struct {
      Processed   int64
      Failed      int64
      Retried     int64
      TotalTime   time.Duration
  }

  type Processor struct {
      config  ProcessorConfig
      logger  *log.Logger
      metrics ProcessorMetrics
      mu      sync.RWMutex
  }

  func NewProcessor(config ProcessorConfig, logger *log.Logger) *Processor {
      if config.Timeout == 0 {
          config.Timeout = 30 * time.Second
      }
      if config.MaxRetries == 0 {
          config.MaxRetries = 3
      }
      return &Processor{config: config, logger: logger}
  }

  func (p *Processor) Process(ctx context.Context, data []byte) error {
      ctx, cancel := context.WithTimeout(ctx, p.config.Timeout)
      defer cancel()

      start := time.Now()
      var lastErr error

      for attempt := 0; attempt <= p.config.MaxRetries; attempt++ {
          if attempt > 0 {
              p.incrementRetried()
              select {
              case <-ctx.Done():
                  return ctx.Err()
              case <-time.After(p.config.RetryDelay * time.Duration(attempt)):
              }
          }

          err := p.doWorkWithContext(ctx, data)
          if err == nil {
              p.recordSuccess(time.Since(start))
              return nil
          }

          lastErr = err
          if !p.isRetryable(err) {
              break
          }
      }

      p.recordFailure()
      if lastErr != nil {
          return lastErr
      }
      return ErrMaxRetriesExceeded
  }

  func (p *Processor) doWorkWithContext(ctx context.Context, data []byte) error {
      resultCh := make(chan error, 1)

      go func() {
          resultCh <- p.doWork(data)
      }()

      select {
      case err := <-resultCh:
          return err
      case <-ctx.Done():
          return ErrProcessingTimeout
      }
  }

  func (p *Processor) doWork(data []byte) error {
      time.Sleep(100 * time.Millisecond)
      return nil
  }

  func (p *Processor) isRetryable(err error) bool {
      return !errors.Is(err, context.Canceled)
  }

  func (p *Processor) incrementRetried() {
      p.mu.Lock()
      p.metrics.Retried++
      p.mu.Unlock()
  }

  func (p *Processor) recordSuccess(duration time.Duration) {
      p.mu.Lock()
      p.metrics.Processed++
      p.metrics.TotalTime += duration
      p.mu.Unlock()
  }

  func (p *Processor) recordFailure() {
      p.mu.Lock()
      p.metrics.Failed++
      p.mu.Unlock()
  }

  func (p *Processor) Metrics() ProcessorMetrics {
      p.mu.RLock()
      defer p.mu.RUnlock()
      return p.metrics
  }
internal/handler/request_handler.go: |
  package handler

  import (
      "context"
      "myproject/internal/service"
  )

  type RequestHandler struct {
      processor *service.Processor
  }

  func NewRequestHandler(processor *service.Processor) *RequestHandler {
      return &RequestHandler{processor: processor}
  }

  func (h *RequestHandler) Handle(ctx context.Context, data []byte) error {
      ctx, cancel := context.WithCancel(ctx)
      defer cancel()
      return h.processor.Process(ctx, data)
  }
internal/unrelated/lifecycle/manager.go: |
  package lifecycle

  const GARBAGE_GO_LIFECYCLE_MGR_001 = "lifecycle_garbage"

  type GARBAGE_GO_TYPE_LIFECYCLE_002 struct {
      state string
  }

  func GARBAGE_GO_FUNC_LIFECYCLE_003() string {
      return "GARBAGE_GO_LIFECYCLE_UNUSED_004"
  }
internal/unrelated/lifecycle/hooks.go: |
  package lifecycle

  const GARBAGE_GO_LIFECYCLE_HOOKS_005 = "hooks_garbage"

  type GARBAGE_GO_TYPE_HOOKS_006 struct {
      callbacks []func()
  }

  func GARBAGE_GO_FUNC_HOOKS_007() {
      println("GARBAGE_GO_HOOKS_OUTPUT_008")
  }
