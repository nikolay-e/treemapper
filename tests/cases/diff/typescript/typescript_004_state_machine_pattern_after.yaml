src/types/order.ts: |
  export type OrderStatus =
    | 'pending'
    | 'confirmed'
    | 'processing'
    | 'shipped'
    | 'delivered'
    | 'cancelled';

  export interface OrderItem {
    productId: string;
    productName: string;
    quantity: number;
    unitPrice: number;
  }

  export interface Order {
    id: string;
    customerId: string;
    items: OrderItem[];
    status: OrderStatus;
    total: number;
    createdAt: Date;
    updatedAt: Date;
  }
src/services/orderService.ts: |
  import { Order, OrderStatus, OrderItem } from '../types/order';

  type StateTransition = {
    from: OrderStatus[];
    to: OrderStatus;
    guard?: (order: Order) => boolean;
  };

  const TRANSITIONS: StateTransition[] = [
    { from: ['pending'], to: 'confirmed' },
    { from: ['confirmed'], to: 'processing' },
    { from: ['processing'], to: 'shipped' },
    { from: ['shipped'], to: 'delivered' },
    { from: ['pending', 'confirmed'], to: 'cancelled' },
  ];

  export class OrderStateMachine {
    canTransition(order: Order, targetStatus: OrderStatus): boolean {
      const transition = TRANSITIONS.find(
        (t) => t.to === targetStatus && t.from.includes(order.status)
      );
      if (!transition) return false;
      if (transition.guard && !transition.guard(order)) return false;
      return true;
    }

    transition(order: Order, targetStatus: OrderStatus): Order {
      if (!this.canTransition(order, targetStatus)) {
        throw new Error(
          `Invalid transition from ${order.status} to ${targetStatus}`
        );
      }
      return {
        ...order,
        status: targetStatus,
        updatedAt: new Date(),
      };
    }

    getAvailableTransitions(order: Order): OrderStatus[] {
      return TRANSITIONS
        .filter((t) => t.from.includes(order.status))
        .filter((t) => !t.guard || t.guard(order))
        .map((t) => t.to);
    }
  }

  export class OrderService {
    private stateMachine = new OrderStateMachine();

    confirmOrder(order: Order): Order {
      return this.stateMachine.transition(order, 'confirmed');
    }

    processOrder(order: Order): Order {
      return this.stateMachine.transition(order, 'processing');
    }

    shipOrder(order: Order): Order {
      return this.stateMachine.transition(order, 'shipped');
    }

    deliverOrder(order: Order): Order {
      return this.stateMachine.transition(order, 'delivered');
    }

    cancelOrder(order: Order): Order {
      return this.stateMachine.transition(order, 'cancelled');
    }
  }
vendor/notification-sdk/index.ts: |
  // GARBAGE_TS_004_NOTIFY_001 - third party notification SDK
  export const GARBAGE_TS_004_VERSION_002 = "1.5.0";

  export function GARBAGE_TS_004_send_003(msg: string): void {
    console.log('GARBAGE_TS_004_SENDING_004:', msg);
  }
docs/audit/README.md: |
  # Audit Documentation
  GARBAGE_TS_004_AUDIT_005 - audit system overview
  Using GARBAGE_TS_004_LOGGER_006 for tracking.
