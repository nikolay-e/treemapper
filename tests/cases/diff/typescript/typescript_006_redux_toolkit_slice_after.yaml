src/types/auth.ts: |
  export interface User {
    id: string;
    email: string;
    displayName: string;
    role: 'admin' | 'user' | 'guest';
  }

  export interface AuthTokens {
    accessToken: string;
    refreshToken: string;
    expiresIn: number;
  }

  export interface LoginCredentials {
    email: string;
    password: string;
  }

  export interface AuthError {
    code: string;
    message: string;
  }
src/api/authApi.ts: |
  import { User, AuthTokens, LoginCredentials, AuthError } from '../types/auth';

  export interface AuthResponse {
    user: User;
    tokens: AuthTokens;
  }

  export interface ApiResult<T> {
    data?: T;
    error?: AuthError;
  }

  export async function loginApi(credentials: LoginCredentials): Promise<ApiResult<AuthResponse>> {
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials),
      });
      const data = await response.json();
      return response.ok ? { data } : { error: data };
    } catch {
      return { error: { code: 'NETWORK_ERROR', message: 'Failed to connect' } };
    }
  }

  export async function logoutApi(): Promise<void> {
    await fetch('/api/auth/logout', { method: 'POST' });
  }
src/store/authSlice.ts: |
  import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
  import { User, AuthTokens, LoginCredentials, AuthError } from '../types/auth';
  import { loginApi, logoutApi } from '../api/authApi';

  export interface AuthState {
    user: User | null;
    tokens: AuthTokens | null;
    isAuthenticated: boolean;
    isLoading: boolean;
    error: AuthError | null;
  }

  const initialState: AuthState = {
    user: null,
    tokens: null,
    isAuthenticated: false,
    isLoading: false,
    error: null,
  };

  export const login = createAsyncThunk(
    'auth/login',
    async (credentials: LoginCredentials, { rejectWithValue }) => {
      const result = await loginApi(credentials);
      if (result.error) {
        return rejectWithValue(result.error);
      }
      return result.data!;
    }
  );

  export const logout = createAsyncThunk('auth/logout', async () => {
    await logoutApi();
  });

  const authSlice = createSlice({
    name: 'auth',
    initialState,
    reducers: {
      clearError(state) {
        state.error = null;
      },
      setTokens(state, action: PayloadAction<AuthTokens>) {
        state.tokens = action.payload;
      },
    },
    extraReducers: (builder) => {
      builder
        .addCase(login.pending, (state) => {
          state.isLoading = true;
          state.error = null;
        })
        .addCase(login.fulfilled, (state, action) => {
          state.isLoading = false;
          state.user = action.payload.user;
          state.tokens = action.payload.tokens;
          state.isAuthenticated = true;
        })
        .addCase(login.rejected, (state, action) => {
          state.isLoading = false;
          state.error = action.payload as AuthError;
        })
        .addCase(logout.fulfilled, (state) => {
          state.user = null;
          state.tokens = null;
          state.isAuthenticated = false;
        });
    },
  });

  export const { clearError, setTokens } = authSlice.actions;
  export default authSlice.reducer;

  export const selectUser = (state: { auth: AuthState }) => state.auth.user;
  export const selectIsAuthenticated = (state: { auth: AuthState }) => state.auth.isAuthenticated;
src/unrelated/storage.ts: |
  // GARBAGE_TS_006_STORAGE_001 - storage utilities
  export const GARBAGE_TS_006_STORAGE_KEY_002 = 'app_storage_';

  export class GARBAGE_TS_006_StorageManager_003 {
    private readonly GARBAGE_TS_006_VERSION_004 = 1;

    set<T>(key: string, value: T): void {
      localStorage.setItem(GARBAGE_TS_006_STORAGE_KEY_002 + key, JSON.stringify(value));
    }

    get<T>(key: string): T | null {
      const raw = localStorage.getItem(GARBAGE_TS_006_STORAGE_KEY_002 + key);
      return raw ? JSON.parse(raw) : null;
    }

    remove(key: string): void {
      localStorage.removeItem(GARBAGE_TS_006_STORAGE_KEY_002 + key);
    }
  }

  export const GARBAGE_TS_006_storageManager_005 = new GARBAGE_TS_006_StorageManager_003();
src/unrelated/i18n.ts: |
  // GARBAGE_TS_006_I18N_006 - internationalization
  export type GARBAGE_TS_006_Locale_007 = 'en' | 'es' | 'fr' | 'de';

  export class GARBAGE_TS_006_I18n_008 {
    private translations = new Map<GARBAGE_TS_006_Locale_007, Record<string, string>>();
    private currentLocale: GARBAGE_TS_006_Locale_007 = 'en';

    setLocale(locale: GARBAGE_TS_006_Locale_007): void {
      this.currentLocale = locale;
    }

    t(key: string): string {
      return this.translations.get(this.currentLocale)?.[key] || key;
    }
  }

  export const GARBAGE_TS_006_i18n_009 = new GARBAGE_TS_006_I18n_008();
