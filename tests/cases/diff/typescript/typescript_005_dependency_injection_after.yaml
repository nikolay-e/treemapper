src/di/container.ts: |
  export type Constructor<T = unknown> = new (...args: unknown[]) => T;
  export type Factory<T = unknown> = () => T;
  export type ServiceIdentifier<T = unknown> = string | symbol | Constructor<T>;

  export interface ServiceDescriptor<T> {
    identifier: ServiceIdentifier<T>;
    implementation: Constructor<T> | Factory<T>;
    lifecycle: 'singleton' | 'transient';
  }

  export class Container {
    private services = new Map<ServiceIdentifier, ServiceDescriptor<unknown>>();
    private singletons = new Map<ServiceIdentifier, unknown>();

    register<T>(descriptor: ServiceDescriptor<T>): this {
      this.services.set(descriptor.identifier, descriptor as ServiceDescriptor<unknown>);
      return this;
    }

    registerSingleton<T>(identifier: ServiceIdentifier<T>, implementation: Constructor<T> | Factory<T>): this {
      return this.register({ identifier, implementation, lifecycle: 'singleton' });
    }

    registerTransient<T>(identifier: ServiceIdentifier<T>, implementation: Constructor<T> | Factory<T>): this {
      return this.register({ identifier, implementation, lifecycle: 'transient' });
    }

    resolve<T>(identifier: ServiceIdentifier<T>): T {
      const descriptor = this.services.get(identifier);
      if (!descriptor) {
        throw new Error(`Service not found: ${String(identifier)}`);
      }

      if (descriptor.lifecycle === 'singleton') {
        if (!this.singletons.has(identifier)) {
          this.singletons.set(identifier, this.createInstance(descriptor));
        }
        return this.singletons.get(identifier) as T;
      }

      return this.createInstance(descriptor) as T;
    }

    private createInstance(descriptor: ServiceDescriptor<unknown>): unknown {
      const impl = descriptor.implementation;
      return typeof impl === 'function' && impl.prototype
        ? new (impl as Constructor)()
        : (impl as Factory)();
    }
  }
src/services/userService.ts: |
  import { Container, ServiceIdentifier } from '../di/container';

  export interface Logger {
    info(message: string): void;
    error(message: string): void;
  }

  export interface UserRepository {
    findById(id: string): Promise<User | null>;
    save(user: User): Promise<User>;
  }

  export interface User {
    id: string;
    name: string;
    email: string;
  }

  export const LOGGER = Symbol('Logger');
  export const USER_REPOSITORY = Symbol('UserRepository');

  export class UserService {
    constructor(
      private logger: Logger,
      private repository: UserRepository
    ) {}

    async getUser(id: string): Promise<User | null> {
      this.logger.info(`Fetching user: ${id}`);
      return this.repository.findById(id);
    }

    async createUser(name: string, email: string): Promise<User> {
      this.logger.info(`Creating user: ${email}`);
      const user = { id: Date.now().toString(), name, email };
      return this.repository.save(user);
    }
  }

  export function registerServices(container: Container): void {
    container.registerSingleton(LOGGER, () => ({
      info: (msg: string) => console.log(`[INFO] ${msg}`),
      error: (msg: string) => console.error(`[ERROR] ${msg}`),
    }));

    container.registerSingleton(USER_REPOSITORY, () => ({
      findById: async (id: string) => null,
      save: async (user: User) => user,
    }));

    container.registerTransient(UserService, () => {
      const logger = container.resolve<Logger>(LOGGER);
      const repository = container.resolve<UserRepository>(USER_REPOSITORY);
      return new UserService(logger, repository);
    });
  }
src/unrelated/config.ts: |
  // GARBAGE_TS_005_CONFIG_001 - configuration management
  export interface GARBAGE_TS_005_ConfigSchema_002 {
    database: { host: string; port: number };
    redis: { url: string };
    api: { timeout: number };
  }

  export class GARBAGE_TS_005_ConfigLoader_003 {
    private config: Partial<GARBAGE_TS_005_ConfigSchema_002> = {};
    private readonly GARBAGE_TS_005_ENV_PREFIX_004 = 'APP_';

    load(): GARBAGE_TS_005_ConfigSchema_002 {
      return {
        database: { host: 'localhost', port: 5432 },
        redis: { url: 'redis://localhost:6379' },
        api: { timeout: 30000 },
      };
    }

    get<K extends keyof GARBAGE_TS_005_ConfigSchema_002>(key: K): GARBAGE_TS_005_ConfigSchema_002[K] {
      return this.load()[key];
    }
  }

  export const GARBAGE_TS_005_config_005 = new GARBAGE_TS_005_ConfigLoader_003();
src/unrelated/events.ts: |
  // GARBAGE_TS_005_EVENTS_006 - event bus
  export type GARBAGE_TS_005_EventHandler_007<T> = (data: T) => void;

  export class GARBAGE_TS_005_EventBus_008 {
    private handlers = new Map<string, GARBAGE_TS_005_EventHandler_007<unknown>[]>();
    private readonly GARBAGE_TS_005_MAX_LISTENERS_009 = 100;

    on<T>(event: string, handler: GARBAGE_TS_005_EventHandler_007<T>): void {
      const handlers = this.handlers.get(event) || [];
      handlers.push(handler as GARBAGE_TS_005_EventHandler_007<unknown>);
      this.handlers.set(event, handlers);
    }

    emit<T>(event: string, data: T): void {
      const handlers = this.handlers.get(event) || [];
      handlers.forEach((handler) => handler(data));
    }

    off(event: string): void {
      this.handlers.delete(event);
    }
  }

  export const GARBAGE_TS_005_eventBus_010 = new GARBAGE_TS_005_EventBus_008();
