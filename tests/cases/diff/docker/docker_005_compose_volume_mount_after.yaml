src/storage.py: |
  import os
  import json
  from pathlib import Path
  from typing import Any, Optional

  DATA_PATH = Path(os.getenv("DATA_PATH", "/app/data"))
  CONFIG_PATH = Path(os.getenv("CONFIG_PATH", "/app/config"))
  LOGS_PATH = Path(os.getenv("LOGS_PATH", "/app/logs"))

  def ensure_directories():
      DATA_PATH.mkdir(parents=True, exist_ok=True)
      LOGS_PATH.mkdir(parents=True, exist_ok=True)

  def save_data(filename: str, content: dict) -> None:
      filepath = DATA_PATH / filename
      with open(filepath, "w") as f:
          json.dump(content, f, indent=2)

  def load_config(config_name: str) -> Optional[dict]:
      config_file = CONFIG_PATH / f"{config_name}.json"
      if not config_file.exists():
          return None
      with open(config_file) as f:
          return json.load(f)

  def write_log(message: str) -> None:
      log_file = LOGS_PATH / "app.log"
      with open(log_file, "a") as f:
          f.write(f"{message}\n")
src/app.py: |
  from storage import ensure_directories, load_config, write_log

  def main():
      ensure_directories()
      config = load_config("app")
      write_log("Application started")

  if __name__ == "__main__":
      main()
requirements.txt: |
  pyyaml==6.0.0
Dockerfile: |
  FROM python:3.12-slim
  WORKDIR /app
  COPY requirements.txt .
  RUN pip install -r requirements.txt
  COPY src/ ./src/
  CMD ["python", "src/app.py"]
docker-compose.yml: |
  version: '3.8'

  services:
    app:
      build:
        context: .
        dockerfile: Dockerfile
      volumes:
        # Persistent data - survives container recreation
        - app_data:/app/data

        # Read-only config from host
        - ./config:/app/config:ro

        # Named volume for logs with custom driver
        - app_logs:/app/logs

        # Temporary storage - cleared on restart
        - type: tmpfs
          target: /app/tmp
          tmpfs:
            size: 100M
            mode: 1777

        # Bind mount for development hot-reload
        - type: bind
          source: ./src
          target: /app/src
          read_only: false

      environment:
        - DATA_PATH=/app/data
        - CONFIG_PATH=/app/config
        - LOGS_PATH=/app/logs
      restart: unless-stopped

    backup:
      image: alpine:latest
      volumes:
        - app_data:/data:ro
        - ./backups:/backups
      command: sh -c "tar -czf /backups/backup-$$(date +%Y%m%d).tar.gz /data"
      profiles:
        - backup

  volumes:
    app_data:
      driver: local
      driver_opts:
        type: none
        o: bind
        device: ${PWD}/persistent_data

    app_logs:
      driver: local
      labels:
        com.example.description: "Application logs"
        com.example.retention: "7d"
scripts/backup.sh: |
  #!/bin/bash
  # GARBAGE_DOCKER_075_BACKUP_MARKER_a1s2d3
  GARBAGE_DOCKER_075_BACKUP_PATH_f4g5h6="/backup"
  tar -czf backup.tar.gz ./data
tests/test_storage.py: |
  # GARBAGE_DOCKER_075_TEST_MARKER_j7k8l9
  GARBAGE_DOCKER_075_TEST_PATH_q0w1e2 = "/tmp/test_data"
  def test_save_data():
      pass
docs/volumes.md: |
  # Volume Configuration
  GARBAGE_DOCKER_075_VOL_DOC_r3t4y5
  GARBAGE_DOCKER_075_MOUNT_POINTS_u6i7o8="data,config,logs"
k8s/pvc.yaml: |
  # GARBAGE_DOCKER_075_K8S_MARKER_p9a0s1
  apiVersion: v1
  GARBAGE_DOCKER_075_PVC_TYPE_d2f3g4: PersistentVolumeClaim
terraform/storage.tf: |
  # GARBAGE_DOCKER_075_TF_MARKER_h5j6k7
  resource "aws_ebs_volume" "data" {
    GARBAGE_DOCKER_075_EBS_SIZE_l8z9x0 = 100
  }
