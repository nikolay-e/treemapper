src/proxy.py: "import requests\nimport os\nfrom flask import Flask, jsonify\n\napp = Flask(__name__)\n\nBACKEND_URL = os.getenv(\"BACKEND_URL\", \"http://backend:8080\")\nAPI_URL = os.getenv(\"API_URL\"\
  , \"http://api:8080\")\n\ndef call_backend(endpoint: str):\n    response = requests.get(f\"{BACKEND_URL}{endpoint}\")\n    return response.json()\n\ndef call_api(endpoint: str):\n    response = requests.get(f\"\
  {API_URL}{endpoint}\")\n    return response.json()\n\n@app.route('/health')\ndef health():\n    return jsonify(status='ok', service='proxy')\n\n@app.route('/proxy/backend/<path:path>')\ndef proxy_backend(path):\n\
  \    return call_backend(f'/{path}')\n\n@app.route('/proxy/api/<path:path>')\ndef proxy_api(path):\n    return call_api(f'/{path}')\n"
src/api.py: "from flask import Flask, jsonify\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health():\n    return jsonify(status='ok', service='api')\n\n@app.route('/users')\ndef users():\n   \
  \ return jsonify(users=['alice', 'bob'])\n"
requirements.txt: 'flask==2.3.0

  requests==2.31.0

  gunicorn==21.2.0

  '
Dockerfile: 'FROM python:3.12-slim

  WORKDIR /app

  COPY requirements.txt .

  RUN pip install -r requirements.txt

  COPY src/ ./src/

  CMD ["gunicorn", "-b", "0.0.0.0:8080", "src.proxy:app"]

  '
docker-compose.yml: "version: '3.8'\n\nservices:\n  web:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    ports:\n      - \"80:8080\"\n    environment:\n      - BACKEND_URL=http://api:8080\n\
  \      - API_URL=http://api:8080\n    networks:\n      frontend:\n        aliases:\n          - proxy\n          - gateway\n      backend:\n    depends_on:\n      api:\n        condition: service_healthy\n\
  \    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8080/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  api:\n    build:\n      context: .\n      dockerfile:\
  \ Dockerfile\n    command: [\"gunicorn\", \"-b\", \"0.0.0.0:8080\", \"src.api:app\"]\n    networks:\n      backend:\n        ipv4_address: 172.20.0.10\n      data:\n    healthcheck:\n      test: [\"CMD\"\
  , \"curl\", \"-f\", \"http://localhost:8080/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  db:\n    image: postgres:16-alpine\n    environment:\n      POSTGRES_PASSWORD: secret\n\
  \    networks:\n      data:\n        ipv4_address: 172.21.0.10\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n\n  redis:\n    image: redis:7-alpine\n    networks:\n      data:\n      \
  \  aliases:\n          - cache\n          - session-store\n\n  monitoring:\n    image: prom/prometheus:latest\n    networks:\n      - frontend\n      - backend\n      - data\n    ports:\n      - \"9090:9090\"\
  \n\nnetworks:\n  frontend:\n    driver: bridge\n    driver_opts:\n      com.docker.network.bridge.name: br-frontend\n    ipam:\n      driver: default\n      config:\n        - subnet: 172.19.0.0/24\n\
  \          gateway: 172.19.0.1\n\n  backend:\n    driver: bridge\n    internal: true\n    ipam:\n      config:\n        - subnet: 172.20.0.0/24\n\n  data:\n    driver: bridge\n    internal: true\n   \
  \ ipam:\n      config:\n        - subnet: 172.21.0.0/24\n    labels:\n      - \"com.example.description=Data tier network\"\n\nvolumes:\n  postgres_data:\n"
scripts/network_setup.sh: '#!/bin/bash

  docker network create frontend

  '
tests/test_network.py: "def test_network_connectivity():\n    pass\n"
docs/networking.md: '# Network Architecture

  '
terraform/vpc.tf: 'resource "aws_vpc" "main" {

  }

  '
k8s/network-policy.yaml: 'apiVersion: networking.k8s.io/v1

  '
