babel.config.json: |
  {
    "presets": ["@babel/preset-env"],
    "plugins": [
      "@babel/plugin-proposal-class-properties",
      "@babel/plugin-transform-runtime"
    ],
    "env": {
      "test": {
        "presets": ["@babel/preset-env"]
      }
    }
  }
src/modern.js: |
  const greet = (name) => `Hello, ${name}`;

  const createPipeline = (...fns) => (input) =>
      fns.reduce((acc, fn) => fn(acc), input);

  class MessageBuilder {
      #prefix = '';

      constructor(prefix) {
          this.#prefix = prefix;
      }

      build(text) {
          return `${this.#prefix}: ${text}`;
      }

      withTimestamp(text) {
          const ts = new Date().toISOString();
          return this.build(`[${ts}] ${text}`);
      }
  }

  const formatOutput = createPipeline(
      (s) => s.trim(),
      (s) => s.toLowerCase(),
      (s) => s.replace(/\s+/g, '-')
  );

  export { greet, createPipeline, MessageBuilder, formatOutput };
  export default greet;
src/runtime.js: |
  import { greet, MessageBuilder } from './modern';

  const builder = new MessageBuilder('APP');

  function startApp(userName) {
      const welcome = greet(userName);
      const message = builder.withTimestamp(welcome);
      console.log(message);
      return message;
  }

  function processMessage(text) {
      return builder.build(text);
  }

  export { startApp, processMessage };
unrelated/hasher.js: |
  const GARBAGE_JSON_006_HASH_SALT_A = 'default_salt_value';

  class GARBAGE_JSON_006_STRING_HASHER_B {
      constructor(salt) {
          this.salt = salt || GARBAGE_JSON_006_HASH_SALT_A;
      }

      hash(input) {
          let hash = 0;
          const salted = this.salt + input;
          for (let i = 0; i < salted.length; i++) {
              const char = salted.charCodeAt(i);
              hash = ((hash << 5) - hash) + char;
              hash = hash & hash;
          }
          return Math.abs(hash).toString(36);
      }
  }

  function GARBAGE_JSON_006_QUICK_HASH_C(value) {
      const hasher = new GARBAGE_JSON_006_STRING_HASHER_B();
      return hasher.hash(value);
  }

  module.exports = { GARBAGE_JSON_006_STRING_HASHER_B, GARBAGE_JSON_006_QUICK_HASH_C };
unrelated/batcher.js: |
  const GARBAGE_JSON_006_BATCH_SIZE_D = 100;

  class GARBAGE_JSON_006_REQUEST_BATCHER_E {
      constructor(size) {
          this.batchSize = size || GARBAGE_JSON_006_BATCH_SIZE_D;
          this.queue = [];
          this.results = [];
      }

      add(item) {
          this.queue.push(item);
          if (this.queue.length >= this.batchSize) {
              this.flush();
          }
      }

      flush() {
          this.results.push([...this.queue]);
          this.queue = [];
      }

      getResults() {
          if (this.queue.length > 0) this.flush();
          return this.results;
      }
  }

  function GARBAGE_JSON_006_BATCH_PROCESS_F(items) {
      const batcher = new GARBAGE_JSON_006_REQUEST_BATCHER_E();
      items.forEach(item => batcher.add(item));
      return batcher.getResults();
  }

  module.exports = { GARBAGE_JSON_006_REQUEST_BATCHER_E, GARBAGE_JSON_006_BATCH_PROCESS_F };
