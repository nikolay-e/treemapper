name: cpp_252_static_cast
initial:
  include/widget/hierarchy.hpp: |
    #pragma once
    #include <string>
    #include <vector>
    #include <memory>

    namespace app::widget {

    class Widget {
    public:
        explicit Widget(const std::string& name)
            : name_(name), visible_(true) {}

        virtual ~Widget() = default;

        const std::string& name() const { return name_; }
        bool isVisible() const { return visible_; }
        void setVisible(bool visible) { visible_ = visible; }

        virtual void render() = 0;
        virtual void update(float deltaTime) {}
        virtual std::string typeName() const { return "Widget"; }

    protected:
        std::string name_;
        bool visible_;
    };

    class Button : public Widget {
    public:
        Button(const std::string& name, const std::string& label)
            : Widget(name), label_(label), pressed_(false) {}

        void render() override {}
        std::string typeName() const override { return "Button"; }

        const std::string& label() const { return label_; }
        bool isPressed() const { return pressed_; }
        void press() { pressed_ = true; }
        void release() { pressed_ = false; }

    private:
        std::string label_;
        bool pressed_;
    };

    class TextInput : public Widget {
    public:
        TextInput(const std::string& name, size_t maxLength = 256)
            : Widget(name), maxLength_(maxLength) {}

        void render() override {}
        std::string typeName() const override { return "TextInput"; }

        const std::string& text() const { return text_; }
        void setText(const std::string& text) {
            text_ = text.substr(0, maxLength_);
        }
        size_t maxLength() const { return maxLength_; }

    private:
        std::string text_;
        size_t maxLength_;
    };

    }

  include/unrelated/particle_system.hpp: |
    #pragma once
    // GARBAGE_CPP_PARTICLE_252_001
    #define GARBAGE_CPP_PARTICLE_MAX_252_002 10000

    namespace app::unrelated::particles {

    // GARBAGE_CPP_PARTICLE_STRUCT_252_003
    struct Particle {
        float position[3];
        float velocity[3];
        float lifetime;
        // GARBAGE_CPP_PARTICLE_COLOR_252_004
    };

    // GARBAGE_CPP_PARTICLE_EMITTER_252_005
    class ParticleEmitter {
    public:
        // GARBAGE_CPP_PARTICLE_EMIT_252_006
        void emit(int count) {
            // GARBAGE_CPP_PARTICLE_EMIT_IMPL_252_007
        }

        // GARBAGE_CPP_PARTICLE_UPDATE_252_008
        void update(float deltaTime) {
            // GARBAGE_CPP_PARTICLE_UPDATE_IMPL_252_009
        }

        // GARBAGE_CPP_PARTICLE_RENDER_252_010
        void render() {
            // GARBAGE_CPP_PARTICLE_RENDER_IMPL_252_011
        }
    };

    }

  src/unrelated/audio_mixer.cpp: |
    // GARBAGE_CPP_AUDIO_252_012
    namespace app::unrelated::audio {

    // GARBAGE_CPP_AUDIO_CHANNEL_252_013
    struct AudioChannel {
        float volume;
        float pan;
        bool muted;
    };

    // GARBAGE_CPP_AUDIO_MIXER_252_014
    class AudioMixer {
    public:
        // GARBAGE_CPP_AUDIO_MIX_252_015
        void mixChannels() {
            // GARBAGE_CPP_AUDIO_MIX_IMPL_252_016
        }

        // GARBAGE_CPP_AUDIO_SETVOLUME_252_017
        void setMasterVolume(float volume) {
            // GARBAGE_CPP_AUDIO_SETVOLUME_IMPL_252_018
        }
    };

    }

  src/handler.cpp: |
    #include <iostream>
    int main() { return 0; }

changed:
  src/handler.cpp: |
    #include "widget/hierarchy.hpp"
    #include <iostream>
    #include <vector>
    #include <memory>

    namespace app::ui {

    class WidgetContainer {
    public:
        void addWidget(std::unique_ptr<widget::Widget> w) {
            widgets_.push_back(std::move(w));
        }

        widget::Widget* getWidget(size_t index) {
            return index < widgets_.size() ? widgets_[index].get() : nullptr;
        }

        template<typename T>
        T* getWidgetAs(size_t index) {
            auto* w = getWidget(index);
            return w ? static_cast<T*>(w) : nullptr;
        }

        size_t count() const { return widgets_.size(); }

        void renderAll() {
            for (auto& w : widgets_) {
                if (w->isVisible()) {
                    w->render();
                }
            }
        }

    private:
        std::vector<std::unique_ptr<widget::Widget>> widgets_;
    };

    class FormHandler {
    public:
        explicit FormHandler(WidgetContainer& container)
            : container_(container) {}

        void handleButtonClick(size_t buttonIndex) {
            auto* button = container_.getWidgetAs<widget::Button>(buttonIndex);
            if (button) {
                button->press();
                std::cout << "Button '" << button->label() << "' pressed\n";
            }
        }

        void handleTextInput(size_t inputIndex, const std::string& text) {
            auto* input = container_.getWidgetAs<widget::TextInput>(inputIndex);
            if (input) {
                input->setText(text);
                std::cout << "TextInput updated: " << input->text() << "\n";
            }
        }

        std::string getInputText(size_t inputIndex) {
            auto* input = container_.getWidgetAs<widget::TextInput>(inputIndex);
            return input ? input->text() : "";
        }

        void processNumericInput(size_t inputIndex, int& outValue) {
            auto* input = container_.getWidgetAs<widget::TextInput>(inputIndex);
            if (input && !input->text().empty()) {
                outValue = static_cast<int>(std::stol(input->text()));
            }
        }

        void setWidgetOpacity(size_t index, double opacity) {
            auto* widget = container_.getWidget(index);
            if (widget) {
                int alphaValue = static_cast<int>(opacity * 255.0);
                std::cout << "Set alpha to " << alphaValue << " for " << widget->name() << "\n";
            }
        }

    private:
        WidgetContainer& container_;
    };

    void printWidgetInfo(widget::Widget* w) {
        std::cout << "Widget: " << w->name() << " (type: " << w->typeName() << ")\n";

        if (w->typeName() == "Button") {
            auto* button = static_cast<widget::Button*>(w);
            std::cout << "  Label: " << button->label() << "\n";
            std::cout << "  Pressed: " << (button->isPressed() ? "yes" : "no") << "\n";
        } else if (w->typeName() == "TextInput") {
            auto* input = static_cast<widget::TextInput*>(w);
            std::cout << "  Text: " << input->text() << "\n";
            std::cout << "  Max length: " << input->maxLength() << "\n";
        }
    }

    }

    int main() {
        app::ui::WidgetContainer container;

        container.addWidget(std::make_unique<app::widget::Button>("submitBtn", "Submit"));
        container.addWidget(std::make_unique<app::widget::TextInput>("nameInput", 100));
        container.addWidget(std::make_unique<app::widget::Button>("cancelBtn", "Cancel"));

        app::ui::FormHandler handler(container);

        handler.handleTextInput(1, "John Doe");
        handler.handleButtonClick(0);

        for (size_t i = 0; i < container.count(); ++i) {
            app::ui::printWidgetInfo(container.getWidget(i));
        }

        handler.setWidgetOpacity(0, 0.8);

        return 0;
    }

assertions:
  must_include:
    - WidgetContainer
    - FormHandler
    - static_cast
    - Widget
    - Button
    - TextInput
    - getWidgetAs
  must_not_include:
    - GARBAGE_CPP_PARTICLE_252_001
    - GARBAGE_CPP_PARTICLE_MAX_252_002
    - GARBAGE_CPP_PARTICLE_STRUCT_252_003
    - GARBAGE_CPP_PARTICLE_EMITTER_252_005
    - GARBAGE_CPP_PARTICLE_EMIT_252_006
    - GARBAGE_CPP_AUDIO_252_012
    - GARBAGE_CPP_AUDIO_CHANNEL_252_013
    - GARBAGE_CPP_AUDIO_MIXER_252_014
    - GARBAGE_CPP_AUDIO_MIX_252_015
    - ParticleEmitter
    - AudioMixer
    - Particle
    - AudioChannel
options:
  commit_message: Add widget form handler with static_cast for type conversion
