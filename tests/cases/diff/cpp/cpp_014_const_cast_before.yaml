include/legacy/string_api.h: |
  #pragma once
  #include <cstddef>

  void legacy_trim(char* str);
  void legacy_to_upper(char* str);
  size_t legacy_count_chars(char* str, char target);

  struct LegacyStringBuffer {
      char data[256];
      size_t length;
  };

  void legacy_init_buffer(LegacyStringBuffer* buf, char* initial);
  void legacy_append(LegacyStringBuffer* buf, char* suffix);
src/legacy/string_api.cpp: |
  #include "legacy/string_api.h"
  #include <cctype>
  #include <cstring>

  void legacy_trim(char* str) {
      size_t len = std::strlen(str);
      while (len > 0 && std::isspace(str[len - 1])) {
          str[--len] = '\0';
      }
      char* start = str;
      while (*start && std::isspace(*start)) ++start;
      if (start != str) std::memmove(str, start, std::strlen(start) + 1);
  }

  void legacy_to_upper(char* str) {
      for (char* p = str; *p; ++p) {
          *p = static_cast<char>(std::toupper(*p));
      }
  }

  size_t legacy_count_chars(char* str, char target) {
      size_t count = 0;
      for (char* p = str; *p; ++p) {
          if (*p == target) ++count;
      }
      return count;
  }

  void legacy_init_buffer(LegacyStringBuffer* buf, char* initial) {
      std::strncpy(buf->data, initial, sizeof(buf->data) - 1);
      buf->data[sizeof(buf->data) - 1] = '\0';
      buf->length = std::strlen(buf->data);
  }

  void legacy_append(LegacyStringBuffer* buf, char* suffix) {
      size_t remaining = sizeof(buf->data) - buf->length - 1;
      std::strncat(buf->data, suffix, remaining);
      buf->length = std::strlen(buf->data);
  }
src/adapter/const_adapter.cpp: |
  #include <iostream>
  int main() { return 0; }
include/unrelated/color_palette.hpp: |
  #pragma once
  // GARBAGE_CPP_014_PALETTE_A
  #include <array>
  #include <cstdint>

  namespace unrelated {

  // GARBAGE_CPP_014_PALETTE_B
  struct ColorRGB {
      uint8_t r, g, b;
      float luminance() const {
          return 0.299f * r + 0.587f * g + 0.114f * b;
      }
  };

  // GARBAGE_CPP_014_PALETTE_C
  class ColorPalette {
  public:
      void addColor(ColorRGB color) { colors_[count_++] = color; }
      ColorRGB getColor(size_t index) const { return colors_[index]; }
      size_t size() const { return count_; }
  private:
      std::array<ColorRGB, 64> colors_{};
      size_t count_ = 0;
  };

  }
src/unrelated/csv_parser.cpp: |
  // GARBAGE_CPP_014_CSV_D
  #include <string>
  #include <vector>
  #include <sstream>

  namespace unrelated {

  // GARBAGE_CPP_014_CSV_E
  class CsvParser {
  public:
      std::vector<std::string> parseLine(const std::string& line) {
          // GARBAGE_CPP_014_PARSE_F
          std::vector<std::string> fields;
          std::istringstream stream(line);
          std::string field;
          while (std::getline(stream, field, ',')) {
              fields.push_back(field);
          }
          return fields;
      }

      size_t countFields(const std::string& line) {
          return parseLine(line).size();
      }
  };

  }
