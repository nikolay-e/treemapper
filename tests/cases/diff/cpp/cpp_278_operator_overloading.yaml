name: cpp_278_operator_overloading
initial:
  include/math/vector.hpp: |
    #pragma once
    #include <cmath>
    #include <ostream>
    #include <stdexcept>
    #include <array>
    #include <initializer_list>

    namespace app::math {

    template<typename T, size_t N>
    class Vector {
    public:
        Vector() : data_{} {}

        Vector(std::initializer_list<T> init) {
            size_t i = 0;
            for (auto val : init) {
                if (i >= N) break;
                data_[i++] = val;
            }
        }

        T& operator[](size_t i) {
            if (i >= N) throw std::out_of_range("Index out of range");
            return data_[i];
        }

        const T& operator[](size_t i) const {
            if (i >= N) throw std::out_of_range("Index out of range");
            return data_[i];
        }

        Vector operator+(const Vector& other) const {
            Vector result;
            for (size_t i = 0; i < N; ++i) {
                result.data_[i] = data_[i] + other.data_[i];
            }
            return result;
        }

        Vector operator-(const Vector& other) const {
            Vector result;
            for (size_t i = 0; i < N; ++i) {
                result.data_[i] = data_[i] - other.data_[i];
            }
            return result;
        }

        Vector operator*(T scalar) const {
            Vector result;
            for (size_t i = 0; i < N; ++i) {
                result.data_[i] = data_[i] * scalar;
            }
            return result;
        }

        Vector operator/(T scalar) const {
            Vector result;
            for (size_t i = 0; i < N; ++i) {
                result.data_[i] = data_[i] / scalar;
            }
            return result;
        }

        Vector& operator+=(const Vector& other) {
            for (size_t i = 0; i < N; ++i) {
                data_[i] += other.data_[i];
            }
            return *this;
        }

        Vector& operator-=(const Vector& other) {
            for (size_t i = 0; i < N; ++i) {
                data_[i] -= other.data_[i];
            }
            return *this;
        }

        Vector& operator*=(T scalar) {
            for (size_t i = 0; i < N; ++i) {
                data_[i] *= scalar;
            }
            return *this;
        }

        Vector operator-() const {
            Vector result;
            for (size_t i = 0; i < N; ++i) {
                result.data_[i] = -data_[i];
            }
            return result;
        }

        bool operator==(const Vector& other) const {
            for (size_t i = 0; i < N; ++i) {
                if (data_[i] != other.data_[i]) return false;
            }
            return true;
        }

        bool operator!=(const Vector& other) const {
            return !(*this == other);
        }

        T dot(const Vector& other) const {
            T result = T{};
            for (size_t i = 0; i < N; ++i) {
                result += data_[i] * other.data_[i];
            }
            return result;
        }

        T lengthSquared() const { return dot(*this); }

        double length() const { return std::sqrt(static_cast<double>(lengthSquared())); }

        Vector normalized() const {
            double len = length();
            if (len < 1e-10) return *this;
            return *this / static_cast<T>(len);
        }

        static constexpr size_t size() { return N; }

        T* begin() { return data_.data(); }
        T* end() { return data_.data() + N; }
        const T* begin() const { return data_.data(); }
        const T* end() const { return data_.data() + N; }

    private:
        std::array<T, N> data_;
    };

    template<typename T, size_t N>
    std::ostream& operator<<(std::ostream& os, const Vector<T, N>& v) {
        os << "(";
        for (size_t i = 0; i < N; ++i) {
            if (i > 0) os << ", ";
            os << v[i];
        }
        os << ")";
        return os;
    }

    template<typename T, size_t N>
    Vector<T, N> operator*(T scalar, const Vector<T, N>& v) {
        return v * scalar;
    }

    using Vec2 = Vector<double, 2>;
    using Vec3 = Vector<double, 3>;
    using Vec4 = Vector<double, 4>;
    using Vec2i = Vector<int, 2>;
    using Vec3i = Vector<int, 3>;

    }

  include/unrelated/json_builder.hpp: |
    #pragma once
    // GARBAGE_CPP_JSON_278_001
    #define GARBAGE_CPP_JSON_DEPTH_278_002 64

    namespace app::unrelated::json {

    // GARBAGE_CPP_JSON_TYPE_278_003
    enum class JsonType {
        Null, Boolean, Number, String, Array, Object
    };

    // GARBAGE_CPP_JSON_VALUE_278_004
    struct JsonValue {
        JsonType type;
        // GARBAGE_CPP_JSON_DATA_278_005
    };

    // GARBAGE_CPP_JSON_BUILDER_278_006
    class JsonBuilder {
    public:
        // GARBAGE_CPP_JSON_OBJ_278_007
        JsonBuilder& beginObject() {
            // GARBAGE_CPP_JSON_OBJ_IMPL_278_008
            return *this;
        }

        // GARBAGE_CPP_JSON_ARR_278_009
        JsonBuilder& beginArray() {
            // GARBAGE_CPP_JSON_ARR_IMPL_278_010
            return *this;
        }

        // GARBAGE_CPP_JSON_KEY_278_011
        JsonBuilder& key(const char* k) {
            // GARBAGE_CPP_JSON_KEY_IMPL_278_012
            return *this;
        }

        // GARBAGE_CPP_JSON_VAL_278_013
        JsonBuilder& value(int v) {
            // GARBAGE_CPP_JSON_VAL_IMPL_278_014
            return *this;
        }
    };

    }

  src/unrelated/markdown_parser.cpp: |
    // GARBAGE_CPP_MD_278_015
    #include <string>
    #include <vector>

    namespace app::unrelated::markdown {

    // GARBAGE_CPP_MD_NODE_278_016
    enum class NodeType {
        Paragraph, Heading, List, Code, Quote
    };

    // GARBAGE_CPP_MD_ELEMENT_278_017
    struct MarkdownNode {
        NodeType type;
        std::string content;
        // GARBAGE_CPP_MD_CHILDREN_278_018
    };

    // GARBAGE_CPP_MD_PARSER_278_019
    class MarkdownParser {
    public:
        // GARBAGE_CPP_MD_PARSE_278_020
        std::vector<MarkdownNode> parse(const std::string& text) {
            // GARBAGE_CPP_MD_PARSE_IMPL_278_021
            return {};
        }

        // GARBAGE_CPP_MD_TO_HTML_278_022
        std::string toHtml(const std::vector<MarkdownNode>& nodes) {
            // GARBAGE_CPP_MD_HTML_IMPL_278_023
            return "";
        }
    };

    }

  src/physics.cpp: |
    #include <iostream>
    int main() { return 0; }

changed:
  src/physics.cpp: |
    #include "math/vector.hpp"
    #include <iostream>
    #include <vector>
    #include <cmath>

    namespace app::physics {

    using namespace math;

    struct Particle {
        Vec3 position;
        Vec3 velocity;
        Vec3 acceleration;
        double mass;

        Particle(Vec3 pos, Vec3 vel, double m)
            : position(pos), velocity(vel), acceleration({0, 0, 0}), mass(m) {}

        void applyForce(const Vec3& force) {
            acceleration += force / mass;
        }

        void update(double dt) {
            velocity += acceleration * dt;
            position += velocity * dt;
            acceleration = Vec3{0, 0, 0};
        }

        Vec3 momentum() const {
            return velocity * mass;
        }

        double kineticEnergy() const {
            return 0.5 * mass * velocity.lengthSquared();
        }
    };

    class PhysicsWorld {
    public:
        void addParticle(const Particle& p) {
            particles_.push_back(p);
        }

        void setGravity(const Vec3& g) {
            gravity_ = g;
        }

        void step(double dt) {
            for (auto& p : particles_) {
                Vec3 gravityForce = gravity_ * p.mass;
                p.applyForce(gravityForce);
                p.update(dt);
            }
        }

        Vec3 totalMomentum() const {
            Vec3 total{0, 0, 0};
            for (const auto& p : particles_) {
                total += p.momentum();
            }
            return total;
        }

        double totalEnergy() const {
            double total = 0;
            for (const auto& p : particles_) {
                total += p.kineticEnergy();
                total += p.mass * (-gravity_.dot(p.position));
            }
            return total;
        }

        size_t particleCount() const { return particles_.size(); }

        const Particle& getParticle(size_t i) const { return particles_[i]; }

    private:
        std::vector<Particle> particles_;
        Vec3 gravity_{0, -9.81, 0};
    };

    class Transform {
    public:
        Transform() : position_{0, 0, 0}, scale_{1, 1, 1} {}

        Transform& translate(const Vec3& delta) {
            position_ += delta;
            return *this;
        }

        Transform& scaleBy(double factor) {
            scale_ *= factor;
            return *this;
        }

        Transform& scaleBy(const Vec3& factors) {
            for (size_t i = 0; i < 3; ++i) {
                scale_[i] *= factors[i];
            }
            return *this;
        }

        Vec3 apply(const Vec3& point) const {
            Vec3 scaled;
            for (size_t i = 0; i < 3; ++i) {
                scaled[i] = point[i] * scale_[i];
            }
            return scaled + position_;
        }

        Transform operator*(const Transform& other) const {
            Transform result;
            result.position_ = apply(other.position_);
            for (size_t i = 0; i < 3; ++i) {
                result.scale_[i] = scale_[i] * other.scale_[i];
            }
            return result;
        }

        const Vec3& position() const { return position_; }
        const Vec3& scale() const { return scale_; }

    private:
        Vec3 position_;
        Vec3 scale_;
    };

    Vec3 cross(const Vec3& a, const Vec3& b) {
        return Vec3{
            a[1] * b[2] - a[2] * b[1],
            a[2] * b[0] - a[0] * b[2],
            a[0] * b[1] - a[1] * b[0]
        };
    }

    Vec3 reflect(const Vec3& incident, const Vec3& normal) {
        return incident - normal * (2.0 * incident.dot(normal));
    }

    double angle(const Vec3& a, const Vec3& b) {
        double cosAngle = a.dot(b) / (a.length() * b.length());
        return std::acos(std::clamp(cosAngle, -1.0, 1.0));
    }

    }

    int main() {
        using namespace app::physics;
        using namespace app::math;

        std::cout << "=== Vector Operations ===\n";
        Vec3 a{1, 2, 3};
        Vec3 b{4, 5, 6};

        std::cout << "a = " << a << "\n";
        std::cout << "b = " << b << "\n";
        std::cout << "a + b = " << (a + b) << "\n";
        std::cout << "a - b = " << (a - b) << "\n";
        std::cout << "a * 2 = " << (a * 2) << "\n";
        std::cout << "2 * a = " << (2.0 * a) << "\n";
        std::cout << "-a = " << (-a) << "\n";
        std::cout << "a.dot(b) = " << a.dot(b) << "\n";
        std::cout << "|a| = " << a.length() << "\n";
        std::cout << "normalized(a) = " << a.normalized() << "\n";
        std::cout << "cross(a, b) = " << cross(a, b) << "\n";
        std::cout << "angle(a, b) = " << angle(a, b) << " rad\n";

        std::cout << "\n=== Physics Simulation ===\n";
        PhysicsWorld world;
        world.setGravity(Vec3{0, -10, 0});

        Particle ball(Vec3{0, 10, 0}, Vec3{5, 0, 0}, 1.0);
        world.addParticle(ball);

        std::cout << "Initial state:\n";
        std::cout << "  Position: " << world.getParticle(0).position << "\n";
        std::cout << "  Velocity: " << world.getParticle(0).velocity << "\n";
        std::cout << "  Energy: " << world.totalEnergy() << "\n";

        for (int i = 0; i < 10; ++i) {
            world.step(0.1);
        }

        std::cout << "\nAfter 1 second:\n";
        std::cout << "  Position: " << world.getParticle(0).position << "\n";
        std::cout << "  Velocity: " << world.getParticle(0).velocity << "\n";
        std::cout << "  Momentum: " << world.totalMomentum() << "\n";

        std::cout << "\n=== Transform ===\n";
        Transform t;
        t.translate(Vec3{1, 2, 3}).scaleBy(2.0);

        Vec3 point{1, 1, 1};
        std::cout << "Original: " << point << "\n";
        std::cout << "Transformed: " << t.apply(point) << "\n";

        std::cout << "\n=== Reflection ===\n";
        Vec3 incident{1, -1, 0};
        Vec3 normal{0, 1, 0};
        std::cout << "Incident: " << incident.normalized() << "\n";
        std::cout << "Normal: " << normal << "\n";
        std::cout << "Reflected: " << reflect(incident, normal).normalized() << "\n";

        return 0;
    }

assertions:
  must_include:
    - Vector
    - Particle
    - PhysicsWorld
    - Transform
    - operator+
    - operator-
    - operator*
    - operator+=
    - operator-=
    - operator[]
    - operator==
    - dot
    - cross
    - reflect
    - normalized
  must_not_include:
    - GARBAGE_CPP_JSON_278_001
    - GARBAGE_CPP_JSON_DEPTH_278_002
    - GARBAGE_CPP_JSON_TYPE_278_003
    - GARBAGE_CPP_JSON_VALUE_278_004
    - GARBAGE_CPP_JSON_DATA_278_005
    - GARBAGE_CPP_JSON_BUILDER_278_006
    - GARBAGE_CPP_JSON_OBJ_278_007
    - GARBAGE_CPP_JSON_ARR_278_009
    - GARBAGE_CPP_JSON_KEY_278_011
    - GARBAGE_CPP_JSON_VAL_278_013
    - GARBAGE_CPP_MD_278_015
    - GARBAGE_CPP_MD_NODE_278_016
    - GARBAGE_CPP_MD_ELEMENT_278_017
    - GARBAGE_CPP_MD_PARSER_278_019
    - GARBAGE_CPP_MD_PARSE_278_020
    - GARBAGE_CPP_MD_TO_HTML_278_022
    - JsonBuilder
    - MarkdownParser
    - JsonValue
    - MarkdownNode
options:
  commit_message: Add physics simulation using template Vector with operator overloading
