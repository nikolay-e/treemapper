name: cpp_263_template_specialization
initial:
  include/serializer/serializer.hpp: |
    #pragma once
    #include <string>
    #include <sstream>
    #include <iomanip>
    #include <vector>
    #include <type_traits>

    namespace app::serializer {

    template<typename T>
    struct Serializer {
        static std::string serialize(const T& value) {
            std::ostringstream oss;
            oss << value;
            return oss.str();
        }

        static T deserialize(const std::string& str) {
            std::istringstream iss(str);
            T value;
            iss >> value;
            return value;
        }
    };

    template<>
    struct Serializer<bool> {
        static std::string serialize(bool value) {
            return value ? "true" : "false";
        }

        static bool deserialize(const std::string& str) {
            return str == "true" || str == "1";
        }
    };

    template<>
    struct Serializer<std::string> {
        static std::string serialize(const std::string& value) {
            std::ostringstream oss;
            oss << '"';
            for (char c : value) {
                if (c == '"') oss << "\\\"";
                else if (c == '\\') oss << "\\\\";
                else if (c == '\n') oss << "\\n";
                else oss << c;
            }
            oss << '"';
            return oss.str();
        }

        static std::string deserialize(const std::string& str) {
            if (str.size() < 2 || str.front() != '"' || str.back() != '"') {
                return str;
            }
            std::string result;
            for (size_t i = 1; i < str.size() - 1; ++i) {
                if (str[i] == '\\' && i + 1 < str.size() - 1) {
                    char next = str[i + 1];
                    if (next == '"') { result += '"'; ++i; }
                    else if (next == '\\') { result += '\\'; ++i; }
                    else if (next == 'n') { result += '\n'; ++i; }
                    else result += str[i];
                } else {
                    result += str[i];
                }
            }
            return result;
        }
    };

    template<>
    struct Serializer<double> {
        static std::string serialize(double value) {
            std::ostringstream oss;
            oss << std::setprecision(15) << value;
            return oss.str();
        }

        static double deserialize(const std::string& str) {
            return std::stod(str);
        }
    };

    template<typename T>
    struct Serializer<std::vector<T>> {
        static std::string serialize(const std::vector<T>& vec) {
            std::ostringstream oss;
            oss << "[";
            for (size_t i = 0; i < vec.size(); ++i) {
                if (i > 0) oss << ",";
                oss << Serializer<T>::serialize(vec[i]);
            }
            oss << "]";
            return oss.str();
        }
    };

    }

  include/unrelated/cache_manager.hpp: |
    #pragma once
    // GARBAGE_CPP_CACHE_263_001
    #define GARBAGE_CPP_CACHE_SIZE_263_002 1024

    namespace app::unrelated::cache {

    // GARBAGE_CPP_CACHE_ENTRY_263_003
    struct CacheEntry {
        void* data;
        size_t size;
        // GARBAGE_CPP_CACHE_TIMESTAMP_263_004
        unsigned long timestamp;
    };

    // GARBAGE_CPP_CACHE_MANAGER_263_005
    class CacheManager {
    public:
        // GARBAGE_CPP_CACHE_GET_263_006
        void* get(const char* key) {
            // GARBAGE_CPP_CACHE_GET_IMPL_263_007
            return nullptr;
        }

        // GARBAGE_CPP_CACHE_PUT_263_008
        void put(const char* key, void* data, size_t size) {
            // GARBAGE_CPP_CACHE_PUT_IMPL_263_009
        }

        // GARBAGE_CPP_CACHE_EVICT_263_010
        void evict(const char* key) {
            // GARBAGE_CPP_CACHE_EVICT_IMPL_263_011
        }

        // GARBAGE_CPP_CACHE_CLEAR_263_012
        void clear() {
            // GARBAGE_CPP_CACHE_CLEAR_IMPL_263_013
        }
    };

    }

  src/unrelated/thread_pool.cpp: |
    // GARBAGE_CPP_THREADPOOL_263_014
    #include <functional>

    namespace app::unrelated::threading {

    // GARBAGE_CPP_THREADPOOL_TASK_263_015
    using TaskFunction = std::function<void()>;

    // GARBAGE_CPP_THREADPOOL_CLASS_263_016
    class ThreadPool {
    public:
        // GARBAGE_CPP_THREADPOOL_SUBMIT_263_017
        void submit(TaskFunction task) {
            // GARBAGE_CPP_THREADPOOL_SUBMIT_IMPL_263_018
        }

        // GARBAGE_CPP_THREADPOOL_SHUTDOWN_263_019
        void shutdown() {
            // GARBAGE_CPP_THREADPOOL_SHUTDOWN_IMPL_263_020
        }

        // GARBAGE_CPP_THREADPOOL_SIZE_263_021
        size_t pendingTasks() const {
            // GARBAGE_CPP_THREADPOOL_SIZE_IMPL_263_022
            return 0;
        }
    };

    }

  src/formatter.cpp: |
    #include <iostream>
    int main() { return 0; }

changed:
  src/formatter.cpp: |
    #include "serializer/serializer.hpp"
    #include <iostream>
    #include <map>
    #include <optional>

    namespace app::format {

    struct Person {
        std::string name;
        int age;
        bool active;
        double salary;
    };

    class DataFormatter {
    public:
        std::string formatPerson(const Person& p) const {
            std::ostringstream oss;
            oss << "Person{";
            oss << "name=" << serializer::Serializer<std::string>::serialize(p.name);
            oss << ",age=" << serializer::Serializer<int>::serialize(p.age);
            oss << ",active=" << serializer::Serializer<bool>::serialize(p.active);
            oss << ",salary=" << serializer::Serializer<double>::serialize(p.salary);
            oss << "}";
            return oss.str();
        }

        std::string formatIntVector(const std::vector<int>& vec) const {
            return serializer::Serializer<std::vector<int>>::serialize(vec);
        }

        std::string formatStringVector(const std::vector<std::string>& vec) const {
            return serializer::Serializer<std::vector<std::string>>::serialize(vec);
        }

        std::string formatKeyValue(const std::string& key, int value) const {
            return serializer::Serializer<std::string>::serialize(key) +
                   ":" + serializer::Serializer<int>::serialize(value);
        }

        std::string formatKeyValue(const std::string& key, bool value) const {
            return serializer::Serializer<std::string>::serialize(key) +
                   ":" + serializer::Serializer<bool>::serialize(value);
        }
    };

    class RecordBuilder {
    public:
        RecordBuilder& addField(const std::string& name, int value) {
            fields_[name] = serializer::Serializer<int>::serialize(value);
            return *this;
        }

        RecordBuilder& addField(const std::string& name, bool value) {
            fields_[name] = serializer::Serializer<bool>::serialize(value);
            return *this;
        }

        RecordBuilder& addField(const std::string& name, double value) {
            fields_[name] = serializer::Serializer<double>::serialize(value);
            return *this;
        }

        RecordBuilder& addField(const std::string& name, const std::string& value) {
            fields_[name] = serializer::Serializer<std::string>::serialize(value);
            return *this;
        }

        std::string build() const {
            std::ostringstream oss;
            oss << "{";
            bool first = true;
            for (const auto& [key, value] : fields_) {
                if (!first) oss << ",";
                oss << serializer::Serializer<std::string>::serialize(key)
                    << ":" << value;
                first = false;
            }
            oss << "}";
            return oss.str();
        }

        void clear() {
            fields_.clear();
        }

    private:
        std::map<std::string, std::string> fields_;
    };

    class StringParser {
    public:
        std::optional<int> parseInt(const std::string& str) const {
            try {
                return serializer::Serializer<int>::deserialize(str);
            } catch (...) {
                return std::nullopt;
            }
        }

        std::optional<bool> parseBool(const std::string& str) const {
            return serializer::Serializer<bool>::deserialize(str);
        }

        std::optional<double> parseDouble(const std::string& str) const {
            try {
                return serializer::Serializer<double>::deserialize(str);
            } catch (...) {
                return std::nullopt;
            }
        }

        std::string parseString(const std::string& str) const {
            return serializer::Serializer<std::string>::deserialize(str);
        }
    };

    }

    int main() {
        app::format::DataFormatter formatter;

        app::format::Person person{"John Doe", 30, true, 75000.50};
        std::cout << formatter.formatPerson(person) << "\n";

        std::vector<int> numbers = {1, 2, 3, 4, 5};
        std::cout << "Numbers: " << formatter.formatIntVector(numbers) << "\n";

        std::vector<std::string> tags = {"cpp", "templates", "specialization"};
        std::cout << "Tags: " << formatter.formatStringVector(tags) << "\n";

        std::cout << formatter.formatKeyValue("count", 42) << "\n";
        std::cout << formatter.formatKeyValue("enabled", true) << "\n";

        app::format::RecordBuilder builder;
        std::string record = builder
            .addField("id", 12345)
            .addField("name", "Test Record")
            .addField("active", true)
            .addField("score", 98.6)
            .build();
        std::cout << "Record: " << record << "\n";

        app::format::StringParser parser;
        auto intVal = parser.parseInt("42");
        if (intVal) std::cout << "Parsed int: " << *intVal << "\n";

        auto boolVal = parser.parseBool("true");
        if (boolVal) std::cout << "Parsed bool: " << *boolVal << "\n";

        auto strVal = parser.parseString("\"Hello\\nWorld\"");
        std::cout << "Parsed string: " << strVal << "\n";

        return 0;
    }

assertions:
  must_include:
    - DataFormatter
    - RecordBuilder
    - StringParser
    - formatPerson
    - Serializer
    - serialize
    - deserialize
    - formatIntVector
    - addField
  must_not_include:
    - GARBAGE_CPP_CACHE_263_001
    - GARBAGE_CPP_CACHE_SIZE_263_002
    - GARBAGE_CPP_CACHE_ENTRY_263_003
    - GARBAGE_CPP_CACHE_TIMESTAMP_263_004
    - GARBAGE_CPP_CACHE_MANAGER_263_005
    - GARBAGE_CPP_CACHE_GET_263_006
    - GARBAGE_CPP_CACHE_PUT_263_008
    - GARBAGE_CPP_CACHE_EVICT_263_010
    - GARBAGE_CPP_CACHE_CLEAR_263_012
    - GARBAGE_CPP_THREADPOOL_263_014
    - GARBAGE_CPP_THREADPOOL_TASK_263_015
    - GARBAGE_CPP_THREADPOOL_CLASS_263_016
    - GARBAGE_CPP_THREADPOOL_SUBMIT_263_017
    - GARBAGE_CPP_THREADPOOL_SHUTDOWN_263_019
    - GARBAGE_CPP_THREADPOOL_SIZE_263_021
    - CacheManager
    - ThreadPool
    - CacheEntry
    - TaskFunction
options:
  commit_message: Add data formatter and record builder using template specialization
