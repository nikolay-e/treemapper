include/typecheck/type_check.hpp: |
  #pragma once
  #include <type_traits>
  #include <utility>

  namespace app::typecheck {

  template<typename T, typename = void>
  struct has_size : std::false_type {};

  template<typename T>
  struct has_size<T, std::void_t<decltype(std::declval<T>().size())>> : std::true_type {};

  template<typename T, typename = void>
  struct has_begin_end : std::false_type {};

  template<typename T>
  struct has_begin_end<T, std::void_t<
      decltype(std::declval<T>().begin()),
      decltype(std::declval<T>().end())
  >> : std::true_type {};

  template<typename T, typename = void>
  struct has_push_back : std::false_type {};

  template<typename T>
  struct has_push_back<T, std::void_t<
      decltype(std::declval<T>().push_back(std::declval<typename T::value_type>()))
  >> : std::true_type {};

  template<typename T, typename = void>
  struct has_reserve : std::false_type {};

  template<typename T>
  struct has_reserve<T, std::void_t<
      decltype(std::declval<T>().reserve(std::declval<size_t>()))
  >> : std::true_type {};

  template<typename T, typename = void>
  struct is_streamable : std::false_type {};

  template<typename T>
  struct is_streamable<T, std::void_t<
      decltype(std::declval<std::ostream&>() << std::declval<T>())
  >> : std::true_type {};

  template<typename T, typename = void>
  struct has_to_string : std::false_type {};

  template<typename T>
  struct has_to_string<T, std::void_t<
      decltype(std::declval<T>().to_string())
  >> : std::true_type {};

  template<typename T>
  inline constexpr bool has_size_v = has_size<T>::value;

  template<typename T>
  inline constexpr bool has_begin_end_v = has_begin_end<T>::value;

  template<typename T>
  inline constexpr bool is_container_v = has_size_v<T> && has_begin_end_v<T>;

  }
include/unrelated/regex_engine.hpp: |
  #pragma once
  // GARBAGE_CPP_REGEX_265_001
  #define GARBAGE_CPP_REGEX_MAX_GROUPS_265_002 32

  namespace app::unrelated::regex {

  // GARBAGE_CPP_REGEX_MATCH_265_003
  struct RegexMatch {
      const char* start;
      size_t length;
      // GARBAGE_CPP_REGEX_GROUP_265_004
  };

  // GARBAGE_CPP_REGEX_ENGINE_265_005
  class RegexEngine {
  public:
      // GARBAGE_CPP_REGEX_COMPILE_265_006
      bool compile(const char* pattern) {
          // GARBAGE_CPP_REGEX_COMPILE_IMPL_265_007
          return false;
      }

      // GARBAGE_CPP_REGEX_EXEC_265_008
      RegexMatch execute(const char* input) {
          // GARBAGE_CPP_REGEX_EXEC_IMPL_265_009
          return RegexMatch{};
      }

      // GARBAGE_CPP_REGEX_REPLACE_265_010
      const char* replace(const char* input, const char* replacement) {
          // GARBAGE_CPP_REGEX_REPLACE_IMPL_265_011
          return nullptr;
      }
  };

  }
src/unrelated/zip_archive.cpp: |
  // GARBAGE_CPP_ZIP_265_012
  #include <cstddef>

  namespace app::unrelated::archive {

  // GARBAGE_CPP_ZIP_ENTRY_265_013
  struct ZipEntry {
      const char* name;
      size_t compressedSize;
      size_t uncompressedSize;
      // GARBAGE_CPP_ZIP_CRC_265_014
  };

  // GARBAGE_CPP_ZIP_ARCHIVE_265_015
  class ZipArchive {
  public:
      // GARBAGE_CPP_ZIP_OPEN_265_016
      bool open(const char* path) {
          // GARBAGE_CPP_ZIP_OPEN_IMPL_265_017
          return false;
      }

      // GARBAGE_CPP_ZIP_EXTRACT_265_018
      bool extractFile(const char* entryName, const char* destPath) {
          // GARBAGE_CPP_ZIP_EXTRACT_IMPL_265_019
          return false;
      }

      // GARBAGE_CPP_ZIP_CLOSE_265_020
      void close() {
          // GARBAGE_CPP_ZIP_CLOSE_IMPL_265_021
      }
  };

  }
src/printer.cpp: |
  #include "typecheck/type_check.hpp"
  #include <vector>
  #include <string>
  #include <list>
  #include <array>
  #include <iostream>
  #include <sstream>

  namespace app::printing {

  template<typename T>
  std::enable_if_t<typecheck::has_size<T>::value, void>
  printInfo(const T& container) {
      std::cout << "Container with size: " << container.size() << "\n";
  }

  template<typename T>
  std::enable_if_t<!typecheck::has_size<T>::value, void>
  printInfo(const T& value) {
      std::cout << "Non-container value\n";
  }

  template<typename T>
  std::enable_if_t<typecheck::is_container_v<T>, void>
  printElements(const T& container) {
      std::cout << "Elements: ";
      for (const auto& elem : container) {
          std::cout << elem << " ";
      }
      std::cout << "\n";
  }

  template<typename T>
  std::enable_if_t<typecheck::has_push_back<T>::value, void>
  addElement(T& container, const typename T::value_type& value) {
      container.push_back(value);
      std::cout << "Added element via push_back\n";
  }

  template<typename T>
  std::enable_if_t<!typecheck::has_push_back<T>::value && typecheck::has_begin_end<T>::value, void>
  addElement(T& container, const typename T::value_type& value) {
      std::cout << "Container doesn't support push_back\n";
  }

  template<typename T>
  std::enable_if_t<typecheck::has_reserve<T>::value, void>
  prepareCapacity(T& container, size_t capacity) {
      container.reserve(capacity);
      std::cout << "Reserved capacity: " << capacity << "\n";
  }

  template<typename T>
  std::enable_if_t<!typecheck::has_reserve<T>::value, void>
  prepareCapacity(T& container, size_t capacity) {
      std::cout << "Container doesn't support reserve\n";
  }

  class ContainerAnalyzer {
  public:
      template<typename T>
      std::string analyzeCapabilities() const {
          std::ostringstream oss;
          oss << "Capabilities:\n";
          oss << "  has_size: " << typecheck::has_size_v<T> << "\n";
          oss << "  has_begin_end: " << typecheck::has_begin_end_v<T> << "\n";
          oss << "  has_push_back: " << typecheck::has_push_back<T>::value << "\n";
          oss << "  has_reserve: " << typecheck::has_reserve<T>::value << "\n";
          oss << "  is_container: " << typecheck::is_container_v<T> << "\n";
          return oss.str();
      }

      template<typename T>
      void processContainer(T& container) const {
          if constexpr (typecheck::has_reserve<T>::value) {
              container.reserve(100);
          }

          if constexpr (typecheck::is_container_v<T>) {
              std::cout << "Processing container with " << container.size() << " elements\n";
          }
      }
  };

  class StreamPrinter {
  public:
      template<typename T>
      std::enable_if_t<typecheck::is_streamable<T>::value, void>
      print(const T& value) const {
          std::cout << value << "\n";
      }

      template<typename T>
      std::enable_if_t<!typecheck::is_streamable<T>::value, void>
      print(const T& value) const {
          std::cout << "[non-printable type]\n";
      }

      template<typename T>
      std::enable_if_t<typecheck::is_streamable<T>::value, std::string>
      toString(const T& value) const {
          std::ostringstream oss;
          oss << value;
          return oss.str();
      }
  };

  struct CustomType {
      int value;
      std::string to_string() const {
          return "CustomType(" + std::to_string(value) + ")";
      }
  };

  template<typename T>
  std::enable_if_t<typecheck::has_to_string<T>::value, std::string>
  convertToString(const T& obj) {
      return obj.to_string();
  }

  template<typename T>
  std::enable_if_t<!typecheck::has_to_string<T>::value && typecheck::is_streamable<T>::value, std::string>
  convertToString(const T& obj) {
      std::ostringstream oss;
      oss << obj;
      return oss.str();
  }

  }

  int main() {
      std::vector<int> vec{1, 2, 3, 4, 5};
      std::list<double> lst{1.1, 2.2, 3.3};
      std::array<int, 3> arr{10, 20, 30};

      std::cout << "=== Vector ===\n";
      app::printing::printInfo(vec);
      app::printing::printElements(vec);
      app::printing::prepareCapacity(vec, 100);
      app::printing::addElement(vec, 6);
      std::cout << "Vector size after add: " << vec.size() << "\n";

      std::cout << "\n=== List ===\n";
      app::printing::printInfo(lst);
      app::printing::printElements(lst);
      app::printing::prepareCapacity(lst, 100);
      app::printing::addElement(lst, 4.4);

      std::cout << "\n=== Array ===\n";
      app::printing::printInfo(arr);
      app::printing::printElements(arr);

      std::cout << "\n=== Non-container ===\n";
      app::printing::printInfo(42);

      app::printing::ContainerAnalyzer analyzer;
      std::cout << "\n=== Vector capabilities ===\n";
      std::cout << analyzer.analyzeCapabilities<std::vector<int>>();

      std::cout << "\n=== List capabilities ===\n";
      std::cout << analyzer.analyzeCapabilities<std::list<double>>();

      app::printing::StreamPrinter printer;
      std::cout << "\n=== Stream printing ===\n";
      printer.print(42);
      printer.print(3.14);
      printer.print("Hello, SFINAE!");

      std::cout << "toString: " << printer.toString(12345) << "\n";

      app::printing::CustomType custom{42};
      std::cout << "\nCustomType: " << app::printing::convertToString(custom) << "\n";
      std::cout << "Integer: " << app::printing::convertToString(100) << "\n";

      return 0;
  }
