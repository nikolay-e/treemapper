include/ui/drawable.hpp: |
  #pragma once
  #include <string>
  #include <iostream>

  namespace app::ui {

  struct Rect {
      int x, y, width, height;
  };

  struct Color {
      unsigned char r, g, b, a;

      static Color red() { return {255, 0, 0, 255}; }
      static Color green() { return {0, 255, 0, 255}; }
      static Color blue() { return {0, 0, 255, 255}; }
      static Color white() { return {255, 255, 255, 255}; }
      static Color black() { return {0, 0, 0, 255}; }
  };

  class Drawable {
  public:
      virtual ~Drawable() = default;

      virtual void draw() = 0;
      virtual void resize(int w, int h) = 0;
      virtual Rect getBounds() const = 0;

      virtual std::string getName() const {
          return "Drawable";
      }

      virtual void setVisible(bool visible) {
          visible_ = visible;
      }

      virtual bool isVisible() const {
          return visible_;
      }

      virtual void setColor(const Color& color) {
          color_ = color;
      }

      virtual Color getColor() const {
          return color_;
      }

  protected:
      bool visible_ = true;
      Color color_ = Color::white();
  };

  class Transformable {
  public:
      virtual ~Transformable() = default;

      virtual void setPosition(int x, int y) = 0;
      virtual void setScale(float sx, float sy) = 0;
      virtual void setRotation(float degrees) = 0;
  };

  }
include/unrelated/audio_mixer.hpp: |
  #pragma once
  // GARBAGE_CPP_AUDIO_269_001
  #define GARBAGE_CPP_AUDIO_CHANNELS_269_002 8

  namespace app::unrelated::audio {

  // GARBAGE_CPP_AUDIO_SAMPLE_269_003
  struct AudioSample {
      float* data;
      size_t length;
      int sampleRate;
      // GARBAGE_CPP_AUDIO_FORMAT_269_004
  };

  // GARBAGE_CPP_AUDIO_MIXER_269_005
  class AudioMixer {
  public:
      // GARBAGE_CPP_AUDIO_MIX_269_006
      void mixSamples(const AudioSample& a, const AudioSample& b, AudioSample& out) {
          // GARBAGE_CPP_AUDIO_MIX_IMPL_269_007
      }

      // GARBAGE_CPP_AUDIO_VOLUME_269_008
      void setVolume(int channel, float volume) {
          // GARBAGE_CPP_AUDIO_VOL_IMPL_269_009
      }

      // GARBAGE_CPP_AUDIO_PAN_269_010
      void setPan(int channel, float pan) {
          // GARBAGE_CPP_AUDIO_PAN_IMPL_269_011
      }
  };

  }
src/unrelated/shader_compiler.cpp: |
  // GARBAGE_CPP_SHADER_269_012
  #include <string>

  namespace app::unrelated::shader {

  // GARBAGE_CPP_SHADER_TYPE_269_013
  enum class ShaderType {
      Vertex,
      Fragment,
      Geometry,
      Compute
  };

  // GARBAGE_CPP_SHADER_COMPILER_269_014
  class ShaderCompiler {
  public:
      // GARBAGE_CPP_SHADER_COMPILE_269_015
      bool compile(ShaderType type, const std::string& source) {
          // GARBAGE_CPP_SHADER_COMP_IMPL_269_016
          return false;
      }

      // GARBAGE_CPP_SHADER_LINK_269_017
      bool link() {
          // GARBAGE_CPP_SHADER_LINK_IMPL_269_018
          return false;
      }

      // GARBAGE_CPP_SHADER_ERROR_269_019
      std::string getError() {
          // GARBAGE_CPP_SHADER_ERR_IMPL_269_020
          return "";
      }
  };

  }
src/widget.cpp: |
  #include <iostream>
  int main() { return 0; }
