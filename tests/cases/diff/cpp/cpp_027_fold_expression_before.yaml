include/fold/fold_ops.hpp: |
  #pragma once
  #include <type_traits>
  #include <utility>
  #include <iostream>

  namespace app::fold {

  template<typename... Args>
  auto sum(Args... args) {
      return (args + ...);
  }

  template<typename... Args>
  auto product(Args... args) {
      return (args * ...);
  }

  template<typename... Args>
  auto sumWithInit(int init, Args... args) {
      return (init + ... + args);
  }

  template<typename... Args>
  bool allTrue(Args... args) {
      return (... && args);
  }

  template<typename... Args>
  bool anyTrue(Args... args) {
      return (... || args);
  }

  template<typename... Args>
  auto bitwiseAnd(Args... args) {
      return (args & ...);
  }

  template<typename... Args>
  auto bitwiseOr(Args... args) {
      return (args | ...);
  }

  template<typename... Args>
  void printAll(Args... args) {
      ((std::cout << args << " "), ...);
      std::cout << "\n";
  }

  template<typename... Args>
  void printWithSeparator(const char* sep, Args... args) {
      size_t count = 0;
      ((std::cout << (count++ > 0 ? sep : "") << args), ...);
      std::cout << "\n";
  }

  template<typename T, typename... Args>
  bool contains(const T& value, Args... args) {
      return ((value == args) || ...);
  }

  template<typename... Args>
  auto maximum(Args... args) {
      auto maxVal = (args, ...);
      ((maxVal = (args > maxVal ? args : maxVal)), ...);
      return maxVal;
  }

  template<typename... Args>
  auto minimum(Args... args) {
      auto minVal = (args, ...);
      ((minVal = (args < minVal ? args : minVal)), ...);
      return minVal;
  }

  template<typename... Args>
  size_t countArgs(Args... args) {
      return sizeof...(args);
  }

  }
include/unrelated/game_physics.hpp: |
  #pragma once
  // GARBAGE_CPP_PHYSICS_268_001
  #define GARBAGE_CPP_PHYSICS_GRAVITY_268_002 9.81f

  namespace app::unrelated::physics {

  // GARBAGE_CPP_PHYSICS_VEC_268_003
  struct Vector3 {
      float x, y, z;
      // GARBAGE_CPP_PHYSICS_METHODS_268_004
  };

  // GARBAGE_CPP_PHYSICS_BODY_268_005
  struct RigidBody {
      Vector3 position;
      Vector3 velocity;
      float mass;
      // GARBAGE_CPP_PHYSICS_PROPS_268_006
  };

  // GARBAGE_CPP_PHYSICS_ENGINE_268_007
  class PhysicsEngine {
  public:
      // GARBAGE_CPP_PHYSICS_UPDATE_268_008
      void update(float deltaTime) {
          // GARBAGE_CPP_PHYSICS_UPDATE_IMPL_268_009
      }

      // GARBAGE_CPP_PHYSICS_COLLIDE_268_010
      bool checkCollision(const RigidBody& a, const RigidBody& b) {
          // GARBAGE_CPP_PHYSICS_COLL_IMPL_268_011
          return false;
      }

      // GARBAGE_CPP_PHYSICS_ADD_268_012
      void addBody(const RigidBody& body) {
          // GARBAGE_CPP_PHYSICS_ADD_IMPL_268_013
      }
  };

  }
src/unrelated/particle_system.cpp: |
  // GARBAGE_CPP_PARTICLE_268_014
  #include <cstddef>

  namespace app::unrelated::particle {

  // GARBAGE_CPP_PARTICLE_DATA_268_015
  struct Particle {
      float x, y, z;
      float vx, vy, vz;
      float life;
      // GARBAGE_CPP_PARTICLE_COLOR_268_016
  };

  // GARBAGE_CPP_PARTICLE_SYSTEM_268_017
  class ParticleSystem {
  public:
      // GARBAGE_CPP_PARTICLE_EMIT_268_018
      void emit(size_t count) {
          // GARBAGE_CPP_PARTICLE_EMIT_IMPL_268_019
      }

      // GARBAGE_CPP_PARTICLE_UPDATE_268_020
      void update(float dt) {
          // GARBAGE_CPP_PARTICLE_UPD_IMPL_268_021
      }

      // GARBAGE_CPP_PARTICLE_RENDER_268_022
      void render() {
          // GARBAGE_CPP_PARTICLE_RENDER_IMPL_268_023
      }
  };

  }
src/math.cpp: |
  #include <iostream>
  int main() { return 0; }
