name: cpp_253_dynamic_cast
initial:
  include/shape/shapes.hpp: |
    #pragma once
    #include <string>
    #include <cmath>

    namespace app::shape {

    class Shape {
    public:
        Shape(double x, double y) : x_(x), y_(y) {}
        virtual ~Shape() = default;

        double x() const { return x_; }
        double y() const { return y_; }
        void setPosition(double x, double y) { x_ = x; y_ = y; }

        virtual double area() const = 0;
        virtual double perimeter() const = 0;
        virtual void draw() const = 0;
        virtual std::string name() const = 0;

    protected:
        double x_, y_;
    };

    class Circle : public Shape {
    public:
        Circle(double x, double y, double radius)
            : Shape(x, y), radius_(radius) {}

        double area() const override { return 3.14159 * radius_ * radius_; }
        double perimeter() const override { return 2 * 3.14159 * radius_; }
        void draw() const override {}
        std::string name() const override { return "Circle"; }

        double radius() const { return radius_; }
        void setRadius(double r) { radius_ = r; }

    private:
        double radius_;
    };

    class Rectangle : public Shape {
    public:
        Rectangle(double x, double y, double width, double height)
            : Shape(x, y), width_(width), height_(height) {}

        double area() const override { return width_ * height_; }
        double perimeter() const override { return 2 * (width_ + height_); }
        void draw() const override {}
        std::string name() const override { return "Rectangle"; }

        double width() const { return width_; }
        double height() const { return height_; }
        void resize(double w, double h) { width_ = w; height_ = h; }

    private:
        double width_, height_;
    };

    class Triangle : public Shape {
    public:
        Triangle(double x, double y, double a, double b, double c)
            : Shape(x, y), a_(a), b_(b), c_(c) {}

        double area() const override {
            double s = (a_ + b_ + c_) / 2;
            return std::sqrt(s * (s - a_) * (s - b_) * (s - c_));
        }
        double perimeter() const override { return a_ + b_ + c_; }
        void draw() const override {}
        std::string name() const override { return "Triangle"; }

        double sideA() const { return a_; }
        double sideB() const { return b_; }
        double sideC() const { return c_; }

    private:
        double a_, b_, c_;
    };

    }

  include/unrelated/terrain_generator.hpp: |
    #pragma once
    // GARBAGE_CPP_TERRAIN_253_001
    #define GARBAGE_CPP_TERRAIN_SIZE_253_002 1024

    namespace app::unrelated::terrain {

    // GARBAGE_CPP_TERRAIN_TYPE_253_003
    enum class TerrainType {
        Grass,
        Sand,
        Rock,
        Water
    };

    // GARBAGE_CPP_TERRAIN_CHUNK_253_004
    struct TerrainChunk {
        float heightmap[64][64];
        // GARBAGE_CPP_TERRAIN_DATA_253_005
    };

    // GARBAGE_CPP_TERRAIN_GEN_253_006
    class TerrainGenerator {
    public:
        // GARBAGE_CPP_TERRAIN_GENERATE_253_007
        TerrainChunk generate(int seed) {
            // GARBAGE_CPP_TERRAIN_GEN_IMPL_253_008
            return TerrainChunk{};
        }

        // GARBAGE_CPP_TERRAIN_ERODE_253_009
        void erode(TerrainChunk& chunk, int iterations) {
            // GARBAGE_CPP_TERRAIN_ERODE_IMPL_253_010
        }
    };

    }

  src/unrelated/pathfinding.cpp: |
    // GARBAGE_CPP_PATH_253_011
    #include <vector>

    namespace app::unrelated::ai {

    // GARBAGE_CPP_PATH_NODE_253_012
    struct PathNode {
        int x, y;
        float cost;
        // GARBAGE_CPP_PATH_PARENT_253_013
    };

    // GARBAGE_CPP_PATH_FINDER_253_014
    class PathFinder {
    public:
        // GARBAGE_CPP_PATH_FIND_253_015
        std::vector<PathNode> findPath(int startX, int startY, int endX, int endY) {
            // GARBAGE_CPP_PATH_FIND_IMPL_253_016
            return {};
        }

        // GARBAGE_CPP_PATH_SETGRID_253_017
        void setGrid(int width, int height) {
            // GARBAGE_CPP_PATH_SETGRID_IMPL_253_018
        }
    };

    }

  src/renderer.cpp: |
    #include <iostream>
    int main() { return 0; }

changed:
  src/renderer.cpp: |
    #include "shape/shapes.hpp"
    #include <iostream>
    #include <vector>
    #include <memory>

    namespace app::graphics {

    class ShapeVisitor {
    public:
        void visit(shape::Shape* s) {
            if (auto* circle = dynamic_cast<shape::Circle*>(s)) {
                visitCircle(circle);
            } else if (auto* rect = dynamic_cast<shape::Rectangle*>(s)) {
                visitRectangle(rect);
            } else if (auto* tri = dynamic_cast<shape::Triangle*>(s)) {
                visitTriangle(tri);
            } else {
                visitGenericShape(s);
            }
        }

    private:
        void visitCircle(shape::Circle* c) {
            std::cout << "Rendering circle at (" << c->x() << ", " << c->y()
                      << ") with radius " << c->radius() << "\n";
        }

        void visitRectangle(shape::Rectangle* r) {
            std::cout << "Rendering rectangle at (" << r->x() << ", " << r->y()
                      << ") size " << r->width() << "x" << r->height() << "\n";
        }

        void visitTriangle(shape::Triangle* t) {
            std::cout << "Rendering triangle at (" << t->x() << ", " << t->y()
                      << ") sides " << t->sideA() << ", " << t->sideB() << ", " << t->sideC() << "\n";
        }

        void visitGenericShape(shape::Shape* s) {
            std::cout << "Rendering generic shape: " << s->name() << "\n";
        }
    };

    class ShapeRenderer {
    public:
        void addShape(std::unique_ptr<shape::Shape> s) {
            shapes_.push_back(std::move(s));
        }

        void renderAll() {
            ShapeVisitor visitor;
            for (auto& s : shapes_) {
                visitor.visit(s.get());
            }
        }

        void scaleCircles(double factor) {
            for (auto& s : shapes_) {
                if (auto* circle = dynamic_cast<shape::Circle*>(s.get())) {
                    circle->setRadius(circle->radius() * factor);
                }
            }
        }

        void resizeRectangles(double widthFactor, double heightFactor) {
            for (auto& s : shapes_) {
                if (auto* rect = dynamic_cast<shape::Rectangle*>(s.get())) {
                    rect->resize(rect->width() * widthFactor, rect->height() * heightFactor);
                }
            }
        }

        double totalArea() const {
            double total = 0;
            for (const auto& s : shapes_) {
                total += s->area();
            }
            return total;
        }

        std::vector<shape::Circle*> getCircles() {
            std::vector<shape::Circle*> circles;
            for (auto& s : shapes_) {
                if (auto* circle = dynamic_cast<shape::Circle*>(s.get())) {
                    circles.push_back(circle);
                }
            }
            return circles;
        }

        std::vector<shape::Rectangle*> getRectangles() {
            std::vector<shape::Rectangle*> rects;
            for (auto& s : shapes_) {
                if (auto* rect = dynamic_cast<shape::Rectangle*>(s.get())) {
                    rects.push_back(rect);
                }
            }
            return rects;
        }

        size_t countByType(const std::string& typeName) const {
            size_t count = 0;
            for (const auto& s : shapes_) {
                if (s->name() == typeName) ++count;
            }
            return count;
        }

    private:
        std::vector<std::unique_ptr<shape::Shape>> shapes_;
    };

    }

    int main() {
        app::graphics::ShapeRenderer renderer;

        renderer.addShape(std::make_unique<app::shape::Circle>(10, 20, 5));
        renderer.addShape(std::make_unique<app::shape::Rectangle>(30, 40, 10, 20));
        renderer.addShape(std::make_unique<app::shape::Triangle>(50, 60, 3, 4, 5));
        renderer.addShape(std::make_unique<app::shape::Circle>(70, 80, 8));

        std::cout << "Initial shapes:\n";
        renderer.renderAll();

        std::cout << "\nTotal area: " << renderer.totalArea() << "\n";

        std::cout << "\nCircle count: " << renderer.countByType("Circle") << "\n";
        std::cout << "Rectangle count: " << renderer.countByType("Rectangle") << "\n";

        renderer.scaleCircles(2.0);
        std::cout << "\nAfter scaling circles:\n";
        for (auto* circle : renderer.getCircles()) {
            std::cout << "Circle radius: " << circle->radius() << "\n";
        }

        renderer.resizeRectangles(1.5, 0.5);
        std::cout << "\nAfter resizing rectangles:\n";
        for (auto* rect : renderer.getRectangles()) {
            std::cout << "Rectangle: " << rect->width() << "x" << rect->height() << "\n";
        }

        return 0;
    }

assertions:
  must_include:
    - ShapeRenderer
    - ShapeVisitor
    - dynamic_cast
    - Circle
    - Rectangle
    - Triangle
    - getCircles
    - scaleCircles
  must_not_include:
    - GARBAGE_CPP_TERRAIN_253_001
    - GARBAGE_CPP_TERRAIN_SIZE_253_002
    - GARBAGE_CPP_TERRAIN_TYPE_253_003
    - GARBAGE_CPP_TERRAIN_GEN_253_006
    - GARBAGE_CPP_TERRAIN_GENERATE_253_007
    - GARBAGE_CPP_PATH_253_011
    - GARBAGE_CPP_PATH_NODE_253_012
    - GARBAGE_CPP_PATH_FINDER_253_014
    - GARBAGE_CPP_PATH_FIND_253_015
    - TerrainGenerator
    - PathFinder
    - TerrainChunk
    - PathNode
options:
  commit_message: Add shape renderer with dynamic_cast for polymorphic dispatch
