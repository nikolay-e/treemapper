include/container/container.hpp: |
  #pragma once
  #include <vector>
  #include <algorithm>
  #include <stdexcept>
  #include <functional>

  namespace app::container {

  template<typename T>
  class Container {
  public:
      using value_type = T;
      using iterator = typename std::vector<T>::iterator;
      using const_iterator = typename std::vector<T>::const_iterator;

      Container() = default;

      explicit Container(size_t initialCapacity) {
          items_.reserve(initialCapacity);
      }

      void add(const T& item) {
          items_.push_back(item);
      }

      void add(T&& item) {
          items_.push_back(std::move(item));
      }

      template<typename... Args>
      T& emplace(Args&&... args) {
          items_.emplace_back(std::forward<Args>(args)...);
          return items_.back();
      }

      T& get(size_t index) {
          if (index >= items_.size()) {
              throw std::out_of_range("Container index out of bounds");
          }
          return items_[index];
      }

      const T& get(size_t index) const {
          if (index >= items_.size()) {
              throw std::out_of_range("Container index out of bounds");
          }
          return items_[index];
      }

      void remove(size_t index) {
          if (index >= items_.size()) {
              throw std::out_of_range("Cannot remove: index out of bounds");
          }
          items_.erase(items_.begin() + index);
      }

      bool contains(const T& item) const {
          return std::find(items_.begin(), items_.end(), item) != items_.end();
      }

      size_t size() const { return items_.size(); }
      bool empty() const { return items_.empty(); }
      void clear() { items_.clear(); }

      iterator begin() { return items_.begin(); }
      iterator end() { return items_.end(); }
      const_iterator begin() const { return items_.begin(); }
      const_iterator end() const { return items_.end(); }

  private:
      std::vector<T> items_;
  };

  template<typename T>
  class SortedContainer : public Container<T> {
  public:
      using Compare = std::function<bool(const T&, const T&)>;

      explicit SortedContainer(Compare comp = std::less<T>{})
          : comparator_(comp) {}

      void addSorted(const T& item) {
          Container<T>::add(item);
          sortItems();
      }

      void sortItems() {
          std::sort(this->begin(), this->end(), comparator_);
      }

  private:
      Compare comparator_;
  };

  }
include/unrelated/json_parser.hpp: |
  #pragma once
  // GARBAGE_CPP_JSON_261_001
  #define GARBAGE_CPP_JSON_MAX_DEPTH_261_002 64

  namespace app::unrelated::json {

  // GARBAGE_CPP_JSON_TOKEN_261_003
  enum class JsonTokenType {
      ObjectStart,
      ObjectEnd,
      ArrayStart,
      ArrayEnd,
      String,
      Number,
      Boolean,
      Null
  };

  // GARBAGE_CPP_JSON_VALUE_261_004
  struct JsonValue {
      JsonTokenType type;
      // GARBAGE_CPP_JSON_DATA_261_005
      union {
          double numberValue;
          bool boolValue;
      };
  };

  // GARBAGE_CPP_JSON_PARSER_261_006
  class JsonParser {
  public:
      // GARBAGE_CPP_JSON_PARSE_261_007
      JsonValue parse(const char* json) {
          // GARBAGE_CPP_JSON_IMPL_261_008
          return JsonValue{};
      }

      // GARBAGE_CPP_JSON_STRINGIFY_261_009
      const char* stringify(const JsonValue& value) {
          // GARBAGE_CPP_JSON_STRINGIFY_IMPL_261_010
          return "";
      }
  };

  }
src/unrelated/xml_serializer.cpp: |
  // GARBAGE_CPP_XML_261_011
  #include <string>

  namespace app::unrelated::xml {

  // GARBAGE_CPP_XML_NODE_261_012
  struct XmlNode {
      std::string name;
      std::string content;
      // GARBAGE_CPP_XML_ATTR_261_013
  };

  // GARBAGE_CPP_XML_SERIALIZER_261_014
  class XmlSerializer {
  public:
      // GARBAGE_CPP_XML_SERIALIZE_261_015
      std::string serialize(const XmlNode& node) {
          // GARBAGE_CPP_XML_SERIALIZE_IMPL_261_016
          return "";
      }

      // GARBAGE_CPP_XML_DESERIALIZE_261_017
      XmlNode deserialize(const std::string& xml) {
          // GARBAGE_CPP_XML_DESERIALIZE_IMPL_261_018
          return XmlNode{};
      }
  };

  }
src/main.cpp: |
  #include <iostream>
  int main() { return 0; }
