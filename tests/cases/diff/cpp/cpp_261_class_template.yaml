name: cpp_261_class_template
initial:
  include/container/container.hpp: |
    #pragma once
    #include <vector>
    #include <algorithm>
    #include <stdexcept>
    #include <functional>

    namespace app::container {

    template<typename T>
    class Container {
    public:
        using value_type = T;
        using iterator = typename std::vector<T>::iterator;
        using const_iterator = typename std::vector<T>::const_iterator;

        Container() = default;

        explicit Container(size_t initialCapacity) {
            items_.reserve(initialCapacity);
        }

        void add(const T& item) {
            items_.push_back(item);
        }

        void add(T&& item) {
            items_.push_back(std::move(item));
        }

        template<typename... Args>
        T& emplace(Args&&... args) {
            items_.emplace_back(std::forward<Args>(args)...);
            return items_.back();
        }

        T& get(size_t index) {
            if (index >= items_.size()) {
                throw std::out_of_range("Container index out of bounds");
            }
            return items_[index];
        }

        const T& get(size_t index) const {
            if (index >= items_.size()) {
                throw std::out_of_range("Container index out of bounds");
            }
            return items_[index];
        }

        void remove(size_t index) {
            if (index >= items_.size()) {
                throw std::out_of_range("Cannot remove: index out of bounds");
            }
            items_.erase(items_.begin() + index);
        }

        bool contains(const T& item) const {
            return std::find(items_.begin(), items_.end(), item) != items_.end();
        }

        size_t size() const { return items_.size(); }
        bool empty() const { return items_.empty(); }
        void clear() { items_.clear(); }

        iterator begin() { return items_.begin(); }
        iterator end() { return items_.end(); }
        const_iterator begin() const { return items_.begin(); }
        const_iterator end() const { return items_.end(); }

    private:
        std::vector<T> items_;
    };

    template<typename T>
    class SortedContainer : public Container<T> {
    public:
        using Compare = std::function<bool(const T&, const T&)>;

        explicit SortedContainer(Compare comp = std::less<T>{})
            : comparator_(comp) {}

        void addSorted(const T& item) {
            Container<T>::add(item);
            sortItems();
        }

        void sortItems() {
            std::sort(this->begin(), this->end(), comparator_);
        }

    private:
        Compare comparator_;
    };

    }

  include/unrelated/json_parser.hpp: |
    #pragma once
    // GARBAGE_CPP_JSON_261_001
    #define GARBAGE_CPP_JSON_MAX_DEPTH_261_002 64

    namespace app::unrelated::json {

    // GARBAGE_CPP_JSON_TOKEN_261_003
    enum class JsonTokenType {
        ObjectStart,
        ObjectEnd,
        ArrayStart,
        ArrayEnd,
        String,
        Number,
        Boolean,
        Null
    };

    // GARBAGE_CPP_JSON_VALUE_261_004
    struct JsonValue {
        JsonTokenType type;
        // GARBAGE_CPP_JSON_DATA_261_005
        union {
            double numberValue;
            bool boolValue;
        };
    };

    // GARBAGE_CPP_JSON_PARSER_261_006
    class JsonParser {
    public:
        // GARBAGE_CPP_JSON_PARSE_261_007
        JsonValue parse(const char* json) {
            // GARBAGE_CPP_JSON_IMPL_261_008
            return JsonValue{};
        }

        // GARBAGE_CPP_JSON_STRINGIFY_261_009
        const char* stringify(const JsonValue& value) {
            // GARBAGE_CPP_JSON_STRINGIFY_IMPL_261_010
            return "";
        }
    };

    }

  src/unrelated/xml_serializer.cpp: |
    // GARBAGE_CPP_XML_261_011
    #include <string>

    namespace app::unrelated::xml {

    // GARBAGE_CPP_XML_NODE_261_012
    struct XmlNode {
        std::string name;
        std::string content;
        // GARBAGE_CPP_XML_ATTR_261_013
    };

    // GARBAGE_CPP_XML_SERIALIZER_261_014
    class XmlSerializer {
    public:
        // GARBAGE_CPP_XML_SERIALIZE_261_015
        std::string serialize(const XmlNode& node) {
            // GARBAGE_CPP_XML_SERIALIZE_IMPL_261_016
            return "";
        }

        // GARBAGE_CPP_XML_DESERIALIZE_261_017
        XmlNode deserialize(const std::string& xml) {
            // GARBAGE_CPP_XML_DESERIALIZE_IMPL_261_018
            return XmlNode{};
        }
    };

    }

  src/main.cpp: |
    #include <iostream>
    int main() { return 0; }

changed:
  src/main.cpp: |
    #include "container/container.hpp"
    #include <string>
    #include <iostream>
    #include <memory>

    namespace app::demo {

    struct Product {
        std::string name;
        double price;
        int quantity;

        bool operator==(const Product& other) const {
            return name == other.name;
        }

        bool operator<(const Product& other) const {
            return price < other.price;
        }
    };

    class Inventory {
    public:
        void addProduct(const std::string& name, double price, int qty) {
            Product& p = products_.emplace(Product{name, price, qty});
            std::cout << "Added product: " << p.name << "\n";
        }

        void addProductSorted(const std::string& name, double price, int qty) {
            sortedProducts_.addSorted(Product{name, price, qty});
        }

        Product* findProduct(const std::string& name) {
            for (auto& product : products_) {
                if (product.name == name) {
                    return &product;
                }
            }
            return nullptr;
        }

        void removeProduct(const std::string& name) {
            for (size_t i = 0; i < products_.size(); ++i) {
                if (products_.get(i).name == name) {
                    products_.remove(i);
                    return;
                }
            }
        }

        double calculateTotalValue() const {
            double total = 0.0;
            for (const auto& product : products_) {
                total += product.price * product.quantity;
            }
            return total;
        }

        void listProducts() const {
            std::cout << "Products in inventory:\n";
            for (const auto& product : products_) {
                std::cout << "  " << product.name << ": $"
                          << product.price << " x " << product.quantity << "\n";
            }
        }

        void listSortedByPrice() const {
            std::cout << "Products sorted by price:\n";
            for (const auto& product : sortedProducts_) {
                std::cout << "  " << product.name << ": $" << product.price << "\n";
            }
        }

        size_t productCount() const { return products_.size(); }

    private:
        container::Container<Product> products_{16};
        container::SortedContainer<Product> sortedProducts_;
    };

    class StringCollection {
    public:
        void addString(const std::string& s) {
            strings_.add(s);
        }

        bool hasString(const std::string& s) const {
            return strings_.contains(s);
        }

        void printAll() const {
            for (const auto& s : strings_) {
                std::cout << s << "\n";
            }
        }

    private:
        container::Container<std::string> strings_;
    };

    }

    int main() {
        app::demo::Inventory inventory;

        inventory.addProduct("Laptop", 999.99, 5);
        inventory.addProduct("Mouse", 29.99, 20);
        inventory.addProduct("Keyboard", 79.99, 15);

        inventory.addProductSorted("Monitor", 299.99, 8);
        inventory.addProductSorted("USB Cable", 9.99, 50);
        inventory.addProductSorted("Headphones", 149.99, 12);

        inventory.listProducts();
        inventory.listSortedByPrice();

        std::cout << "\nTotal inventory value: $"
                  << inventory.calculateTotalValue() << "\n";

        auto* laptop = inventory.findProduct("Laptop");
        if (laptop) {
            laptop->quantity += 10;
            std::cout << "Updated laptop quantity\n";
        }

        inventory.removeProduct("Mouse");
        std::cout << "After removal: " << inventory.productCount() << " products\n";

        app::demo::StringCollection tags;
        tags.addString("electronics");
        tags.addString("sale");
        std::cout << "Has 'electronics': " << tags.hasString("electronics") << "\n";

        return 0;
    }

assertions:
  must_include:
    - Container
    - SortedContainer
    - Inventory
    - addProduct
    - findProduct
    - removeProduct
    - calculateTotalValue
    - emplace
    - addSorted
  must_not_include:
    - GARBAGE_CPP_JSON_261_001
    - GARBAGE_CPP_JSON_MAX_DEPTH_261_002
    - GARBAGE_CPP_JSON_TOKEN_261_003
    - GARBAGE_CPP_JSON_VALUE_261_004
    - GARBAGE_CPP_JSON_DATA_261_005
    - GARBAGE_CPP_JSON_PARSER_261_006
    - GARBAGE_CPP_JSON_PARSE_261_007
    - GARBAGE_CPP_JSON_IMPL_261_008
    - GARBAGE_CPP_JSON_STRINGIFY_261_009
    - GARBAGE_CPP_JSON_STRINGIFY_IMPL_261_010
    - GARBAGE_CPP_XML_261_011
    - GARBAGE_CPP_XML_NODE_261_012
    - GARBAGE_CPP_XML_ATTR_261_013
    - GARBAGE_CPP_XML_SERIALIZER_261_014
    - GARBAGE_CPP_XML_SERIALIZE_261_015
    - GARBAGE_CPP_XML_SERIALIZE_IMPL_261_016
    - GARBAGE_CPP_XML_DESERIALIZE_261_017
    - GARBAGE_CPP_XML_DESERIALIZE_IMPL_261_018
    - JsonParser
    - XmlSerializer
    - JsonValue
    - XmlNode
options:
  commit_message: Add inventory system using class templates with sorted container
