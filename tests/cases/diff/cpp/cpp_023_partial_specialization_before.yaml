include/traits/ptr_traits.hpp: |
  #pragma once
  #include <type_traits>
  #include <memory>

  namespace app::traits {

  template<typename T>
  struct PtrTraits {
      using element_type = T;
      using pointer_type = T*;
      static constexpr bool is_pointer = false;
      static constexpr bool is_smart_pointer = false;

      static T* get(T& value) { return &value; }
      static const T* get(const T& value) { return &value; }
  };

  template<typename T>
  struct PtrTraits<T*> {
      using element_type = T;
      using pointer_type = T*;
      static constexpr bool is_pointer = true;
      static constexpr bool is_smart_pointer = false;

      static T* get(T* ptr) { return ptr; }
      static const T* get(const T* ptr) { return ptr; }
  };

  template<typename T>
  struct PtrTraits<std::unique_ptr<T>> {
      using element_type = T;
      using pointer_type = T*;
      static constexpr bool is_pointer = false;
      static constexpr bool is_smart_pointer = true;

      static T* get(std::unique_ptr<T>& ptr) { return ptr.get(); }
      static const T* get(const std::unique_ptr<T>& ptr) { return ptr.get(); }
  };

  template<typename T>
  struct PtrTraits<std::shared_ptr<T>> {
      using element_type = T;
      using pointer_type = T*;
      static constexpr bool is_pointer = false;
      static constexpr bool is_smart_pointer = true;

      static T* get(std::shared_ptr<T>& ptr) { return ptr.get(); }
      static const T* get(const std::shared_ptr<T>& ptr) { return ptr.get(); }
  };

  template<typename T, size_t N>
  struct ArrayTraits {
      using element_type = T;
      static constexpr size_t size = N;
      static constexpr bool is_array = true;

      static T* data(T (&arr)[N]) { return arr; }
      static const T* data(const T (&arr)[N]) { return arr; }
  };

  template<typename T>
  struct RemoveConst {
      using type = T;
  };

  template<typename T>
  struct RemoveConst<const T> {
      using type = T;
  };

  template<typename T>
  struct RemoveRef {
      using type = T;
  };

  template<typename T>
  struct RemoveRef<T&> {
      using type = T;
  };

  template<typename T>
  struct RemoveRef<T&&> {
      using type = T;
  };

  }
include/unrelated/signal_handler.hpp: |
  #pragma once
  // GARBAGE_CPP_SIGNAL_264_001
  #define GARBAGE_CPP_SIGNAL_MAX_264_002 32

  namespace app::unrelated::signal {

  // GARBAGE_CPP_SIGNAL_TYPE_264_003
  enum class SignalType {
      Interrupt,
      Terminate,
      Abort,
      SegFault
  };

  // GARBAGE_CPP_SIGNAL_HANDLER_264_004
  using SignalCallback = void(*)(SignalType);

  // GARBAGE_CPP_SIGNAL_MANAGER_264_005
  class SignalManager {
  public:
      // GARBAGE_CPP_SIGNAL_REGISTER_264_006
      void registerHandler(SignalType type, SignalCallback callback) {
          // GARBAGE_CPP_SIGNAL_REG_IMPL_264_007
      }

      // GARBAGE_CPP_SIGNAL_UNREGISTER_264_008
      void unregisterHandler(SignalType type) {
          // GARBAGE_CPP_SIGNAL_UNREG_IMPL_264_009
      }

      // GARBAGE_CPP_SIGNAL_RAISE_264_010
      void raise(SignalType type) {
          // GARBAGE_CPP_SIGNAL_RAISE_IMPL_264_011
      }
  };

  }
src/unrelated/memory_pool.cpp: |
  // GARBAGE_CPP_MEMPOOL_264_012
  #include <cstddef>

  namespace app::unrelated::memory {

  // GARBAGE_CPP_MEMPOOL_BLOCK_264_013
  struct MemoryBlock {
      void* ptr;
      size_t size;
      // GARBAGE_CPP_MEMPOOL_NEXT_264_014
      MemoryBlock* next;
  };

  // GARBAGE_CPP_MEMPOOL_CLASS_264_015
  class MemoryPool {
  public:
      // GARBAGE_CPP_MEMPOOL_ALLOC_264_016
      void* allocate(size_t size) {
          // GARBAGE_CPP_MEMPOOL_ALLOC_IMPL_264_017
          return nullptr;
      }

      // GARBAGE_CPP_MEMPOOL_FREE_264_018
      void deallocate(void* ptr) {
          // GARBAGE_CPP_MEMPOOL_FREE_IMPL_264_019
      }

      // GARBAGE_CPP_MEMPOOL_RESET_264_020
      void reset() {
          // GARBAGE_CPP_MEMPOOL_RESET_IMPL_264_021
      }
  };

  }
src/checker.cpp: |
  #include <iostream>
  int main() { return 0; }
