include/shape/shapes.hpp: |
  #pragma once
  #include <string>
  #include <cmath>

  namespace app::shape {

  class Shape {
  public:
      Shape(double x, double y) : x_(x), y_(y) {}
      virtual ~Shape() = default;

      double x() const { return x_; }
      double y() const { return y_; }
      void setPosition(double x, double y) { x_ = x; y_ = y; }

      virtual double area() const = 0;
      virtual double perimeter() const = 0;
      virtual void draw() const = 0;
      virtual std::string name() const = 0;

  protected:
      double x_, y_;
  };

  class Circle : public Shape {
  public:
      Circle(double x, double y, double radius)
          : Shape(x, y), radius_(radius) {}

      double area() const override { return 3.14159 * radius_ * radius_; }
      double perimeter() const override { return 2 * 3.14159 * radius_; }
      void draw() const override {}
      std::string name() const override { return "Circle"; }

      double radius() const { return radius_; }
      void setRadius(double r) { radius_ = r; }

  private:
      double radius_;
  };

  class Rectangle : public Shape {
  public:
      Rectangle(double x, double y, double width, double height)
          : Shape(x, y), width_(width), height_(height) {}

      double area() const override { return width_ * height_; }
      double perimeter() const override { return 2 * (width_ + height_); }
      void draw() const override {}
      std::string name() const override { return "Rectangle"; }

      double width() const { return width_; }
      double height() const { return height_; }
      void resize(double w, double h) { width_ = w; height_ = h; }

  private:
      double width_, height_;
  };

  class Triangle : public Shape {
  public:
      Triangle(double x, double y, double a, double b, double c)
          : Shape(x, y), a_(a), b_(b), c_(c) {}

      double area() const override {
          double s = (a_ + b_ + c_) / 2;
          return std::sqrt(s * (s - a_) * (s - b_) * (s - c_));
      }
      double perimeter() const override { return a_ + b_ + c_; }
      void draw() const override {}
      std::string name() const override { return "Triangle"; }

      double sideA() const { return a_; }
      double sideB() const { return b_; }
      double sideC() const { return c_; }

  private:
      double a_, b_, c_;
  };

  }
include/unrelated/terrain_generator.hpp: |
  #pragma once
  // GARBAGE_CPP_TERRAIN_253_001
  #define GARBAGE_CPP_TERRAIN_SIZE_253_002 1024

  namespace app::unrelated::terrain {

  // GARBAGE_CPP_TERRAIN_TYPE_253_003
  enum class TerrainType {
      Grass,
      Sand,
      Rock,
      Water
  };

  // GARBAGE_CPP_TERRAIN_CHUNK_253_004
  struct TerrainChunk {
      float heightmap[64][64];
      // GARBAGE_CPP_TERRAIN_DATA_253_005
  };

  // GARBAGE_CPP_TERRAIN_GEN_253_006
  class TerrainGenerator {
  public:
      // GARBAGE_CPP_TERRAIN_GENERATE_253_007
      TerrainChunk generate(int seed) {
          // GARBAGE_CPP_TERRAIN_GEN_IMPL_253_008
          return TerrainChunk{};
      }

      // GARBAGE_CPP_TERRAIN_ERODE_253_009
      void erode(TerrainChunk& chunk, int iterations) {
          // GARBAGE_CPP_TERRAIN_ERODE_IMPL_253_010
      }
  };

  }
src/unrelated/pathfinding.cpp: |
  // GARBAGE_CPP_PATH_253_011
  #include <vector>

  namespace app::unrelated::ai {

  // GARBAGE_CPP_PATH_NODE_253_012
  struct PathNode {
      int x, y;
      float cost;
      // GARBAGE_CPP_PATH_PARENT_253_013
  };

  // GARBAGE_CPP_PATH_FINDER_253_014
  class PathFinder {
  public:
      // GARBAGE_CPP_PATH_FIND_253_015
      std::vector<PathNode> findPath(int startX, int startY, int endX, int endY) {
          // GARBAGE_CPP_PATH_FIND_IMPL_253_016
          return {};
      }

      // GARBAGE_CPP_PATH_SETGRID_253_017
      void setGrid(int width, int height) {
          // GARBAGE_CPP_PATH_SETGRID_IMPL_253_018
      }
  };

  }
src/renderer.cpp: |
  #include <iostream>
  int main() { return 0; }
