include/sync/mutex.hpp: |
  #pragma once
  #include <atomic>

  namespace app::sync {

  class SpinMutex {
  public:
      SpinMutex() : locked_(false) {}

      void lock() {
          while (locked_.exchange(true, std::memory_order_acquire)) {
              while (locked_.load(std::memory_order_relaxed)) {
              }
          }
      }

      void unlock() {
          locked_.store(false, std::memory_order_release);
      }

      bool try_lock() {
          return !locked_.exchange(true, std::memory_order_acquire);
      }

  private:
      std::atomic<bool> locked_;
  };

  class RecursiveMutex {
  public:
      RecursiveMutex() : owner_(0), count_(0) {}

      void lock() {
          auto self = std::hash<std::thread::id>{}(std::this_thread::get_id());
          if (owner_ == self) {
              ++count_;
              return;
          }
          mutex_.lock();
          owner_ = self;
          count_ = 1;
      }

      void unlock() {
          if (--count_ == 0) {
              owner_ = 0;
              mutex_.unlock();
          }
      }

  private:
      SpinMutex mutex_;
      std::atomic<size_t> owner_;
      size_t count_;
  };

  }
include/unrelated/regex_engine.hpp: |
  #pragma once
  // GARBAGE_CPP_REGEX_249_001
  #define GARBAGE_CPP_REGEX_MAX_249_002 1000

  namespace app::unrelated::regex {

  // GARBAGE_CPP_REGEX_FLAGS_249_003
  enum class RegexFlags {
      None = 0,
      CaseInsensitive = 1,
      Multiline = 2,
      DotAll = 4
  };

  // GARBAGE_CPP_REGEX_MATCH_249_004
  struct RegexMatch {
      size_t start;
      size_t length;
      // GARBAGE_CPP_REGEX_GROUPS_249_005
  };

  // GARBAGE_CPP_REGEX_ENGINE_249_006
  class RegexEngine {
  public:
      // GARBAGE_CPP_REGEX_COMPILE_249_007
      bool compile(const char* pattern) {
          // GARBAGE_CPP_REGEX_COMPILE_IMPL_249_008
          return false;
      }

      // GARBAGE_CPP_REGEX_MATCH_FN_249_009
      bool match(const char* input, RegexMatch& result) {
          // GARBAGE_CPP_REGEX_MATCH_IMPL_249_010
          return false;
      }

      // GARBAGE_CPP_REGEX_SEARCH_249_011
      bool search(const char* input) {
          // GARBAGE_CPP_REGEX_SEARCH_IMPL_249_012
          return false;
      }
  };

  }
src/unrelated/config_parser.cpp: |
  // GARBAGE_CPP_CONFIG_249_013
  #include <string>
  #include <map>

  namespace app::unrelated::config {

  // GARBAGE_CPP_CONFIG_VALUE_249_014
  struct ConfigValue {
      std::string stringValue;
      int intValue;
      bool boolValue;
  };

  // GARBAGE_CPP_CONFIG_PARSER_249_015
  class ConfigParser {
  public:
      // GARBAGE_CPP_CONFIG_LOAD_249_016
      bool loadFromFile(const std::string& path) {
          // GARBAGE_CPP_CONFIG_LOAD_IMPL_249_017
          return false;
      }

      // GARBAGE_CPP_CONFIG_GET_249_018
      ConfigValue get(const std::string& key) const {
          // GARBAGE_CPP_CONFIG_GET_IMPL_249_019
          return ConfigValue{};
      }

      // GARBAGE_CPP_CONFIG_SET_249_020
      void set(const std::string& key, const ConfigValue& value) {
          // GARBAGE_CPP_CONFIG_SET_IMPL_249_021
      }
  };

  }
src/guard.cpp: |
  #include <iostream>
  int main() { return 0; }
