name: cpp_271_final_specifier
initial:
  include/security/authenticator.hpp: |
    #pragma once
    #include <string>
    #include <vector>
    #include <memory>

    namespace app::security {

    class Credentials {
    public:
        virtual ~Credentials() = default;
        virtual std::string type() const = 0;
        virtual bool validate() const = 0;
    };

    class PasswordCredentials final : public Credentials {
    public:
        PasswordCredentials(const std::string& user, const std::string& pass)
            : username_(user), password_(pass) {}

        std::string type() const override { return "password"; }

        bool validate() const override {
            return !username_.empty() && password_.length() >= 8;
        }

        const std::string& username() const { return username_; }

    private:
        std::string username_;
        std::string password_;
    };

    class TokenCredentials final : public Credentials {
    public:
        explicit TokenCredentials(const std::string& token)
            : token_(token) {}

        std::string type() const override { return "token"; }

        bool validate() const override {
            return token_.length() == 64;
        }

        const std::string& token() const { return token_; }

    private:
        std::string token_;
    };

    class Authenticator {
    public:
        virtual ~Authenticator() = default;
        virtual bool authenticate(const Credentials& creds) = 0;
        virtual std::string name() const = 0;
    };

    class Session {
    public:
        virtual ~Session() = default;
        virtual bool isValid() const = 0;
        virtual void invalidate() = 0;
    };

    }

  include/unrelated/compression.hpp: |
    #pragma once
    // GARBAGE_CPP_COMPRESS_271_001
    #define GARBAGE_CPP_COMPRESS_LEVEL_271_002 6

    namespace app::unrelated::compress {

    // GARBAGE_CPP_COMPRESS_DATA_271_003
    struct CompressedData {
        unsigned char* data;
        size_t compressedSize;
        size_t originalSize;
        // GARBAGE_CPP_COMPRESS_CHECKSUM_271_004
    };

    // GARBAGE_CPP_COMPRESS_ENGINE_271_005
    class CompressionEngine {
    public:
        // GARBAGE_CPP_COMPRESS_ENCODE_271_006
        CompressedData compress(const unsigned char* input, size_t size) {
            // GARBAGE_CPP_COMPRESS_ENC_IMPL_271_007
            return CompressedData{};
        }

        // GARBAGE_CPP_COMPRESS_DECODE_271_008
        size_t decompress(const CompressedData& data, unsigned char* output) {
            // GARBAGE_CPP_COMPRESS_DEC_IMPL_271_009
            return 0;
        }

        // GARBAGE_CPP_COMPRESS_RATIO_271_010
        float getCompressionRatio(const CompressedData& data) {
            // GARBAGE_CPP_COMPRESS_RATIO_IMPL_271_011
            return 0.0f;
        }
    };

    }

  src/unrelated/font_renderer.cpp: |
    // GARBAGE_CPP_FONT_271_012
    #include <string>

    namespace app::unrelated::font {

    // GARBAGE_CPP_FONT_GLYPH_271_013
    struct Glyph {
        int codepoint;
        int width;
        int height;
        // GARBAGE_CPP_FONT_ADVANCE_271_014
    };

    // GARBAGE_CPP_FONT_RENDERER_271_015
    class FontRenderer {
    public:
        // GARBAGE_CPP_FONT_LOAD_271_016
        bool loadFont(const std::string& path) {
            // GARBAGE_CPP_FONT_LOAD_IMPL_271_017
            return false;
        }

        // GARBAGE_CPP_FONT_RENDER_271_018
        void renderText(const std::string& text, int x, int y) {
            // GARBAGE_CPP_FONT_RENDER_IMPL_271_019
        }

        // GARBAGE_CPP_FONT_MEASURE_271_020
        int measureText(const std::string& text) {
            // GARBAGE_CPP_FONT_MEASURE_IMPL_271_021
            return 0;
        }
    };

    }

  src/auth.cpp: |
    #include <iostream>
    int main() { return 0; }

changed:
  src/auth.cpp: |
    #include "security/authenticator.hpp"
    #include <iostream>
    #include <chrono>
    #include <random>
    #include <unordered_map>

    namespace app::auth {

    class LocalAuthenticator final : public security::Authenticator {
    public:
        void addUser(const std::string& username, const std::string& passwordHash) {
            users_[username] = passwordHash;
        }

        bool authenticate(const security::Credentials& creds) override {
            if (creds.type() != "password") return false;

            auto& passCreds = static_cast<const security::PasswordCredentials&>(creds);
            auto it = users_.find(passCreds.username());
            if (it == users_.end()) return false;

            return true;
        }

        std::string name() const override { return "LocalAuthenticator"; }

        size_t userCount() const { return users_.size(); }

    private:
        std::unordered_map<std::string, std::string> users_;
    };

    class TokenAuthenticator final : public security::Authenticator {
    public:
        void addValidToken(const std::string& token) {
            validTokens_.push_back(token);
        }

        bool authenticate(const security::Credentials& creds) override {
            if (creds.type() != "token") return false;

            auto& tokenCreds = static_cast<const security::TokenCredentials&>(creds);
            for (const auto& valid : validTokens_) {
                if (valid == tokenCreds.token()) return true;
            }
            return false;
        }

        std::string name() const override { return "TokenAuthenticator"; }

        void clearTokens() { validTokens_.clear(); }

    private:
        std::vector<std::string> validTokens_;
    };

    class ActiveSession final : public security::Session {
    public:
        ActiveSession(const std::string& userId, int durationSeconds)
            : userId_(userId)
            , expiry_(std::chrono::steady_clock::now() +
                      std::chrono::seconds(durationSeconds))
            , valid_(true) {}

        bool isValid() const override {
            return valid_ && std::chrono::steady_clock::now() < expiry_;
        }

        void invalidate() override {
            valid_ = false;
        }

        const std::string& userId() const { return userId_; }

        void extend(int seconds) {
            expiry_ = std::chrono::steady_clock::now() + std::chrono::seconds(seconds);
        }

    private:
        std::string userId_;
        std::chrono::steady_clock::time_point expiry_;
        bool valid_;
    };

    class AuthManager {
    public:
        void registerAuthenticator(std::unique_ptr<security::Authenticator> auth) {
            authenticators_.push_back(std::move(auth));
        }

        security::Session* login(const security::Credentials& creds) {
            for (auto& auth : authenticators_) {
                if (auth->authenticate(creds)) {
                    std::cout << "Authenticated via " << auth->name() << "\n";
                    auto session = std::make_unique<ActiveSession>("user123", 3600);
                    auto* ptr = session.get();
                    sessions_.push_back(std::move(session));
                    return ptr;
                }
            }
            std::cout << "Authentication failed\n";
            return nullptr;
        }

        void logout(security::Session* session) {
            if (session) {
                session->invalidate();
            }
        }

        size_t activeSessionCount() const {
            size_t count = 0;
            for (const auto& session : sessions_) {
                if (session->isValid()) ++count;
            }
            return count;
        }

    private:
        std::vector<std::unique_ptr<security::Authenticator>> authenticators_;
        std::vector<std::unique_ptr<ActiveSession>> sessions_;
    };

    }

    int main() {
        app::auth::AuthManager manager;

        auto localAuth = std::make_unique<app::auth::LocalAuthenticator>();
        localAuth->addUser("alice", "hashed_password_123");
        localAuth->addUser("bob", "hashed_password_456");
        manager.registerAuthenticator(std::move(localAuth));

        auto tokenAuth = std::make_unique<app::auth::TokenAuthenticator>();
        tokenAuth->addValidToken(std::string(64, 'a'));
        manager.registerAuthenticator(std::move(tokenAuth));

        std::cout << "=== Password Authentication ===\n";
        app::security::PasswordCredentials passCreds("alice", "mysecretpassword");
        std::cout << "Credentials valid: " << passCreds.validate() << "\n";
        auto* session1 = manager.login(passCreds);
        if (session1) {
            std::cout << "Session valid: " << session1->isValid() << "\n";
        }

        std::cout << "\n=== Token Authentication ===\n";
        app::security::TokenCredentials tokenCreds(std::string(64, 'a'));
        std::cout << "Token valid format: " << tokenCreds.validate() << "\n";
        auto* session2 = manager.login(tokenCreds);

        std::cout << "\n=== Invalid Token ===\n";
        app::security::TokenCredentials invalidToken(std::string(32, 'b'));
        std::cout << "Short token valid: " << invalidToken.validate() << "\n";

        std::cout << "\n=== Session Management ===\n";
        std::cout << "Active sessions: " << manager.activeSessionCount() << "\n";
        manager.logout(session1);
        std::cout << "After logout: " << manager.activeSessionCount() << "\n";

        return 0;
    }

assertions:
  must_include:
    - final
    - LocalAuthenticator
    - TokenAuthenticator
    - ActiveSession
    - AuthManager
    - authenticate
    - PasswordCredentials
    - TokenCredentials
    - invalidate
  must_not_include:
    - GARBAGE_CPP_COMPRESS_271_001
    - GARBAGE_CPP_COMPRESS_LEVEL_271_002
    - GARBAGE_CPP_COMPRESS_DATA_271_003
    - GARBAGE_CPP_COMPRESS_CHECKSUM_271_004
    - GARBAGE_CPP_COMPRESS_ENGINE_271_005
    - GARBAGE_CPP_COMPRESS_ENCODE_271_006
    - GARBAGE_CPP_COMPRESS_DECODE_271_008
    - GARBAGE_CPP_COMPRESS_RATIO_271_010
    - GARBAGE_CPP_FONT_271_012
    - GARBAGE_CPP_FONT_GLYPH_271_013
    - GARBAGE_CPP_FONT_ADVANCE_271_014
    - GARBAGE_CPP_FONT_RENDERER_271_015
    - GARBAGE_CPP_FONT_LOAD_271_016
    - GARBAGE_CPP_FONT_RENDER_271_018
    - GARBAGE_CPP_FONT_MEASURE_271_020
    - CompressionEngine
    - FontRenderer
    - CompressedData
    - Glyph
options:
  commit_message: Add authentication system with final specifiers preventing inheritance
