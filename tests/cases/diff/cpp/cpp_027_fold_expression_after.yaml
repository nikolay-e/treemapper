include/fold/fold_ops.hpp: |
  #pragma once
  #include <type_traits>
  #include <utility>
  #include <iostream>

  namespace app::fold {

  template<typename... Args>
  auto sum(Args... args) {
      return (args + ...);
  }

  template<typename... Args>
  auto product(Args... args) {
      return (args * ...);
  }

  template<typename... Args>
  auto sumWithInit(int init, Args... args) {
      return (init + ... + args);
  }

  template<typename... Args>
  bool allTrue(Args... args) {
      return (... && args);
  }

  template<typename... Args>
  bool anyTrue(Args... args) {
      return (... || args);
  }

  template<typename... Args>
  auto bitwiseAnd(Args... args) {
      return (args & ...);
  }

  template<typename... Args>
  auto bitwiseOr(Args... args) {
      return (args | ...);
  }

  template<typename... Args>
  void printAll(Args... args) {
      ((std::cout << args << " "), ...);
      std::cout << "\n";
  }

  template<typename... Args>
  void printWithSeparator(const char* sep, Args... args) {
      size_t count = 0;
      ((std::cout << (count++ > 0 ? sep : "") << args), ...);
      std::cout << "\n";
  }

  template<typename T, typename... Args>
  bool contains(const T& value, Args... args) {
      return ((value == args) || ...);
  }

  template<typename... Args>
  auto maximum(Args... args) {
      auto maxVal = (args, ...);
      ((maxVal = (args > maxVal ? args : maxVal)), ...);
      return maxVal;
  }

  template<typename... Args>
  auto minimum(Args... args) {
      auto minVal = (args, ...);
      ((minVal = (args < minVal ? args : minVal)), ...);
      return minVal;
  }

  template<typename... Args>
  size_t countArgs(Args... args) {
      return sizeof...(args);
  }

  }
include/unrelated/game_physics.hpp: |
  #pragma once
  // GARBAGE_CPP_PHYSICS_268_001
  #define GARBAGE_CPP_PHYSICS_GRAVITY_268_002 9.81f

  namespace app::unrelated::physics {

  // GARBAGE_CPP_PHYSICS_VEC_268_003
  struct Vector3 {
      float x, y, z;
      // GARBAGE_CPP_PHYSICS_METHODS_268_004
  };

  // GARBAGE_CPP_PHYSICS_BODY_268_005
  struct RigidBody {
      Vector3 position;
      Vector3 velocity;
      float mass;
      // GARBAGE_CPP_PHYSICS_PROPS_268_006
  };

  // GARBAGE_CPP_PHYSICS_ENGINE_268_007
  class PhysicsEngine {
  public:
      // GARBAGE_CPP_PHYSICS_UPDATE_268_008
      void update(float deltaTime) {
          // GARBAGE_CPP_PHYSICS_UPDATE_IMPL_268_009
      }

      // GARBAGE_CPP_PHYSICS_COLLIDE_268_010
      bool checkCollision(const RigidBody& a, const RigidBody& b) {
          // GARBAGE_CPP_PHYSICS_COLL_IMPL_268_011
          return false;
      }

      // GARBAGE_CPP_PHYSICS_ADD_268_012
      void addBody(const RigidBody& body) {
          // GARBAGE_CPP_PHYSICS_ADD_IMPL_268_013
      }
  };

  }
src/unrelated/particle_system.cpp: |
  // GARBAGE_CPP_PARTICLE_268_014
  #include <cstddef>

  namespace app::unrelated::particle {

  // GARBAGE_CPP_PARTICLE_DATA_268_015
  struct Particle {
      float x, y, z;
      float vx, vy, vz;
      float life;
      // GARBAGE_CPP_PARTICLE_COLOR_268_016
  };

  // GARBAGE_CPP_PARTICLE_SYSTEM_268_017
  class ParticleSystem {
  public:
      // GARBAGE_CPP_PARTICLE_EMIT_268_018
      void emit(size_t count) {
          // GARBAGE_CPP_PARTICLE_EMIT_IMPL_268_019
      }

      // GARBAGE_CPP_PARTICLE_UPDATE_268_020
      void update(float dt) {
          // GARBAGE_CPP_PARTICLE_UPD_IMPL_268_021
      }

      // GARBAGE_CPP_PARTICLE_RENDER_268_022
      void render() {
          // GARBAGE_CPP_PARTICLE_RENDER_IMPL_268_023
      }
  };

  }
src/math.cpp: |
  #include "fold/fold_ops.hpp"
  #include <string>
  #include <vector>
  #include <functional>

  namespace app::math {

  class Calculator {
  public:
      template<typename... Args>
      auto computeSum(Args... args) {
          return fold::sum(args...);
      }

      template<typename... Args>
      auto computeProduct(Args... args) {
          return fold::product(args...);
      }

      template<typename... Args>
      auto computeAverage(Args... args) {
          if constexpr (sizeof...(args) == 0) {
              return 0.0;
          } else {
              return static_cast<double>(fold::sum(args...)) / sizeof...(args);
          }
      }

      template<typename... Args>
      auto computeWeightedSum(double weight, Args... args) {
          return (weight * args + ...);
      }
  };

  class Validator {
  public:
      template<typename... Args>
      bool allPositive(Args... args) {
          return ((args > 0) && ...);
      }

      template<typename... Args>
      bool anyNegative(Args... args) {
          return ((args < 0) || ...);
      }

      template<typename... Args>
      bool allInRange(int minVal, int maxVal, Args... args) {
          return ((args >= minVal && args <= maxVal) && ...);
      }

      template<typename T, typename... Args>
      bool isOneOf(const T& value, Args... candidates) {
          return fold::contains(value, candidates...);
      }
  };

  class Printer {
  public:
      template<typename... Args>
      void printValues(Args... args) {
          std::cout << "Values: ";
          fold::printAll(args...);
      }

      template<typename... Args>
      void printCSV(Args... args) {
          std::cout << "CSV: ";
          fold::printWithSeparator(",", args...);
      }

      template<typename... Args>
      void printJSON(Args... args) {
          std::cout << "[";
          size_t count = 0;
          ((std::cout << (count++ > 0 ? "," : "") << '"' << args << '"'), ...);
          std::cout << "]\n";
      }

      template<typename... Args>
      std::string join(const char* sep, Args... args) {
          std::string result;
          size_t count = 0;
          ((result += (count++ > 0 ? sep : "") + std::to_string(args)), ...);
          return result;
      }
  };

  class BitOperations {
  public:
      template<typename... Args>
      auto combineFlags(Args... flags) {
          return fold::bitwiseOr(flags...);
      }

      template<typename... Args>
      auto maskFlags(Args... flags) {
          return fold::bitwiseAnd(flags...);
      }

      template<typename... Args>
      bool hasAllFlags(unsigned int value, Args... flags) {
          return (value & fold::bitwiseOr(flags...)) == fold::bitwiseOr(flags...);
      }

      template<typename... Args>
      bool hasAnyFlag(unsigned int value, Args... flags) {
          return (value & fold::bitwiseOr(flags...)) != 0;
      }
  };

  class Statistics {
  public:
      template<typename... Args>
      auto findMax(Args... args) {
          return fold::maximum(args...);
      }

      template<typename... Args>
      auto findMin(Args... args) {
          return fold::minimum(args...);
      }

      template<typename... Args>
      auto range(Args... args) {
          return fold::maximum(args...) - fold::minimum(args...);
      }
  };

  }

  int main() {
      app::math::Calculator calc;

      std::cout << "=== Calculator ===\n";
      std::cout << "Sum(1,2,3,4,5): " << calc.computeSum(1, 2, 3, 4, 5) << "\n";
      std::cout << "Product(2,3,4): " << calc.computeProduct(2, 3, 4) << "\n";
      std::cout << "Average(10,20,30): " << calc.computeAverage(10, 20, 30) << "\n";
      std::cout << "WeightedSum(0.5, 2,4,6): " << calc.computeWeightedSum(0.5, 2, 4, 6) << "\n";

      app::math::Validator validator;

      std::cout << "\n=== Validator ===\n";
      std::cout << "AllPositive(1,2,3): " << validator.allPositive(1, 2, 3) << "\n";
      std::cout << "AllPositive(1,-2,3): " << validator.allPositive(1, -2, 3) << "\n";
      std::cout << "AnyNegative(1,-2,3): " << validator.anyNegative(1, -2, 3) << "\n";
      std::cout << "AllInRange(0,10, 1,5,9): " << validator.allInRange(0, 10, 1, 5, 9) << "\n";
      std::cout << "IsOneOf(5, 1,3,5,7): " << validator.isOneOf(5, 1, 3, 5, 7) << "\n";
      std::cout << "IsOneOf(4, 1,3,5,7): " << validator.isOneOf(4, 1, 3, 5, 7) << "\n";

      app::math::Printer printer;

      std::cout << "\n=== Printer ===\n";
      printer.printValues(1, 2.5, "hello", 'A');
      printer.printCSV(10, 20, 30, 40);
      printer.printJSON("apple", "banana", "cherry");
      std::cout << "Join: " << printer.join("-", 1, 2, 3, 4, 5) << "\n";

      app::math::BitOperations bits;

      std::cout << "\n=== Bit Operations ===\n";
      constexpr unsigned int FLAG_A = 0x01;
      constexpr unsigned int FLAG_B = 0x02;
      constexpr unsigned int FLAG_C = 0x04;
      constexpr unsigned int FLAG_D = 0x08;

      std::cout << "CombineFlags(A,C): " << bits.combineFlags(FLAG_A, FLAG_C) << "\n";
      std::cout << "HasAllFlags(5, A,C): " << bits.hasAllFlags(5, FLAG_A, FLAG_C) << "\n";
      std::cout << "HasAnyFlag(1, B,C): " << bits.hasAnyFlag(1, FLAG_B, FLAG_C) << "\n";

      app::math::Statistics stats;

      std::cout << "\n=== Statistics ===\n";
      std::cout << "Max(3,1,4,1,5,9): " << stats.findMax(3, 1, 4, 1, 5, 9) << "\n";
      std::cout << "Min(3,1,4,1,5,9): " << stats.findMin(3, 1, 4, 1, 5, 9) << "\n";
      std::cout << "Range(3,1,4,1,5,9): " << stats.range(3, 1, 4, 1, 5, 9) << "\n";

      std::cout << "\n=== Direct Fold ===\n";
      std::cout << "sum: " << app::fold::sum(1, 2, 3, 4, 5) << "\n";
      std::cout << "product: " << app::fold::product(1, 2, 3, 4) << "\n";
      std::cout << "allTrue: " << app::fold::allTrue(true, true, false) << "\n";
      std::cout << "anyTrue: " << app::fold::anyTrue(false, false, true) << "\n";

      return 0;
  }
