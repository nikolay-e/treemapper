name: cpp_270_override_specifier
initial:
  include/entity/base.hpp: |
    #pragma once
    #include <string>
    #include <memory>

    namespace app::entity {

    enum class EntityType {
        Unknown,
        Character,
        Item,
        Environment
    };

    class Base {
    public:
        virtual ~Base() = default;

        virtual std::string name() const { return "Base"; }
        virtual EntityType type() const { return EntityType::Unknown; }
        virtual void process() {}
        virtual void update(float deltaTime) {}
        virtual bool isActive() const { return active_; }
        virtual void setActive(bool active) { active_ = active; }
        virtual std::string serialize() const { return "{}"; }
        virtual void deserialize(const std::string& data) {}

    protected:
        bool active_ = true;
    };

    class Component {
    public:
        virtual ~Component() = default;

        virtual void onAttach() {}
        virtual void onDetach() {}
        virtual void tick(float dt) {}
        virtual std::string componentName() const { return "Component"; }
    };

    }

  include/unrelated/network_protocol.hpp: |
    #pragma once
    // GARBAGE_CPP_NETWORK_270_001
    #define GARBAGE_CPP_NETWORK_PORT_270_002 8080

    namespace app::unrelated::network {

    // GARBAGE_CPP_NETWORK_PACKET_270_003
    struct Packet {
        int type;
        size_t length;
        char data[1024];
        // GARBAGE_CPP_NETWORK_CHECKSUM_270_004
    };

    // GARBAGE_CPP_NETWORK_PROTOCOL_270_005
    class NetworkProtocol {
    public:
        // GARBAGE_CPP_NETWORK_ENCODE_270_006
        size_t encode(const Packet& packet, char* buffer) {
            // GARBAGE_CPP_NETWORK_ENC_IMPL_270_007
            return 0;
        }

        // GARBAGE_CPP_NETWORK_DECODE_270_008
        Packet decode(const char* buffer, size_t length) {
            // GARBAGE_CPP_NETWORK_DEC_IMPL_270_009
            return Packet{};
        }

        // GARBAGE_CPP_NETWORK_VALIDATE_270_010
        bool validate(const Packet& packet) {
            // GARBAGE_CPP_NETWORK_VAL_IMPL_270_011
            return false;
        }
    };

    }

  src/unrelated/asset_loader.cpp: |
    // GARBAGE_CPP_ASSET_270_012
    #include <string>

    namespace app::unrelated::asset {

    // GARBAGE_CPP_ASSET_TYPE_270_013
    enum class AssetType {
        Texture,
        Model,
        Sound,
        Script
    };

    // GARBAGE_CPP_ASSET_LOADER_270_014
    class AssetLoader {
    public:
        // GARBAGE_CPP_ASSET_LOAD_270_015
        void* load(const std::string& path, AssetType type) {
            // GARBAGE_CPP_ASSET_LOAD_IMPL_270_016
            return nullptr;
        }

        // GARBAGE_CPP_ASSET_UNLOAD_270_017
        void unload(void* asset) {
            // GARBAGE_CPP_ASSET_UNLOAD_IMPL_270_018
        }

        // GARBAGE_CPP_ASSET_RELOAD_270_019
        void reload(const std::string& path) {
            // GARBAGE_CPP_ASSET_RELOAD_IMPL_270_020
        }
    };

    }

  src/derived.cpp: |
    #include <iostream>
    int main() { return 0; }

changed:
  src/derived.cpp: |
    #include "entity/base.hpp"
    #include <iostream>
    #include <vector>
    #include <sstream>

    namespace app::game {

    class Character : public entity::Base {
    public:
        Character(const std::string& name, int health, int level)
            : characterName_(name), health_(health), level_(level) {}

        std::string name() const override { return characterName_; }

        entity::EntityType type() const override {
            return entity::EntityType::Character;
        }

        void process() override {
            if (!isActive()) return;
            std::cout << "Processing character: " << characterName_ << "\n";
        }

        void update(float deltaTime) override {
            if (!isActive()) return;
            std::cout << characterName_ << " updating, dt=" << deltaTime << "\n";
        }

        std::string serialize() const override {
            std::ostringstream oss;
            oss << "{\"name\":\"" << characterName_ << "\","
                << "\"health\":" << health_ << ","
                << "\"level\":" << level_ << "}";
            return oss.str();
        }

        void deserialize(const std::string& data) override {
            std::cout << "Deserializing character from: " << data << "\n";
        }

        int health() const { return health_; }
        int level() const { return level_; }
        void takeDamage(int amount) { health_ -= amount; }

    private:
        std::string characterName_;
        int health_;
        int level_;
    };

    class Item : public entity::Base {
    public:
        Item(const std::string& name, int value)
            : itemName_(name), value_(value) {}

        std::string name() const override { return itemName_; }

        entity::EntityType type() const override {
            return entity::EntityType::Item;
        }

        void process() override {
            std::cout << "Item " << itemName_ << " processed\n";
        }

        std::string serialize() const override {
            std::ostringstream oss;
            oss << "{\"name\":\"" << itemName_ << "\",\"value\":" << value_ << "}";
            return oss.str();
        }

        int getValue() const { return value_; }

    private:
        std::string itemName_;
        int value_;
    };

    class HealthComponent : public entity::Component {
    public:
        explicit HealthComponent(int maxHealth)
            : maxHealth_(maxHealth), currentHealth_(maxHealth) {}

        void onAttach() override {
            std::cout << "HealthComponent attached\n";
        }

        void onDetach() override {
            std::cout << "HealthComponent detached\n";
        }

        void tick(float dt) override {
            if (regenerating_) {
                currentHealth_ = std::min(maxHealth_, currentHealth_ + static_cast<int>(dt * 5));
            }
        }

        std::string componentName() const override {
            return "HealthComponent";
        }

        void setRegenerating(bool regen) { regenerating_ = regen; }
        int currentHealth() const { return currentHealth_; }
        int maxHealth() const { return maxHealth_; }

    private:
        int maxHealth_;
        int currentHealth_;
        bool regenerating_ = false;
    };

    class MovementComponent : public entity::Component {
    public:
        MovementComponent(float speed) : speed_(speed) {}

        void onAttach() override {
            std::cout << "MovementComponent attached with speed " << speed_ << "\n";
        }

        void tick(float dt) override {
            positionX_ += velocityX_ * speed_ * dt;
            positionY_ += velocityY_ * speed_ * dt;
        }

        std::string componentName() const override {
            return "MovementComponent";
        }

        void setVelocity(float vx, float vy) {
            velocityX_ = vx;
            velocityY_ = vy;
        }

        float posX() const { return positionX_; }
        float posY() const { return positionY_; }

    private:
        float speed_;
        float positionX_ = 0.0f;
        float positionY_ = 0.0f;
        float velocityX_ = 0.0f;
        float velocityY_ = 0.0f;
    };

    }

    int main() {
        std::vector<std::unique_ptr<app::entity::Base>> entities;

        entities.push_back(std::make_unique<app::game::Character>("Hero", 100, 5));
        entities.push_back(std::make_unique<app::game::Character>("Villain", 150, 7));
        entities.push_back(std::make_unique<app::game::Item>("Sword", 50));
        entities.push_back(std::make_unique<app::game::Item>("Shield", 30));

        std::cout << "=== Entity Processing ===\n";
        for (auto& entity : entities) {
            std::cout << "Entity: " << entity->name()
                      << " Type: " << static_cast<int>(entity->type()) << "\n";
            entity->process();
        }

        std::cout << "\n=== Serialization ===\n";
        for (auto& entity : entities) {
            std::cout << entity->name() << ": " << entity->serialize() << "\n";
        }

        std::cout << "\n=== Update Cycle ===\n";
        entities[2]->setActive(false);
        for (auto& entity : entities) {
            entity->update(0.016f);
        }

        std::cout << "\n=== Components ===\n";
        std::vector<std::unique_ptr<app::entity::Component>> components;
        components.push_back(std::make_unique<app::game::HealthComponent>(100));
        components.push_back(std::make_unique<app::game::MovementComponent>(5.0f));

        for (auto& comp : components) {
            comp->onAttach();
            std::cout << "Component: " << comp->componentName() << "\n";
            comp->tick(0.1f);
        }

        return 0;
    }

assertions:
  must_include:
    - Character
    - override
    - Base
    - Item
    - HealthComponent
    - MovementComponent
    - serialize
    - process
    - componentName
  must_not_include:
    - GARBAGE_CPP_NETWORK_270_001
    - GARBAGE_CPP_NETWORK_PORT_270_002
    - GARBAGE_CPP_NETWORK_PACKET_270_003
    - GARBAGE_CPP_NETWORK_CHECKSUM_270_004
    - GARBAGE_CPP_NETWORK_PROTOCOL_270_005
    - GARBAGE_CPP_NETWORK_ENCODE_270_006
    - GARBAGE_CPP_NETWORK_DECODE_270_008
    - GARBAGE_CPP_NETWORK_VALIDATE_270_010
    - GARBAGE_CPP_ASSET_270_012
    - GARBAGE_CPP_ASSET_TYPE_270_013
    - GARBAGE_CPP_ASSET_LOADER_270_014
    - GARBAGE_CPP_ASSET_LOAD_270_015
    - GARBAGE_CPP_ASSET_UNLOAD_270_017
    - GARBAGE_CPP_ASSET_RELOAD_270_019
    - NetworkProtocol
    - AssetLoader
    - Packet
    - AssetType
options:
  commit_message: Add entity system with override specifiers for polymorphism
