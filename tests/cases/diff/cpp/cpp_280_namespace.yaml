name: cpp_280_namespace
initial:
  include/utils/utils.hpp: |
    #pragma once
    #include <string>
    #include <algorithm>
    #include <cctype>
    #include <sstream>
    #include <vector>
    #include <iomanip>

    namespace app::utils {

    std::string trim(const std::string& s) {
        size_t start = s.find_first_not_of(" \t\n\r");
        size_t end = s.find_last_not_of(" \t\n\r");
        return (start == std::string::npos) ? "" : s.substr(start, end - start + 1);
    }

    std::string toUpper(const std::string& s) {
        std::string result = s;
        std::transform(result.begin(), result.end(), result.begin(), ::toupper);
        return result;
    }

    std::string toLower(const std::string& s) {
        std::string result = s;
        std::transform(result.begin(), result.end(), result.begin(), ::tolower);
        return result;
    }

    std::vector<std::string> split(const std::string& s, char delimiter) {
        std::vector<std::string> tokens;
        std::stringstream ss(s);
        std::string token;
        while (std::getline(ss, token, delimiter)) {
            tokens.push_back(token);
        }
        return tokens;
    }

    std::string join(const std::vector<std::string>& parts, const std::string& delimiter) {
        std::string result;
        for (size_t i = 0; i < parts.size(); ++i) {
            if (i > 0) result += delimiter;
            result += parts[i];
        }
        return result;
    }

    bool startsWith(const std::string& s, const std::string& prefix) {
        return s.size() >= prefix.size() && s.substr(0, prefix.size()) == prefix;
    }

    bool endsWith(const std::string& s, const std::string& suffix) {
        return s.size() >= suffix.size() &&
               s.substr(s.size() - suffix.size()) == suffix;
    }

    std::string replace(const std::string& s, const std::string& from, const std::string& to) {
        std::string result = s;
        size_t pos = 0;
        while ((pos = result.find(from, pos)) != std::string::npos) {
            result.replace(pos, from.length(), to);
            pos += to.length();
        }
        return result;
    }

    }

    namespace app::utils::format {

    std::string padLeft(const std::string& s, size_t width, char padChar = ' ') {
        if (s.size() >= width) return s;
        return std::string(width - s.size(), padChar) + s;
    }

    std::string padRight(const std::string& s, size_t width, char padChar = ' ') {
        if (s.size() >= width) return s;
        return s + std::string(width - s.size(), padChar);
    }

    template<typename T>
    std::string toHex(T value) {
        std::ostringstream oss;
        oss << std::hex << std::uppercase << value;
        return oss.str();
    }

    }

  include/unrelated/binary_tree.hpp: |
    #pragma once
    // GARBAGE_CPP_TREE_280_001
    #define GARBAGE_CPP_TREE_MAX_DEPTH_280_002 100

    namespace app::unrelated::tree {

    // GARBAGE_CPP_TREE_NODE_280_003
    template<typename T>
    struct TreeNode {
        T value;
        TreeNode* left;
        TreeNode* right;
        // GARBAGE_CPP_TREE_PARENT_280_004
    };

    // GARBAGE_CPP_TREE_CLASS_280_005
    template<typename T>
    class BinaryTree {
    public:
        // GARBAGE_CPP_TREE_INSERT_280_006
        void insert(const T& value) {
            // GARBAGE_CPP_TREE_INSERT_IMPL_280_007
        }

        // GARBAGE_CPP_TREE_FIND_280_008
        TreeNode<T>* find(const T& value) {
            // GARBAGE_CPP_TREE_FIND_IMPL_280_009
            return nullptr;
        }

        // GARBAGE_CPP_TREE_REMOVE_280_010
        void remove(const T& value) {
            // GARBAGE_CPP_TREE_REMOVE_IMPL_280_011
        }
    };

    }

  src/unrelated/graph_algorithm.cpp: |
    // GARBAGE_CPP_GRAPH_280_012
    #include <vector>

    namespace app::unrelated::graph {

    // GARBAGE_CPP_GRAPH_EDGE_280_013
    struct Edge {
        int from;
        int to;
        float weight;
        // GARBAGE_CPP_GRAPH_FLAGS_280_014
    };

    // GARBAGE_CPP_GRAPH_CLASS_280_015
    class Graph {
    public:
        // GARBAGE_CPP_GRAPH_ADD_280_016
        void addEdge(int from, int to, float weight) {
            // GARBAGE_CPP_GRAPH_ADD_IMPL_280_017
        }

        // GARBAGE_CPP_GRAPH_BFS_280_018
        std::vector<int> bfs(int start) {
            // GARBAGE_CPP_GRAPH_BFS_IMPL_280_019
            return {};
        }

        // GARBAGE_CPP_GRAPH_DFS_280_020
        std::vector<int> dfs(int start) {
            // GARBAGE_CPP_GRAPH_DFS_IMPL_280_021
            return {};
        }
    };

    }

  src/app.cpp: |
    #include <iostream>
    int main() { return 0; }

changed:
  src/app.cpp: |
    #include "utils/utils.hpp"
    #include <iostream>
    #include <map>

    using app::utils::trim;
    using app::utils::toUpper;
    using app::utils::toLower;
    using app::utils::split;
    using app::utils::join;
    using app::utils::startsWith;
    using app::utils::endsWith;
    using app::utils::replace;

    namespace app::text {

    class TextProcessor {
    public:
        std::string normalizeWhitespace(const std::string& text) {
            auto words = split(trim(text), ' ');
            std::vector<std::string> nonEmpty;
            for (const auto& word : words) {
                auto trimmed = trim(word);
                if (!trimmed.empty()) {
                    nonEmpty.push_back(trimmed);
                }
            }
            return join(nonEmpty, " ");
        }

        std::string toTitleCase(const std::string& text) {
            auto words = split(text, ' ');
            for (auto& word : words) {
                if (!word.empty()) {
                    word = toUpper(word.substr(0, 1)) + toLower(word.substr(1));
                }
            }
            return join(words, " ");
        }

        std::string toCamelCase(const std::string& text) {
            auto words = split(toLower(text), ' ');
            std::string result;
            for (size_t i = 0; i < words.size(); ++i) {
                if (words[i].empty()) continue;
                if (i == 0) {
                    result += words[i];
                } else {
                    result += toUpper(words[i].substr(0, 1)) + words[i].substr(1);
                }
            }
            return result;
        }

        std::string toSnakeCase(const std::string& text) {
            auto normalized = normalizeWhitespace(toLower(text));
            return replace(normalized, " ", "_");
        }

        std::string toKebabCase(const std::string& text) {
            auto normalized = normalizeWhitespace(toLower(text));
            return replace(normalized, " ", "-");
        }
    };

    class PathUtils {
    public:
        std::string getExtension(const std::string& path) {
            auto parts = split(path, '.');
            return parts.size() > 1 ? parts.back() : "";
        }

        std::string getFilename(const std::string& path) {
            auto parts = split(path, '/');
            return parts.empty() ? path : parts.back();
        }

        std::string getDirectory(const std::string& path) {
            auto parts = split(path, '/');
            if (parts.size() <= 1) return "";
            parts.pop_back();
            return join(parts, "/");
        }

        bool hasExtension(const std::string& path, const std::string& ext) {
            return endsWith(path, "." + ext);
        }

        std::string changeExtension(const std::string& path, const std::string& newExt) {
            auto parts = split(path, '.');
            if (parts.size() > 1) {
                parts.back() = newExt;
            } else {
                parts.push_back(newExt);
            }
            return join(parts, ".");
        }
    };

    class TemplateEngine {
    public:
        void setVariable(const std::string& name, const std::string& value) {
            variables_[name] = value;
        }

        std::string render(const std::string& templateStr) {
            std::string result = templateStr;
            for (const auto& [name, value] : variables_) {
                result = replace(result, "{{" + name + "}}", value);
            }
            return result;
        }

        void clearVariables() {
            variables_.clear();
        }

    private:
        std::map<std::string, std::string> variables_;
    };

    }

    int main() {
        std::cout << "=== Basic String Utils ===\n";
        std::cout << "trim: '" << trim("  hello world  ") << "'\n";
        std::cout << "toUpper: " << toUpper("hello world") << "\n";
        std::cout << "toLower: " << toLower("HELLO WORLD") << "\n";

        auto parts = split("a,b,c,d", ',');
        std::cout << "split count: " << parts.size() << "\n";
        std::cout << "join: " << join(parts, "-") << "\n";

        std::cout << "startsWith 'hello' with 'hel': " << startsWith("hello", "hel") << "\n";
        std::cout << "endsWith 'hello' with 'lo': " << endsWith("hello", "lo") << "\n";
        std::cout << "replace: " << replace("foo bar foo", "foo", "baz") << "\n";

        std::cout << "\n=== Format Utils ===\n";
        std::cout << "padLeft: '" << app::utils::format::padLeft("42", 5, '0') << "'\n";
        std::cout << "padRight: '" << app::utils::format::padRight("hi", 5) << "'\n";
        std::cout << "toHex(255): " << app::utils::format::toHex(255) << "\n";

        std::cout << "\n=== Text Processor ===\n";
        app::text::TextProcessor processor;
        std::cout << "normalizeWhitespace: '" << processor.normalizeWhitespace("  hello   world  ") << "'\n";
        std::cout << "toTitleCase: " << processor.toTitleCase("hello world example") << "\n";
        std::cout << "toCamelCase: " << processor.toCamelCase("hello world example") << "\n";
        std::cout << "toSnakeCase: " << processor.toSnakeCase("Hello World Example") << "\n";
        std::cout << "toKebabCase: " << processor.toKebabCase("Hello World Example") << "\n";

        std::cout << "\n=== Path Utils ===\n";
        app::text::PathUtils paths;
        std::cout << "getExtension: " << paths.getExtension("/path/to/file.txt") << "\n";
        std::cout << "getFilename: " << paths.getFilename("/path/to/file.txt") << "\n";
        std::cout << "getDirectory: " << paths.getDirectory("/path/to/file.txt") << "\n";
        std::cout << "hasExtension: " << paths.hasExtension("file.txt", "txt") << "\n";
        std::cout << "changeExtension: " << paths.changeExtension("file.txt", "md") << "\n";

        std::cout << "\n=== Template Engine ===\n";
        app::text::TemplateEngine engine;
        engine.setVariable("name", "Alice");
        engine.setVariable("greeting", "Hello");
        std::cout << engine.render("{{greeting}}, {{name}}!") << "\n";

        return 0;
    }

assertions:
  must_include:
    - trim
    - toUpper
    - app::utils
    - TextProcessor
    - PathUtils
    - TemplateEngine
    - normalizeWhitespace
    - getExtension
    - render
  must_not_include:
    - GARBAGE_CPP_TREE_280_001
    - GARBAGE_CPP_TREE_MAX_DEPTH_280_002
    - GARBAGE_CPP_TREE_NODE_280_003
    - GARBAGE_CPP_TREE_PARENT_280_004
    - GARBAGE_CPP_TREE_CLASS_280_005
    - GARBAGE_CPP_TREE_INSERT_280_006
    - GARBAGE_CPP_TREE_FIND_280_008
    - GARBAGE_CPP_TREE_REMOVE_280_010
    - GARBAGE_CPP_GRAPH_280_012
    - GARBAGE_CPP_GRAPH_EDGE_280_013
    - GARBAGE_CPP_GRAPH_FLAGS_280_014
    - GARBAGE_CPP_GRAPH_CLASS_280_015
    - GARBAGE_CPP_GRAPH_ADD_280_016
    - GARBAGE_CPP_GRAPH_BFS_280_018
    - GARBAGE_CPP_GRAPH_DFS_280_020
    - BinaryTree
    - Graph
    - TreeNode
    - Edge
options:
  commit_message: Add text processing and path utilities using namespaces
