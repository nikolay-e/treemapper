include/utils/utils.hpp: |
  #pragma once
  #include <string>
  #include <algorithm>
  #include <cctype>
  #include <sstream>
  #include <vector>
  #include <iomanip>

  namespace app::utils {

  std::string trim(const std::string& s) {
      size_t start = s.find_first_not_of(" \t\n\r");
      size_t end = s.find_last_not_of(" \t\n\r");
      return (start == std::string::npos) ? "" : s.substr(start, end - start + 1);
  }

  std::string toUpper(const std::string& s) {
      std::string result = s;
      std::transform(result.begin(), result.end(), result.begin(), ::toupper);
      return result;
  }

  std::string toLower(const std::string& s) {
      std::string result = s;
      std::transform(result.begin(), result.end(), result.begin(), ::tolower);
      return result;
  }

  std::vector<std::string> split(const std::string& s, char delimiter) {
      std::vector<std::string> tokens;
      std::stringstream ss(s);
      std::string token;
      while (std::getline(ss, token, delimiter)) {
          tokens.push_back(token);
      }
      return tokens;
  }

  std::string join(const std::vector<std::string>& parts, const std::string& delimiter) {
      std::string result;
      for (size_t i = 0; i < parts.size(); ++i) {
          if (i > 0) result += delimiter;
          result += parts[i];
      }
      return result;
  }

  bool startsWith(const std::string& s, const std::string& prefix) {
      return s.size() >= prefix.size() && s.substr(0, prefix.size()) == prefix;
  }

  bool endsWith(const std::string& s, const std::string& suffix) {
      return s.size() >= suffix.size() &&
             s.substr(s.size() - suffix.size()) == suffix;
  }

  std::string replace(const std::string& s, const std::string& from, const std::string& to) {
      std::string result = s;
      size_t pos = 0;
      while ((pos = result.find(from, pos)) != std::string::npos) {
          result.replace(pos, from.length(), to);
          pos += to.length();
      }
      return result;
  }

  }

  namespace app::utils::format {

  std::string padLeft(const std::string& s, size_t width, char padChar = ' ') {
      if (s.size() >= width) return s;
      return std::string(width - s.size(), padChar) + s;
  }

  std::string padRight(const std::string& s, size_t width, char padChar = ' ') {
      if (s.size() >= width) return s;
      return s + std::string(width - s.size(), padChar);
  }

  template<typename T>
  std::string toHex(T value) {
      std::ostringstream oss;
      oss << std::hex << std::uppercase << value;
      return oss.str();
  }

  }
include/unrelated/binary_tree.hpp: |
  #pragma once
  // GARBAGE_CPP_TREE_280_001
  #define GARBAGE_CPP_TREE_MAX_DEPTH_280_002 100

  namespace app::unrelated::tree {

  // GARBAGE_CPP_TREE_NODE_280_003
  template<typename T>
  struct TreeNode {
      T value;
      TreeNode* left;
      TreeNode* right;
      // GARBAGE_CPP_TREE_PARENT_280_004
  };

  // GARBAGE_CPP_TREE_CLASS_280_005
  template<typename T>
  class BinaryTree {
  public:
      // GARBAGE_CPP_TREE_INSERT_280_006
      void insert(const T& value) {
          // GARBAGE_CPP_TREE_INSERT_IMPL_280_007
      }

      // GARBAGE_CPP_TREE_FIND_280_008
      TreeNode<T>* find(const T& value) {
          // GARBAGE_CPP_TREE_FIND_IMPL_280_009
          return nullptr;
      }

      // GARBAGE_CPP_TREE_REMOVE_280_010
      void remove(const T& value) {
          // GARBAGE_CPP_TREE_REMOVE_IMPL_280_011
      }
  };

  }
src/unrelated/graph_algorithm.cpp: |
  // GARBAGE_CPP_GRAPH_280_012
  #include <vector>

  namespace app::unrelated::graph {

  // GARBAGE_CPP_GRAPH_EDGE_280_013
  struct Edge {
      int from;
      int to;
      float weight;
      // GARBAGE_CPP_GRAPH_FLAGS_280_014
  };

  // GARBAGE_CPP_GRAPH_CLASS_280_015
  class Graph {
  public:
      // GARBAGE_CPP_GRAPH_ADD_280_016
      void addEdge(int from, int to, float weight) {
          // GARBAGE_CPP_GRAPH_ADD_IMPL_280_017
      }

      // GARBAGE_CPP_GRAPH_BFS_280_018
      std::vector<int> bfs(int start) {
          // GARBAGE_CPP_GRAPH_BFS_IMPL_280_019
          return {};
      }

      // GARBAGE_CPP_GRAPH_DFS_280_020
      std::vector<int> dfs(int start) {
          // GARBAGE_CPP_GRAPH_DFS_IMPL_280_021
          return {};
      }
  };

  }
src/app.cpp: |
  #include <iostream>
  int main() { return 0; }
