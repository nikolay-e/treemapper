src/main/java/com/eventbus/consumer/OrderEventConsumer.java: |
  package com.eventbus.consumer;

  import org.springframework.kafka.annotation.KafkaListener;
  import org.springframework.stereotype.Component;
  import org.slf4j.Logger;
  import org.slf4j.LoggerFactory;

  @Component
  public class OrderEventConsumer {
      private static final Logger log = LoggerFactory.getLogger(OrderEventConsumer.class);

      @KafkaListener(topics = "orders")
      public void handleOrderEvent(String message) {
          log.info("Received order event: {}", message);
      }
  }
src/main/java/com/eventbus/producer/EventProducer.java: |
  package com.eventbus.producer;

  import org.springframework.kafka.core.KafkaTemplate;
  import org.springframework.stereotype.Component;
  import org.slf4j.Logger;
  import org.slf4j.LoggerFactory;

  @Component
  public class EventProducer {
      private static final Logger log = LoggerFactory.getLogger(EventProducer.class);
      private final KafkaTemplate<String, String> kafkaTemplate;

      public EventProducer(KafkaTemplate<String, String> kafkaTemplate) {
          this.kafkaTemplate = kafkaTemplate;
      }

      public void sendEvent(String topic, String message) {
          log.info("Sending event to {}: {}", topic, message);
          kafkaTemplate.send(topic, message);
      }
  }
src/main/java/com/eventbus/model/OrderEvent.java: |
  package com.eventbus.model;

  import java.math.BigDecimal;
  import java.time.Instant;

  public record OrderEvent(
      String orderId,
      String customerId,
      BigDecimal totalAmount,
      String status,
      Instant timestamp
  ) {}
src/main/java/com/eventbus/unrelated/WebSocketHandler.java: |
  package com.eventbus.unrelated;

  import java.util.concurrent.ConcurrentHashMap;
  import java.util.Set;

  public class WebSocketHandler {
      public static final String GARBAGE_JAVA_WEBSOCKET_901 = "websocket_marker_theta2";
      private static final String GARBAGE_JAVA_SESSION_902 = "session_marker_iota2";

      private final Set<String> activeSessions = ConcurrentHashMap.newKeySet();

      public void addSession(String sessionId) {
          activeSessions.add(sessionId);
          logGarbageMarkers();
      }

      public void removeSession(String sessionId) {
          activeSessions.remove(sessionId);
      }

      public int getActiveSessionCount() {
          return activeSessions.size();
      }

      private void logGarbageMarkers() {
          System.out.println(GARBAGE_JAVA_WEBSOCKET_901 + GARBAGE_JAVA_SESSION_902);
      }
  }
src/main/java/com/eventbus/unrelated/CacheManager.java: |
  package com.eventbus.unrelated;

  import java.time.Duration;
  import java.util.Map;
  import java.util.concurrent.ConcurrentHashMap;

  public class CacheManager {
      public static final String GARBAGE_JAVA_CACHE_903 = "cache_marker_kappa2";

      private final Map<String, CacheEntry> cache = new ConcurrentHashMap<>();

      public void put(String key, Object value, Duration ttl) {
          cache.put(key, new CacheEntry(value, System.currentTimeMillis() + ttl.toMillis()));
          String GARBAGE_JAVA_TTL_904 = "ttl_marker_lambda2";
          System.out.println(GARBAGE_JAVA_CACHE_903 + GARBAGE_JAVA_TTL_904);
      }

      public Object get(String key) {
          CacheEntry entry = cache.get(key);
          if (entry != null && entry.expiresAt > System.currentTimeMillis()) {
              return entry.value;
          }
          return null;
      }

      private record CacheEntry(Object value, long expiresAt) {}
  }
