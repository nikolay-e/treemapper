src/main/java/com/stocktrading/model/StockPrice.java: "package com.stocktrading.model;\n\nimport java.math.BigDecimal;\nimport java.time.Instant;\n\npublic class StockPrice {\n    private final String symbol;\n\
  \    private final BigDecimal price;\n    private final BigDecimal previousClose;\n    private final long volume;\n    private final Instant timestamp;\n\n    public StockPrice(String symbol, BigDecimal\
  \ price, BigDecimal previousClose, long volume) {\n        this.symbol = symbol;\n        this.price = price;\n        this.previousClose = previousClose;\n        this.volume = volume;\n        this.timestamp\
  \ = Instant.now();\n    }\n\n    public String getSymbol() { return symbol; }\n    public BigDecimal getPrice() { return price; }\n    public BigDecimal getPreviousClose() { return previousClose; }\n\
  \    public long getVolume() { return volume; }\n    public Instant getTimestamp() { return timestamp; }\n\n    public BigDecimal getChange() {\n        return price.subtract(previousClose);\n    }\n\n\
  \    public BigDecimal getChangePercent() {\n        if (previousClose.compareTo(BigDecimal.ZERO) == 0) {\n            return BigDecimal.ZERO;\n        }\n        return getChange().divide(previousClose,\
  \ 4, java.math.RoundingMode.HALF_UP)\n            .multiply(new BigDecimal(\"100\"));\n    }\n}\n"
src/main/java/com/stocktrading/service/PriceUpdateService.java: "package com.stocktrading.service;\n\nimport com.stocktrading.model.StockPrice;\nimport com.stocktrading.observer.PriceSubject;\nimport org.springframework.stereotype.Service;\n\
  import java.math.BigDecimal;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Service\npublic class PriceUpdateService {\n    private final Map<String, StockPrice> currentPrices = new HashMap<>();\n\
  \    private final PriceSubject priceSubject;\n\n    public PriceUpdateService(PriceSubject priceSubject) {\n        this.priceSubject = priceSubject;\n    }\n\n    public void updatePrice(String symbol,\
  \ BigDecimal price, BigDecimal previousClose, long volume) {\n        StockPrice stockPrice = new StockPrice(symbol, price, previousClose, volume);\n        currentPrices.put(symbol, stockPrice);\n  \
  \      priceSubject.notifyObservers(stockPrice);\n    }\n\n    public StockPrice getPrice(String symbol) {\n        return currentPrices.get(symbol);\n    }\n\n    public Map<String, StockPrice> getAllPrices()\
  \ {\n        return new HashMap<>(currentPrices);\n    }\n\n    public PriceSubject getPriceSubject() {\n        return priceSubject;\n    }\n}\n"
src/test/java/com/demo/math/TemperatureConverter.java: "package com.demo.math;\n\npublic class TemperatureConverter {\n\n    public double celsiusToFahrenheit(double c) {\n        return c * 1.8 + 32;\n\
  \    }\n\n    public double fahrenheitToCelsius(double f) {\n        return (f - 32) / 1.8;\n    }\n}\n"
src/test/java/com/demo/shapes/CircleCalculator.java: "package com.demo.shapes;\n\npublic class CircleCalculator {\n\n    public double calculateArea(double r) {\n        return 3.14159 * r * r;\n    }\n\
  }\n"
src/test/java/com/demo/text/WordCounter.java: "package com.demo.text;\n\npublic class WordCounter {\n\n    public int countWords(String t) {\n        return t == null ? 0 : t.split(\" \").length;\n    }\n\
  \n    public int countCharacters(String t) {\n        return t == null ? 0 : t.length();\n    }\n}\n"
src/main/java/com/stocktrading/observer/PriceObserver.java: "package com.stocktrading.observer;\n\nimport com.stocktrading.model.StockPrice;\n\n@FunctionalInterface\npublic interface PriceObserver {\n \
  \   void onPriceUpdate(StockPrice price);\n\n    default void onError(String symbol, Exception error) {\n    }\n\n    default boolean interestedIn(String symbol) {\n        return true;\n    }\n}\n"
src/main/java/com/stocktrading/observer/PriceChangeEvent.java: "package com.stocktrading.observer;\n\nimport com.stocktrading.model.StockPrice;\nimport java.math.BigDecimal;\nimport java.time.Instant;\n\
  \npublic record PriceChangeEvent(\n    String symbol,\n    StockPrice newPrice,\n    StockPrice previousPrice,\n    BigDecimal absoluteChange,\n    BigDecimal percentChange,\n    Instant eventTime\n)\
  \ {\n    public static PriceChangeEvent from(StockPrice newPrice, StockPrice previousPrice) {\n        BigDecimal absoluteChange = newPrice.getPrice().subtract(\n            previousPrice != null ? previousPrice.getPrice()\
  \ : newPrice.getPreviousClose()\n        );\n        BigDecimal base = previousPrice != null ? previousPrice.getPrice() : newPrice.getPreviousClose();\n        BigDecimal percentChange = BigDecimal.ZERO;\n\
  \        if (base.compareTo(BigDecimal.ZERO) != 0) {\n            percentChange = absoluteChange.divide(base, 4, java.math.RoundingMode.HALF_UP)\n                .multiply(new BigDecimal(\"100\"));\n\
  \        }\n        return new PriceChangeEvent(\n            newPrice.getSymbol(),\n            newPrice,\n            previousPrice,\n            absoluteChange,\n            percentChange,\n      \
  \      Instant.now()\n        );\n    }\n\n    public boolean isSignificantChange(BigDecimal threshold) {\n        return percentChange.abs().compareTo(threshold) >= 0;\n    }\n}\n"
src/main/java/com/stocktrading/observer/PriceAlertObserver.java: "package com.stocktrading.observer;\n\nimport com.stocktrading.model.StockPrice;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\
  \nimport java.math.BigDecimal;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class PriceAlertObserver implements PriceObserver {\n    private static final Logger log\
  \ = LoggerFactory.getLogger(PriceAlertObserver.class);\n\n    private final Map<String, BigDecimal> upperThresholds = new ConcurrentHashMap<>();\n    private final Map<String, BigDecimal> lowerThresholds\
  \ = new ConcurrentHashMap<>();\n    private final AlertCallback callback;\n\n    public PriceAlertObserver(AlertCallback callback) {\n        this.callback = callback;\n    }\n\n    public void setUpperThreshold(String\
  \ symbol, BigDecimal price) {\n        upperThresholds.put(symbol, price);\n    }\n\n    public void setLowerThreshold(String symbol, BigDecimal price) {\n        lowerThresholds.put(symbol, price);\n\
  \    }\n\n    public void removeThresholds(String symbol) {\n        upperThresholds.remove(symbol);\n        lowerThresholds.remove(symbol);\n    }\n\n    @Override\n    public void onPriceUpdate(StockPrice\
  \ price) {\n        String symbol = price.getSymbol();\n        BigDecimal currentPrice = price.getPrice();\n\n        BigDecimal upper = upperThresholds.get(symbol);\n        if (upper != null && currentPrice.compareTo(upper)\
  \ >= 0) {\n            log.info(\"Upper threshold triggered for {}: {} >= {}\", symbol, currentPrice, upper);\n            callback.onAlert(symbol, AlertType.UPPER_THRESHOLD, currentPrice, upper);\n \
  \       }\n\n        BigDecimal lower = lowerThresholds.get(symbol);\n        if (lower != null && currentPrice.compareTo(lower) <= 0) {\n            log.info(\"Lower threshold triggered for {}: {} <=\
  \ {}\", symbol, currentPrice, lower);\n            callback.onAlert(symbol, AlertType.LOWER_THRESHOLD, currentPrice, lower);\n        }\n    }\n\n    @Override\n    public boolean interestedIn(String\
  \ symbol) {\n        return upperThresholds.containsKey(symbol) || lowerThresholds.containsKey(symbol);\n    }\n\n    public enum AlertType {\n        UPPER_THRESHOLD, LOWER_THRESHOLD\n    }\n\n    @FunctionalInterface\n\
  \    public interface AlertCallback {\n        void onAlert(String symbol, AlertType type, BigDecimal currentPrice, BigDecimal threshold);\n    }\n}\n"
src/main/java/com/stocktrading/observer/PriceSubject.java: "package com.stocktrading.observer;\n\nimport com.stocktrading.model.StockPrice;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport\
  \ org.springframework.stereotype.Component;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport\
  \ java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n@Component\npublic class PriceSubject {\n    private static final Logger log = LoggerFactory.getLogger(PriceSubject.class);\n\
  \n    private final List<PriceObserver> observers = new CopyOnWriteArrayList<>();\n    private final Map<String, StockPrice> lastPrices = new ConcurrentHashMap<>();\n    private final ExecutorService\
  \ notificationExecutor;\n    private volatile boolean asyncNotifications;\n\n    public PriceSubject() {\n        this.notificationExecutor = Executors.newFixedThreadPool(4);\n        this.asyncNotifications\
  \ = true;\n    }\n\n    public void attach(PriceObserver observer) {\n        if (!observers.contains(observer)) {\n            observers.add(observer);\n            log.debug(\"Observer attached: {}\"\
  , observer.getClass().getSimpleName());\n        }\n    }\n\n    public void detach(PriceObserver observer) {\n        observers.remove(observer);\n        log.debug(\"Observer detached: {}\", observer.getClass().getSimpleName());\n\
  \    }\n\n    public void notifyObservers(StockPrice price) {\n        StockPrice previous = lastPrices.put(price.getSymbol(), price);\n        PriceChangeEvent event = PriceChangeEvent.from(price, previous);\n\
  \n        for (PriceObserver observer : observers) {\n            if (observer.interestedIn(price.getSymbol())) {\n                if (asyncNotifications) {\n                    notificationExecutor.submit(()\
  \ -> safeNotify(observer, price, event));\n                } else {\n                    safeNotify(observer, price, event);\n                }\n            }\n        }\n    }\n\n    private void safeNotify(PriceObserver\
  \ observer, StockPrice price, PriceChangeEvent event) {\n        try {\n            observer.onPriceUpdate(price);\n        } catch (Exception e) {\n            log.error(\"Error notifying observer {}\
  \ for symbol {}\",\n                observer.getClass().getSimpleName(), price.getSymbol(), e);\n            observer.onError(price.getSymbol(), e);\n        }\n    }\n\n    public int getObserverCount()\
  \ {\n        return observers.size();\n    }\n\n    public StockPrice getLastPrice(String symbol) {\n        return lastPrices.get(symbol);\n    }\n\n    public void setAsyncNotifications(boolean async)\
  \ {\n        this.asyncNotifications = async;\n    }\n\n    public void shutdown() {\n        notificationExecutor.shutdown();\n    }\n}\n"
