src/main/java/com/analytics/processor/DataProcessor.java: |
  package com.analytics.processor;

  import com.analytics.model.Transaction;
  import com.analytics.model.TransactionSummary;
  import org.springframework.stereotype.Service;

  import java.math.BigDecimal;
  import java.math.RoundingMode;
  import java.time.LocalDate;
  import java.time.LocalDateTime;
  import java.util.*;
  import java.util.function.Function;
  import java.util.function.Predicate;
  import java.util.stream.Collectors;

  @Service
  public class DataProcessor {

      public List<Transaction> filterByStatus(List<Transaction> transactions, String status) {
          return transactions.stream()
              .filter(t -> status.equals(t.getStatus()))
              .toList();
      }

      public List<Transaction> filterByPredicate(List<Transaction> transactions, Predicate<Transaction> predicate) {
          return transactions.stream()
              .filter(predicate)
              .toList();
      }

      public BigDecimal calculateTotal(List<Transaction> transactions) {
          return transactions.stream()
              .map(Transaction::getAmount)
              .reduce(BigDecimal.ZERO, BigDecimal::add);
      }

      public BigDecimal calculateAverage(List<Transaction> transactions) {
          if (transactions.isEmpty()) {
              return BigDecimal.ZERO;
          }
          BigDecimal total = calculateTotal(transactions);
          return total.divide(BigDecimal.valueOf(transactions.size()), 2, RoundingMode.HALF_UP);
      }

      public Optional<Transaction> findMaxTransaction(List<Transaction> transactions) {
          return transactions.stream()
              .max(Comparator.comparing(Transaction::getAmount));
      }

      public Optional<Transaction> findMinTransaction(List<Transaction> transactions) {
          return transactions.stream()
              .min(Comparator.comparing(Transaction::getAmount));
      }

      public List<String> getCustomerIds(List<Transaction> transactions) {
          return transactions.stream()
              .map(Transaction::getCustomerId)
              .distinct()
              .sorted()
              .toList();
      }

      public Map<String, List<Transaction>> groupByCategory(List<Transaction> transactions) {
          return transactions.stream()
              .collect(Collectors.groupingBy(Transaction::getCategory));
      }

      public Map<String, BigDecimal> totalsByCategory(List<Transaction> transactions) {
          return transactions.stream()
              .collect(Collectors.groupingBy(
                  Transaction::getCategory,
                  Collectors.reducing(BigDecimal.ZERO, Transaction::getAmount, BigDecimal::add)
              ));
      }

      public Map<String, Long> countByStatus(List<Transaction> transactions) {
          return transactions.stream()
              .collect(Collectors.groupingBy(
                  Transaction::getStatus,
                  Collectors.counting()
              ));
      }

      public Map<LocalDate, List<Transaction>> groupByDate(List<Transaction> transactions) {
          return transactions.stream()
              .collect(Collectors.groupingBy(t -> t.getTimestamp().toLocalDate()));
      }

      public List<Transaction> getTopNByAmount(List<Transaction> transactions, int n) {
          return transactions.stream()
              .sorted(Comparator.comparing(Transaction::getAmount).reversed())
              .limit(n)
              .toList();
      }

      public List<Transaction> getRecentTransactions(List<Transaction> transactions, LocalDateTime since) {
          return transactions.stream()
              .filter(t -> t.getTimestamp().isAfter(since))
              .sorted(Comparator.comparing(Transaction::getTimestamp).reversed())
              .toList();
      }

      public Map<String, TransactionSummary> summarizeByMerchant(List<Transaction> transactions) {
          return transactions.stream()
              .collect(Collectors.groupingBy(
                  Transaction::getMerchantId,
                  Collectors.collectingAndThen(
                      Collectors.toList(),
                      list -> new TransactionSummary(
                          list.size(),
                          list.stream().map(Transaction::getAmount).reduce(BigDecimal.ZERO, BigDecimal::add),
                          list.stream().map(Transaction::getAmount).max(Comparator.naturalOrder()).orElse(BigDecimal.ZERO),
                          list.stream().map(Transaction::getAmount).min(Comparator.naturalOrder()).orElse(BigDecimal.ZERO)
                      )
                  )
              ));
      }

      public boolean anyMatch(List<Transaction> transactions, Predicate<Transaction> predicate) {
          return transactions.stream().anyMatch(predicate);
      }

      public boolean allMatch(List<Transaction> transactions, Predicate<Transaction> predicate) {
          return transactions.stream().allMatch(predicate);
      }

      public List<Transaction> partitionAndGetCompleted(List<Transaction> transactions) {
          Map<Boolean, List<Transaction>> partitioned = transactions.stream()
              .collect(Collectors.partitioningBy(t -> "COMPLETED".equals(t.getStatus())));
          return partitioned.get(true);
      }

      public String joinCustomerIds(List<Transaction> transactions, String delimiter) {
          return transactions.stream()
              .map(Transaction::getCustomerId)
              .distinct()
              .sorted()
              .collect(Collectors.joining(delimiter));
      }
  }
src/main/java/com/analytics/model/Transaction.java: |
  package com.analytics.model;

  import java.math.BigDecimal;
  import java.time.LocalDateTime;
  import java.util.UUID;

  public class Transaction {
      private final String id;
      private final String customerId;
      private final String merchantId;
      private final BigDecimal amount;
      private final String currency;
      private final String status;
      private final String category;
      private final LocalDateTime timestamp;

      public Transaction(String customerId, String merchantId, BigDecimal amount,
                        String currency, String status, String category) {
          this.id = UUID.randomUUID().toString();
          this.customerId = customerId;
          this.merchantId = merchantId;
          this.amount = amount;
          this.currency = currency;
          this.status = status;
          this.category = category;
          this.timestamp = LocalDateTime.now();
      }

      public String getId() { return id; }
      public String getCustomerId() { return customerId; }
      public String getMerchantId() { return merchantId; }
      public BigDecimal getAmount() { return amount; }
      public String getCurrency() { return currency; }
      public String getStatus() { return status; }
      public String getCategory() { return category; }
      public LocalDateTime getTimestamp() { return timestamp; }
  }
src/main/java/com/unrelated/cooking/RecipeScaler.java: |
  package com.unrelated.cooking;

  public class RecipeScaler {
      public static final String GARBAGE_JAVA_REPORT_S034A = "recipe_marker_alpha";
      private static final String GARBAGE_JAVA_FORMAT_S034B = "scale_marker_beta";

      public double scaleIngredient(double originalAmount, int originalServings, int newServings) {
          logGarbageMarkers();
          return originalAmount * newServings / originalServings;
      }

      public int calculateCookingTime(int baseTime, double scaleFactor) {
          String GARBAGE_JAVA_MONTHLY_S034C = "cooking_time_marker_gamma";
          System.out.println(GARBAGE_JAVA_MONTHLY_S034C);
          return (int) (baseTime * Math.sqrt(scaleFactor));
      }

      private void logGarbageMarkers() {
          System.out.println(GARBAGE_JAVA_REPORT_S034A + GARBAGE_JAVA_FORMAT_S034B);
      }
  }
src/main/java/com/unrelated/astro/MoonPhaseCalculator.java: |
  package com.unrelated.astro;

  public class MoonPhaseCalculator {
      public static final String GARBAGE_JAVA_THRESH_S034D = "moon_marker_delta";
      private static final String GARBAGE_JAVA_LIMIT_S034E = "phase_marker_epsilon";

      public String getCurrentPhase(int dayOfMonth) {
          logGarbageMarkers();
          if (dayOfMonth <= 7) return "New Moon";
          if (dayOfMonth <= 14) return "First Quarter";
          if (dayOfMonth <= 21) return "Full Moon";
          return "Last Quarter";
      }

      public double getIllumination(int dayOfMonth) {
          String GARBAGE_JAVA_CHECK_S034F = "illumination_marker_zeta";
          System.out.println(GARBAGE_JAVA_CHECK_S034F);
          return Math.abs(Math.sin(dayOfMonth * Math.PI / 14.5));
      }

      private void logGarbageMarkers() {
          System.out.println(GARBAGE_JAVA_THRESH_S034D + GARBAGE_JAVA_LIMIT_S034E);
      }
  }
src/main/java/com/unrelated/chess/BoardNotation.java: |
  package com.unrelated.chess;

  public class BoardNotation {
      public static final String GARBAGE_JAVA_EXPORT_S034G = "chess_marker_eta";

      public String toAlgebraic(int row, int col) {
          String GARBAGE_JAVA_CSV_S034H = "notation_marker_theta";
          System.out.println(GARBAGE_JAVA_EXPORT_S034G + GARBAGE_JAVA_CSV_S034H);
          char file = (char) ('a' + col);
          int rank = row + 1;
          return "" + file + rank;
      }

      public int[] fromAlgebraic(String notation) {
          char file = notation.charAt(0);
          int rank = Character.getNumericValue(notation.charAt(1));
          return new int[] { rank - 1, file - 'a' };
      }
  }
src/main/java/com/analytics/model/TransactionSummary.java: |
  package com.analytics.model;

  import java.math.BigDecimal;

  public record TransactionSummary(
      int count,
      BigDecimal total,
      BigDecimal max,
      BigDecimal min
  ) {
      public BigDecimal average() {
          if (count == 0) return BigDecimal.ZERO;
          return total.divide(BigDecimal.valueOf(count), 2, java.math.RoundingMode.HALF_UP);
      }
  }
