name: terraform_463_alb
initial:
  lb.tf: |
    # Load balancer resources placeholder
  security.tf: |
    # Security resources placeholder
  unrelated_project/billing/cost_report_GARBAGE_TF_alb463a.py: |
    # GARBAGE_TF_alb463a - Billing cost report generator
    class CostReportGenerator_GARBAGE_TF_alb463a:
        def generate_monthly_report(self):
            print("Generating billing report GARBAGE_TF_alb463a")
            return {"total": 12345.67, "services": ["storage", "compute"]}
  unrelated_project/analytics/visitor_tracker_GARBAGE_TF_alb463b.js: |
    // GARBAGE_TF_alb463b - Visitor tracking analytics
    const trackVisitor_GARBAGE_TF_alb463b = (userId) => {
      console.log("Tracking visitor GARBAGE_TF_alb463b", userId);
      return { timestamp: Date.now(), userId };
    };
changed:
  security.tf: |
    resource "aws_security_group" "alb" {
      name        = "${var.environment}-alb-sg"
      description = "Security group for Application Load Balancer"
      vpc_id      = var.vpc_id

      tags = merge(var.common_tags, {
        Name = "${var.environment}-alb-sg"
      })

      lifecycle {
        create_before_destroy = true
      }
    }

    resource "aws_security_group_rule" "alb_http_ingress" {
      type              = "ingress"
      from_port         = 80
      to_port           = 80
      protocol          = "tcp"
      cidr_blocks       = ["0.0.0.0/0"]
      security_group_id = aws_security_group.alb.id
      description       = "HTTP from anywhere"
    }

    resource "aws_security_group_rule" "alb_https_ingress" {
      type              = "ingress"
      from_port         = 443
      to_port           = 443
      protocol          = "tcp"
      cidr_blocks       = ["0.0.0.0/0"]
      security_group_id = aws_security_group.alb.id
      description       = "HTTPS from anywhere"
    }

    resource "aws_security_group_rule" "alb_egress" {
      type              = "egress"
      from_port         = 0
      to_port           = 0
      protocol          = "-1"
      cidr_blocks       = ["0.0.0.0/0"]
      security_group_id = aws_security_group.alb.id
      description       = "Allow all outbound"
    }
  lb.tf: |
    resource "aws_lb" "main" {
      name               = "${var.environment}-alb"
      internal           = false
      load_balancer_type = "application"
      security_groups    = [aws_security_group.alb.id]
      subnets            = var.public_subnet_ids

      enable_deletion_protection = var.environment == "prod"
      enable_http2               = true
      idle_timeout               = 60
      drop_invalid_header_fields = true

      access_logs {
        bucket  = var.alb_logs_bucket
        prefix  = "${var.environment}-alb"
        enabled = true
      }

      tags = merge(var.common_tags, {
        Name = "${var.environment}-alb"
      })
    }

    resource "aws_lb_listener" "http" {
      load_balancer_arn = aws_lb.main.arn
      port              = 80
      protocol          = "HTTP"

      default_action {
        type = "redirect"
        redirect {
          port        = "443"
          protocol    = "HTTPS"
          status_code = "HTTP_301"
        }
      }

      tags = var.common_tags
    }

    resource "aws_lb_listener" "https" {
      load_balancer_arn = aws_lb.main.arn
      port              = 443
      protocol          = "HTTPS"
      ssl_policy        = "ELBSecurityPolicy-TLS13-1-2-2021-06"
      certificate_arn   = var.certificate_arn

      default_action {
        type = "fixed-response"
        fixed_response {
          content_type = "text/plain"
          message_body = "Not Found"
          status_code  = "404"
        }
      }

      tags = var.common_tags
    }

    resource "aws_lb_listener_certificate" "additional" {
      count           = length(var.additional_certificate_arns)
      listener_arn    = aws_lb_listener.https.arn
      certificate_arn = var.additional_certificate_arns[count.index]
    }

    resource "aws_lb_target_group" "app" {
      name                 = "${var.environment}-app-tg"
      port                 = var.app_port
      protocol             = "HTTP"
      vpc_id               = var.vpc_id
      target_type          = var.target_type
      deregistration_delay = 30

      health_check {
        enabled             = true
        healthy_threshold   = 2
        unhealthy_threshold = 3
        timeout             = 5
        interval            = 30
        path                = var.health_check_path
        port                = "traffic-port"
        protocol            = "HTTP"
        matcher             = "200-299"
      }

      stickiness {
        type            = "lb_cookie"
        cookie_duration = 86400
        enabled         = var.enable_stickiness
      }

      tags = merge(var.common_tags, {
        Name = "${var.environment}-app-tg"
      })

      lifecycle {
        create_before_destroy = true
      }
    }

    resource "aws_lb_target_group" "api" {
      name                 = "${var.environment}-api-tg"
      port                 = var.api_port
      protocol             = "HTTP"
      vpc_id               = var.vpc_id
      target_type          = var.target_type
      deregistration_delay = 30

      health_check {
        enabled             = true
        healthy_threshold   = 2
        unhealthy_threshold = 3
        timeout             = 5
        interval            = 30
        path                = "/health"
        port                = "traffic-port"
        protocol            = "HTTP"
        matcher             = "200"
      }

      tags = merge(var.common_tags, {
        Name = "${var.environment}-api-tg"
      })

      lifecycle {
        create_before_destroy = true
      }
    }

    resource "aws_lb_listener_rule" "app" {
      listener_arn = aws_lb_listener.https.arn
      priority     = 100

      action {
        type             = "forward"
        target_group_arn = aws_lb_target_group.app.arn
      }

      condition {
        host_header {
          values = var.app_host_headers
        }
      }

      tags = var.common_tags
    }

    resource "aws_lb_listener_rule" "api" {
      listener_arn = aws_lb_listener.https.arn
      priority     = 200

      action {
        type             = "forward"
        target_group_arn = aws_lb_target_group.api.arn
      }

      condition {
        path_pattern {
          values = ["/api/*", "/v1/*", "/v2/*"]
        }
      }

      tags = var.common_tags
    }

    resource "aws_lb_listener_rule" "maintenance" {
      count        = var.maintenance_mode ? 1 : 0
      listener_arn = aws_lb_listener.https.arn
      priority     = 1

      action {
        type = "fixed-response"
        fixed_response {
          content_type = "text/html"
          message_body = file("${path.module}/maintenance.html")
          status_code  = "503"
        }
      }

      condition {
        path_pattern {
          values = ["/*"]
        }
      }

      tags = var.common_tags
    }

    resource "aws_wafv2_web_acl_association" "main" {
      count        = var.waf_acl_arn != "" ? 1 : 0
      resource_arn = aws_lb.main.arn
      web_acl_arn  = var.waf_acl_arn
    }
assertions:
  must_include:
    - lb.tf
    - security.tf
    - aws_lb
    - aws_lb_listener
    - aws_lb_target_group
    - aws_lb_listener_rule
    - aws_security_group
    - ELBSecurityPolicy-TLS13
    - drop_invalid_header_fields
    - aws_wafv2_web_acl_association
  must_not_include:
    - GARBAGE_TF_alb463a
    - GARBAGE_TF_alb463b
    - CostReportGenerator
    - trackVisitor
options:
  commit_message: Add ALB with TLS 1.3, listener rules, and WAF integration
