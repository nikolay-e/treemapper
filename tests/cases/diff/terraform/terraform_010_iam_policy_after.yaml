modules/iam_role/main.tf: |
  resource "aws_iam_role" "this" {
    name               = var.role_name
    assume_role_policy = var.assume_role_policy
    description        = var.description

    max_session_duration = var.max_session_duration

    tags = var.tags
  }

  resource "aws_iam_role_policy_attachment" "managed" {
    count      = length(var.managed_policy_arns)
    role       = aws_iam_role.this.name
    policy_arn = var.managed_policy_arns[count.index]
  }

  resource "aws_iam_role_policy" "inline" {
    count  = var.inline_policy != null ? 1 : 0
    name   = "${var.role_name}-inline-policy"
    role   = aws_iam_role.this.id
    policy = var.inline_policy
  }
modules/iam_role/variables.tf: |
  variable "role_name" {
    type = string
  }

  variable "assume_role_policy" {
    type = string
  }

  variable "description" {
    type    = string
    default = "Managed by Terraform"
  }

  variable "max_session_duration" {
    type    = number
    default = 3600
  }

  variable "managed_policy_arns" {
    type    = list(string)
    default = []
  }

  variable "inline_policy" {
    type    = string
    default = null
  }

  variable "tags" {
    type    = map(string)
    default = {}
  }
modules/iam_role/outputs.tf: |
  output "role_arn" {
    value = aws_iam_role.this.arn
  }

  output "role_name" {
    value = aws_iam_role.this.name
  }
infrastructure/iam.tf: |
  data "aws_iam_policy_document" "lambda_assume_role" {
    statement {
      effect  = "Allow"
      actions = ["sts:AssumeRole"]

      principals {
        type        = "Service"
        identifiers = ["lambda.amazonaws.com"]
      }
    }
  }

  module "lambda_role" {
    source             = "./modules/iam_role"
    role_name          = "lambda-exec-role-${var.environment}"
    assume_role_policy = data.aws_iam_policy_document.lambda_assume_role.json

    managed_policy_arns = [
      "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole",
      "arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole"
    ]

    inline_policy = data.aws_iam_policy_document.lambda_permissions.json

    tags = local.common_tags
  }

  data "aws_iam_policy_document" "lambda_permissions" {
    statement {
      sid    = "S3Access"
      effect = "Allow"
      actions = [
        "s3:GetObject",
        "s3:PutObject",
        "s3:DeleteObject"
      ]
      resources = [
        "${module.data_bucket.bucket_arn}/*"
      ]
    }

    statement {
      sid    = "DynamoDBAccess"
      effect = "Allow"
      actions = [
        "dynamodb:GetItem",
        "dynamodb:PutItem",
        "dynamodb:UpdateItem",
        "dynamodb:DeleteItem",
        "dynamodb:Query",
        "dynamodb:Scan"
      ]
      resources = [
        module.users_table.table_arn,
        "${module.users_table.table_arn}/index/*"
      ]
    }

    statement {
      sid    = "SQSAccess"
      effect = "Allow"
      actions = [
        "sqs:SendMessage",
        "sqs:ReceiveMessage",
        "sqs:DeleteMessage",
        "sqs:GetQueueAttributes"
      ]
      resources = [
        aws_sqs_queue.processing.arn
      ]
    }

    statement {
      sid    = "KMSDecrypt"
      effect = "Allow"
      actions = [
        "kms:Decrypt",
        "kms:GenerateDataKey"
      ]
      resources = [
        aws_kms_key.data.arn
      ]
    }
  }

  resource "aws_iam_policy" "s3_readonly" {
    name        = "s3-readonly-${var.environment}"
    description = "Read-only access to data bucket"

    policy = jsonencode({
      Version = "2012-10-17"
      Statement = [{
        Effect = "Allow"
        Action = [
          "s3:GetObject",
          "s3:ListBucket"
        ]
        Resource = [
          module.data_bucket.bucket_arn,
          "${module.data_bucket.bucket_arn}/*"
        ]
      }]
    })

    tags = local.common_tags
  }

  resource "aws_iam_role_policy_attachment" "s3_readonly" {
    role       = module.readonly_role.role_name
    policy_arn = aws_iam_policy.s3_readonly.arn
  }
unrelated/cognito.tf: |
  # GARBAGE_TF_COGNITO_450_001
  resource "aws_cognito_user_pool" "unrelated_pool" {
    name = "GARBAGE_USER_POOL_450_002"

    password_policy {
      minimum_length = 8
    }

    schema {
      name                = "GARBAGE_ATTR_450_003"
      attribute_data_type = "String"
      mutable             = true
    }
  }

  resource "aws_cognito_user_pool_client" "unrelated_client" {
    name         = "GARBAGE_CLIENT_450_004"
    user_pool_id = aws_cognito_user_pool.unrelated_pool.id
  }
unrelated/organizations.tf: |
  # GARBAGE_TF_ORG_450_005
  resource "aws_organizations_policy" "unrelated_scp" {
    name    = "GARBAGE_SCP_450_006"
    content = jsonencode({
      Version = "2012-10-17"
      Statement = [{
        Effect   = "Deny"
        Action   = ["GARBAGE_ACTION_450_007"]
        Resource = "*"
      }]
    })
  }
