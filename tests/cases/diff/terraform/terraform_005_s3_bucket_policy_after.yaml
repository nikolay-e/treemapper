modules/s3/main.tf: |
  resource "aws_s3_bucket" "this" {
    bucket = var.bucket_name
    tags   = var.tags
  }

  resource "aws_s3_bucket_policy" "this" {
    count  = var.bucket_policy != null ? 1 : 0
    bucket = aws_s3_bucket.this.id
    policy = var.bucket_policy
  }

  resource "aws_s3_bucket_cors_configuration" "this" {
    count  = length(var.cors_rules) > 0 ? 1 : 0
    bucket = aws_s3_bucket.this.id

    dynamic "cors_rule" {
      for_each = var.cors_rules
      content {
        allowed_headers = cors_rule.value.allowed_headers
        allowed_methods = cors_rule.value.allowed_methods
        allowed_origins = cors_rule.value.allowed_origins
        expose_headers  = cors_rule.value.expose_headers
        max_age_seconds = cors_rule.value.max_age_seconds
      }
    }
  }

  resource "aws_s3_bucket_logging" "this" {
    count         = var.logging_bucket != null ? 1 : 0
    bucket        = aws_s3_bucket.this.id
    target_bucket = var.logging_bucket
    target_prefix = var.logging_prefix
  }
modules/s3/variables.tf: |
  variable "bucket_name" {
    type = string
  }

  variable "bucket_policy" {
    type    = string
    default = null
  }

  variable "cors_rules" {
    type    = list(any)
    default = []
  }

  variable "logging_bucket" {
    type    = string
    default = null
  }

  variable "logging_prefix" {
    type    = string
    default = "logs/"
  }

  variable "tags" {
    type    = map(string)
    default = {}
  }
modules/s3/outputs.tf: |
  output "bucket_id" {
    value = aws_s3_bucket.this.id
  }

  output "bucket_arn" {
    value = aws_s3_bucket.this.arn
  }
infrastructure/static_site.tf: |
  module "static_site" {
    source      = "./modules/s3"
    bucket_name = "myapp-static-${var.environment}"

    bucket_policy = data.aws_iam_policy_document.static_site_combined.json

    cors_rules = [
      {
        allowed_headers = ["*"]
        allowed_methods = ["GET", "HEAD"]
        allowed_origins = ["https://example.com", "https://app.example.com"]
        expose_headers  = ["ETag", "Content-Length"]
        max_age_seconds = 86400
      }
    ]

    logging_bucket = module.logs_bucket.bucket_id
    logging_prefix = "static-site-access/"

    tags = local.common_tags
  }

  data "aws_iam_policy_document" "static_site_combined" {
    source_policy_documents = [
      data.aws_iam_policy_document.cloudfront_access.json,
      data.aws_iam_policy_document.ssl_only.json
    ]
  }

  data "aws_iam_policy_document" "cloudfront_access" {
    statement {
      sid       = "AllowCloudFrontAccess"
      effect    = "Allow"
      actions   = ["s3:GetObject"]
      resources = ["${module.static_site.bucket_arn}/*"]

      principals {
        type        = "Service"
        identifiers = ["cloudfront.amazonaws.com"]
      }

      condition {
        test     = "StringEquals"
        variable = "AWS:SourceArn"
        values   = [aws_cloudfront_distribution.main.arn]
      }
    }
  }

  data "aws_iam_policy_document" "ssl_only" {
    statement {
      sid       = "DenyNonSSL"
      effect    = "Deny"
      actions   = ["s3:*"]
      resources = [
        module.static_site.bucket_arn,
        "${module.static_site.bucket_arn}/*"
      ]

      principals {
        type        = "*"
        identifiers = ["*"]
      }

      condition {
        test     = "Bool"
        variable = "aws:SecureTransport"
        values   = ["false"]
      }
    }
  }
unrelated/msk.tf: |
  # GARBAGE_TF_MSK_445_001
  resource "aws_msk_cluster" "unrelated_kafka" {
    cluster_name           = "GARBAGE_MSK_CLUSTER_445_002"
    kafka_version          = "3.4.0"
    number_of_broker_nodes = 3

    broker_node_group_info {
      instance_type   = "kafka.m5.large"
      client_subnets  = ["subnet-GARBAGE_445_003", "subnet-GARBAGE_445_004", "subnet-GARBAGE_445_005"]
      security_groups = ["sg-GARBAGE_445_006"]

      storage_info {
        ebs_storage_info {
          volume_size = 100
        }
      }
    }
  }
unrelated/kinesis.tf: |
  # GARBAGE_TF_KINESIS_445_007
  resource "aws_kinesis_stream" "unrelated_stream" {
    name             = "GARBAGE_KINESIS_STREAM_445_008"
    shard_count      = 1
    retention_period = 24

    stream_mode_details {
      stream_mode = "PROVISIONED"
    }
  }

  resource "aws_kinesis_firehose_delivery_stream" "unrelated_firehose" {
    name        = "GARBAGE_FIREHOSE_445_009"
    destination = "extended_s3"

    extended_s3_configuration {
      role_arn   = "arn:aws:iam::123456789:role/GARBAGE_FIREHOSE_ROLE_445_010"
      bucket_arn = "arn:aws:s3:::GARBAGE_FIREHOSE_BUCKET_445_011"
    }
  }
