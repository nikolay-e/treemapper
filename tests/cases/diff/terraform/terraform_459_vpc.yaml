name: terraform_459_vpc
initial:
  network.tf: |
    # Network resources placeholder
  outputs.tf: |
    # Outputs placeholder
  deprecated/legacy_network_GARBAGE_TF_vpc459a.tf: |
    # GARBAGE_TF_vpc459a - Legacy VPC configuration
    resource "aws_vpc" "legacy_GARBAGE_TF_vpc459a" {
      cidr_block = "172.16.0.0/16"
      tags = {
        Name = "legacy-vpc-GARBAGE_TF_vpc459a"
      }
    }

    resource "aws_subnet" "legacy_public_GARBAGE_TF_vpc459a" {
      vpc_id     = aws_vpc.legacy_GARBAGE_TF_vpc459a.id
      cidr_block = "172.16.1.0/24"
    }
  docs/network_diagram_GARBAGE_TF_vpc459b.md: |
    # Legacy Network GARBAGE_TF_vpc459b
    Old network architecture documentation GARBAGE_TF_vpc459b
changed:
  network.tf: |
    data "aws_availability_zones" "available" {
      state = "available"
      filter {
        name   = "opt-in-status"
        values = ["opt-in-not-required"]
      }
    }

    locals {
      azs = slice(data.aws_availability_zones.available.names, 0, var.az_count)

      public_subnets = [
        for i, az in local.azs : cidrsubnet(var.vpc_cidr, 8, i)
      ]

      private_subnets = [
        for i, az in local.azs : cidrsubnet(var.vpc_cidr, 8, i + 100)
      ]

      database_subnets = [
        for i, az in local.azs : cidrsubnet(var.vpc_cidr, 8, i + 200)
      ]
    }

    resource "aws_vpc" "main" {
      cidr_block           = var.vpc_cidr
      enable_dns_hostnames = true
      enable_dns_support   = true
      instance_tenancy     = "default"

      tags = merge(var.common_tags, {
        Name = "${var.environment}-vpc"
      })
    }

    resource "aws_internet_gateway" "main" {
      vpc_id = aws_vpc.main.id

      tags = merge(var.common_tags, {
        Name = "${var.environment}-igw"
      })
    }

    resource "aws_subnet" "public" {
      count                   = length(local.public_subnets)
      vpc_id                  = aws_vpc.main.id
      cidr_block              = local.public_subnets[count.index]
      availability_zone       = local.azs[count.index]
      map_public_ip_on_launch = true

      tags = merge(var.common_tags, {
        Name                     = "${var.environment}-public-${local.azs[count.index]}"
        "kubernetes.io/role/elb" = "1"
        Tier                     = "public"
      })
    }

    resource "aws_subnet" "private" {
      count             = length(local.private_subnets)
      vpc_id            = aws_vpc.main.id
      cidr_block        = local.private_subnets[count.index]
      availability_zone = local.azs[count.index]

      tags = merge(var.common_tags, {
        Name                              = "${var.environment}-private-${local.azs[count.index]}"
        "kubernetes.io/role/internal-elb" = "1"
        Tier                              = "private"
      })
    }

    resource "aws_subnet" "database" {
      count             = length(local.database_subnets)
      vpc_id            = aws_vpc.main.id
      cidr_block        = local.database_subnets[count.index]
      availability_zone = local.azs[count.index]

      tags = merge(var.common_tags, {
        Name = "${var.environment}-database-${local.azs[count.index]}"
        Tier = "database"
      })
    }

    resource "aws_eip" "nat" {
      count  = var.single_nat_gateway ? 1 : length(local.azs)
      domain = "vpc"

      tags = merge(var.common_tags, {
        Name = "${var.environment}-nat-eip-${count.index + 1}"
      })

      depends_on = [aws_internet_gateway.main]
    }

    resource "aws_nat_gateway" "main" {
      count         = var.single_nat_gateway ? 1 : length(local.azs)
      allocation_id = aws_eip.nat[count.index].id
      subnet_id     = aws_subnet.public[count.index].id

      tags = merge(var.common_tags, {
        Name = "${var.environment}-nat-${count.index + 1}"
      })

      depends_on = [aws_internet_gateway.main]
    }

    resource "aws_route_table" "public" {
      vpc_id = aws_vpc.main.id

      route {
        cidr_block = "0.0.0.0/0"
        gateway_id = aws_internet_gateway.main.id
      }

      tags = merge(var.common_tags, {
        Name = "${var.environment}-public-rt"
      })
    }

    resource "aws_route_table" "private" {
      count  = var.single_nat_gateway ? 1 : length(local.azs)
      vpc_id = aws_vpc.main.id

      route {
        cidr_block     = "0.0.0.0/0"
        nat_gateway_id = aws_nat_gateway.main[var.single_nat_gateway ? 0 : count.index].id
      }

      tags = merge(var.common_tags, {
        Name = "${var.environment}-private-rt-${count.index + 1}"
      })
    }

    resource "aws_route_table_association" "public" {
      count          = length(local.public_subnets)
      subnet_id      = aws_subnet.public[count.index].id
      route_table_id = aws_route_table.public.id
    }

    resource "aws_route_table_association" "private" {
      count          = length(local.private_subnets)
      subnet_id      = aws_subnet.private[count.index].id
      route_table_id = aws_route_table.private[var.single_nat_gateway ? 0 : count.index].id
    }

    resource "aws_route_table_association" "database" {
      count          = length(local.database_subnets)
      subnet_id      = aws_subnet.database[count.index].id
      route_table_id = aws_route_table.private[var.single_nat_gateway ? 0 : count.index].id
    }

    resource "aws_vpc_endpoint" "s3" {
      vpc_id            = aws_vpc.main.id
      service_name      = "com.amazonaws.${var.aws_region}.s3"
      vpc_endpoint_type = "Gateway"
      route_table_ids   = concat([aws_route_table.public.id], aws_route_table.private[*].id)

      tags = merge(var.common_tags, {
        Name = "${var.environment}-s3-endpoint"
      })
    }

    resource "aws_vpc_endpoint" "dynamodb" {
      vpc_id            = aws_vpc.main.id
      service_name      = "com.amazonaws.${var.aws_region}.dynamodb"
      vpc_endpoint_type = "Gateway"
      route_table_ids   = aws_route_table.private[*].id

      tags = merge(var.common_tags, {
        Name = "${var.environment}-dynamodb-endpoint"
      })
    }

    resource "aws_flow_log" "main" {
      iam_role_arn    = aws_iam_role.vpc_flow_log.arn
      log_destination = aws_cloudwatch_log_group.vpc_flow_log.arn
      traffic_type    = "ALL"
      vpc_id          = aws_vpc.main.id

      tags = merge(var.common_tags, {
        Name = "${var.environment}-vpc-flow-log"
      })
    }

    resource "aws_cloudwatch_log_group" "vpc_flow_log" {
      name              = "/aws/vpc/${var.environment}-flow-logs"
      retention_in_days = var.flow_log_retention_days

      tags = var.common_tags
    }

    resource "aws_iam_role" "vpc_flow_log" {
      name = "${var.environment}-vpc-flow-log-role"

      assume_role_policy = jsonencode({
        Version = "2012-10-17"
        Statement = [{
          Effect    = "Allow"
          Principal = { Service = "vpc-flow-logs.amazonaws.com" }
          Action    = "sts:AssumeRole"
        }]
      })

      tags = var.common_tags
    }

    resource "aws_iam_role_policy" "vpc_flow_log" {
      name = "${var.environment}-vpc-flow-log-policy"
      role = aws_iam_role.vpc_flow_log.id

      policy = jsonencode({
        Version = "2012-10-17"
        Statement = [{
          Effect = "Allow"
          Action = [
            "logs:CreateLogGroup",
            "logs:CreateLogStream",
            "logs:PutLogEvents",
            "logs:DescribeLogGroups",
            "logs:DescribeLogStreams"
          ]
          Resource = "*"
        }]
      })
    }
  outputs.tf: |
    output "vpc_id" {
      description = "VPC ID"
      value       = aws_vpc.main.id
    }

    output "vpc_cidr_block" {
      description = "VPC CIDR block"
      value       = aws_vpc.main.cidr_block
    }

    output "public_subnet_ids" {
      description = "List of public subnet IDs"
      value       = aws_subnet.public[*].id
    }

    output "private_subnet_ids" {
      description = "List of private subnet IDs"
      value       = aws_subnet.private[*].id
    }

    output "database_subnet_ids" {
      description = "List of database subnet IDs"
      value       = aws_subnet.database[*].id
    }

    output "nat_gateway_ids" {
      description = "List of NAT Gateway IDs"
      value       = aws_nat_gateway.main[*].id
    }

    output "availability_zones" {
      description = "List of availability zones used"
      value       = local.azs
    }
assertions:
  must_include:
    - network.tf
    - aws_vpc
    - aws_subnet
    - aws_nat_gateway
    - aws_internet_gateway
    - aws_route_table
    - aws_vpc_endpoint
    - aws_flow_log
    - kubernetes.io/role/elb
  must_not_include:
    - GARBAGE_TF_vpc459a
    - GARBAGE_TF_vpc459b
    - legacy-vpc
    - legacy_public
options:
  commit_message: Add VPC with multi-AZ subnets, NAT gateways, and VPC endpoints
