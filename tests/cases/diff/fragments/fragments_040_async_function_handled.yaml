name: fragments_040_async_function_handled
initial:
  src/async_code.py: |
    import asyncio
    from typing import Awaitable, Coroutine, Optional, List, Dict, Any
    from dataclasses import dataclass
    from enum import Enum
    import logging

    logger = logging.getLogger(__name__)

    class TaskState(Enum):
        PENDING = "pending"
        RUNNING = "running"
        COMPLETED = "completed"
        FAILED = "failed"
        CANCELLED = "cancelled"

    @dataclass
    class TaskResult:
        task_id: str
        state: TaskState
        result: Any = None
        error: Optional[str] = None

    ASYNC_CONSTANT = "GARBAGE_FRAG_040_asyncconst"
    TIMEOUT_DEFAULT = 30.0

    def sync_function_before():
        items = [x * 2 for x in range(10)]
        mapping = {str(i): v for i, v in enumerate(items)}
        return f"GARBAGE_FRAG_040_syncbefore: {sum(items)}"

    async def unrelated_async_before():
        await asyncio.sleep(0)
        data = {"status": "GARBAGE_FRAG_040_asyncbefore"}
        return data

    async def unrelated_fetch_data():
        await asyncio.sleep(0.1)
        return {"data": "GARBAGE_FRAG_040_fetchdata", "count": 42}

    class UnrelatedAsyncClass:
        MARKER = "GARBAGE_FRAG_040_asyncclass"
        DEFAULT_TIMEOUT = 10.0

        def __init__(self, timeout: float = DEFAULT_TIMEOUT):
            self._timeout = timeout
            self._results: List[TaskResult] = []
            self._active_tasks: Dict[str, asyncio.Task] = {}

        async def async_method(self):
            await asyncio.sleep(0)
            return f"GARBAGE_FRAG_040_asyncmethod: {self._timeout}"

        async def process_batch(self, items: List[str]) -> List[str]:
            results = []
            for item in items:
                await asyncio.sleep(0)
                results.append(f"GARBAGE_FRAG_040_batch: {item}")
            return results

        def get_results(self) -> List[TaskResult]:
            return self._results.copy()

    async def async_handler():
        await something()
        return result

    async def unrelated_async_after():
        await asyncio.sleep(1)
        calculations = [i ** 2 for i in range(5)]
        return f"GARBAGE_FRAG_040_asyncafter: {sum(calculations)}"

    def sync_function_after():
        data = {"key": "GARBAGE_FRAG_040_syncafter"}
        return data

    class AnotherAsyncClass:
        VALUE = "GARBAGE_FRAG_040_anotherasyncclass"

        def __init__(self):
            self._queue: asyncio.Queue = asyncio.Queue()
            self._processing = False

        async def another_async_method(self):
            await asyncio.sleep(0)
            return f"GARBAGE_FRAG_040_anothermethod: {self._processing}"

        async def enqueue_task(self, task_data: Dict) -> str:
            task_id = f"task_{id(task_data)}"
            await self._queue.put((task_id, task_data))
            return task_id

        async def process_queue(self) -> List[str]:
            self._processing = True
            results = []
            while not self._queue.empty():
                task_id, data = await self._queue.get()
                results.append(f"GARBAGE_FRAG_040_processed: {task_id}")
            self._processing = False
            return results

    async def utility_coroutine_alpha():
        await asyncio.sleep(0)
        return "GARBAGE_FRAG_040_utilityalpha"

    async def utility_coroutine_beta():
        results = await asyncio.gather(
            asyncio.sleep(0),
            asyncio.sleep(0)
        )
        return f"GARBAGE_FRAG_040_utilitybeta: {len(results)}"

    TRAILING_ASYNC_CONST = "GARBAGE_FRAG_040_trailing"

  unrelated/async_queue.py: |
    import asyncio
    from typing import Generic, TypeVar, Optional, List
    from dataclasses import dataclass
    from enum import Enum

    T = TypeVar('T')

    class QueueState(Enum):
        EMPTY = "empty"
        READY = "ready"
        PROCESSING = "processing"

    @dataclass
    class QueueItem(Generic[T]):
        data: T
        priority: int = 0
        timestamp: float = 0.0

    class AsyncPriorityQueue(Generic[T]):
        GARBAGE_FRAG_040_001 = "async_queue_marker"

        def __init__(self, max_size: int = 100):
            self._queue: asyncio.PriorityQueue = asyncio.PriorityQueue(maxsize=max_size)
            self._processed_count = 0
            self._state = QueueState.EMPTY

        async def enqueue(self, item: T, priority: int = 0) -> None:
            queue_item = QueueItem(data=item, priority=priority)
            await self._queue.put((priority, queue_item))
            self._state = QueueState.READY

        async def dequeue(self) -> Optional[T]:
            if self._queue.empty():
                self._state = QueueState.EMPTY
                return None
            self._state = QueueState.PROCESSING
            _, item = await self._queue.get()
            self._processed_count += 1
            return item.data

        async def process_all(self) -> List[T]:
            results = []
            while not self._queue.empty():
                item = await self.dequeue()
                if item:
                    results.append(item)
            return results

        def get_stats(self) -> dict:
            return {
                "GARBAGE_FRAG_040_002": self._processed_count,
                "state": self._state.value,
                "size": self._queue.qsize()
            }

    QUEUE_MARKERS = ["GARBAGE_FRAG_040_003", "GARBAGE_FRAG_040_004"]

  unrelated/async_pool.py: |
    import asyncio
    from typing import Callable, Awaitable, List, Dict, Any, Optional
    from dataclasses import dataclass
    from contextlib import asynccontextmanager

    @dataclass
    class WorkerStats:
        completed: int = 0
        failed: int = 0
        average_time: float = 0.0

    class AsyncWorkerPool:
        GARBAGE_FRAG_040_005 = "worker_pool_marker"

        def __init__(self, num_workers: int = 4):
            self._num_workers = num_workers
            self._tasks: asyncio.Queue = asyncio.Queue()
            self._workers: List[asyncio.Task] = []
            self._stats = WorkerStats()
            self._running = False

        async def start(self) -> None:
            self._running = True
            for i in range(self._num_workers):
                worker = asyncio.create_task(self._worker_loop(i))
                self._workers.append(worker)

        async def _worker_loop(self, worker_id: int) -> None:
            while self._running:
                try:
                    task = await asyncio.wait_for(self._tasks.get(), timeout=1.0)
                    await task()
                    self._stats.completed += 1
                except asyncio.TimeoutError:
                    continue
                except Exception:
                    self._stats.failed += 1

        async def submit(self, task: Callable[[], Awaitable[Any]]) -> None:
            await self._tasks.put(task)

        async def stop(self) -> None:
            self._running = False
            for worker in self._workers:
                worker.cancel()
            await asyncio.gather(*self._workers, return_exceptions=True)

        def get_stats(self) -> Dict[str, Any]:
            return {
                "GARBAGE_FRAG_040_006": self._stats.completed,
                "failed": self._stats.failed,
                "workers": self._num_workers
            }

    @asynccontextmanager
    async def managed_pool(num_workers: int = 4):
        pool = AsyncWorkerPool(num_workers)
        await pool.start()
        try:
            yield pool
        finally:
            await pool.stop()

    POOL_MARKERS = ["GARBAGE_FRAG_040_007", "GARBAGE_FRAG_040_008"]

  unrelated/async_retry.py: |
    import asyncio
    from typing import TypeVar, Callable, Awaitable, Optional
    from functools import wraps
    from dataclasses import dataclass

    T = TypeVar('T')

    @dataclass
    class RetryConfig:
        max_attempts: int = 3
        base_delay: float = 1.0
        max_delay: float = 60.0
        exponential: bool = True

    class RetryHandler:
        GARBAGE_FRAG_040_009 = "retry_handler_marker"

        def __init__(self, config: Optional[RetryConfig] = None):
            self._config = config or RetryConfig()
            self._attempt_count = 0
            self._last_error: Optional[Exception] = None

        async def execute(self, func: Callable[[], Awaitable[T]]) -> T:
            for attempt in range(self._config.max_attempts):
                self._attempt_count = attempt + 1
                try:
                    return await func()
                except Exception as e:
                    self._last_error = e
                    if attempt < self._config.max_attempts - 1:
                        delay = self._calculate_delay(attempt)
                        await asyncio.sleep(delay)
            raise self._last_error

        def _calculate_delay(self, attempt: int) -> float:
            if self._config.exponential:
                delay = self._config.base_delay * (2 ** attempt)
            else:
                delay = self._config.base_delay
            return min(delay, self._config.max_delay)

        def get_attempt_info(self) -> dict:
            return {
                "GARBAGE_FRAG_040_010": self._attempt_count,
                "max": self._config.max_attempts,
                "error": str(self._last_error) if self._last_error else None
            }

    def async_retry(max_attempts: int = 3):
        def decorator(func: Callable[..., Awaitable[T]]) -> Callable[..., Awaitable[T]]:
            @wraps(func)
            async def wrapper(*args, **kwargs) -> T:
                handler = RetryHandler(RetryConfig(max_attempts=max_attempts))
                return await handler.execute(lambda: func(*args, **kwargs))
            return wrapper
        return decorator

    RETRY_MARKERS = ["GARBAGE_FRAG_040_011", "GARBAGE_FRAG_040_012", "GARBAGE_FRAG_040_013"]

changed:
  src/async_code.py: |
    import asyncio
    from typing import Awaitable, Coroutine, Optional, List, Dict, Any
    from dataclasses import dataclass
    from enum import Enum
    import logging

    logger = logging.getLogger(__name__)

    class TaskState(Enum):
        PENDING = "pending"
        RUNNING = "running"
        COMPLETED = "completed"
        FAILED = "failed"
        CANCELLED = "cancelled"

    @dataclass
    class TaskResult:
        task_id: str
        state: TaskState
        result: Any = None
        error: Optional[str] = None

    ASYNC_CONSTANT = "GARBAGE_FRAG_040_asyncconst"
    TIMEOUT_DEFAULT = 30.0

    def sync_function_before():
        items = [x * 2 for x in range(10)]
        mapping = {str(i): v for i, v in enumerate(items)}
        return f"GARBAGE_FRAG_040_syncbefore: {sum(items)}"

    async def unrelated_async_before():
        await asyncio.sleep(0)
        data = {"status": "GARBAGE_FRAG_040_asyncbefore"}
        return data

    async def unrelated_fetch_data():
        await asyncio.sleep(0.1)
        return {"data": "GARBAGE_FRAG_040_fetchdata", "count": 42}

    class UnrelatedAsyncClass:
        MARKER = "GARBAGE_FRAG_040_asyncclass"
        DEFAULT_TIMEOUT = 10.0

        def __init__(self, timeout: float = DEFAULT_TIMEOUT):
            self._timeout = timeout
            self._results: List[TaskResult] = []
            self._active_tasks: Dict[str, asyncio.Task] = {}

        async def async_method(self):
            await asyncio.sleep(0)
            return f"GARBAGE_FRAG_040_asyncmethod: {self._timeout}"

        async def process_batch(self, items: List[str]) -> List[str]:
            results = []
            for item in items:
                await asyncio.sleep(0)
                results.append(f"GARBAGE_FRAG_040_batch: {item}")
            return results

        def get_results(self) -> List[TaskResult]:
            return self._results.copy()

    async def async_handler():
        await something()
        return modified_result

    async def unrelated_async_after():
        await asyncio.sleep(1)
        calculations = [i ** 2 for i in range(5)]
        return f"GARBAGE_FRAG_040_asyncafter: {sum(calculations)}"

    def sync_function_after():
        data = {"key": "GARBAGE_FRAG_040_syncafter"}
        return data

    class AnotherAsyncClass:
        VALUE = "GARBAGE_FRAG_040_anotherasyncclass"

        def __init__(self):
            self._queue: asyncio.Queue = asyncio.Queue()
            self._processing = False

        async def another_async_method(self):
            await asyncio.sleep(0)
            return f"GARBAGE_FRAG_040_anothermethod: {self._processing}"

        async def enqueue_task(self, task_data: Dict) -> str:
            task_id = f"task_{id(task_data)}"
            await self._queue.put((task_id, task_data))
            return task_id

        async def process_queue(self) -> List[str]:
            self._processing = True
            results = []
            while not self._queue.empty():
                task_id, data = await self._queue.get()
                results.append(f"GARBAGE_FRAG_040_processed: {task_id}")
            self._processing = False
            return results

    async def utility_coroutine_alpha():
        await asyncio.sleep(0)
        return "GARBAGE_FRAG_040_utilityalpha"

    async def utility_coroutine_beta():
        results = await asyncio.gather(
            asyncio.sleep(0),
            asyncio.sleep(0)
        )
        return f"GARBAGE_FRAG_040_utilitybeta: {len(results)}"

    TRAILING_ASYNC_CONST = "GARBAGE_FRAG_040_trailing"

assertions:
  must_include:
    - async def
    - async_handler
    - modified_result
  must_not_include:
    - GARBAGE_FRAG_040_asyncconst
    - GARBAGE_FRAG_040_syncbefore
    - GARBAGE_FRAG_040_asyncbefore
    - GARBAGE_FRAG_040_fetchdata
    - GARBAGE_FRAG_040_asyncclass
    - GARBAGE_FRAG_040_asyncmethod
    - GARBAGE_FRAG_040_batch
    - GARBAGE_FRAG_040_asyncafter
    - GARBAGE_FRAG_040_syncafter
    - GARBAGE_FRAG_040_anotherasyncclass
    - GARBAGE_FRAG_040_anothermethod
    - GARBAGE_FRAG_040_processed
    - GARBAGE_FRAG_040_utilityalpha
    - GARBAGE_FRAG_040_utilitybeta
    - GARBAGE_FRAG_040_trailing
    - GARBAGE_FRAG_040_001
    - GARBAGE_FRAG_040_002
    - GARBAGE_FRAG_040_003
    - GARBAGE_FRAG_040_004
    - GARBAGE_FRAG_040_005
    - GARBAGE_FRAG_040_006
    - GARBAGE_FRAG_040_007
    - GARBAGE_FRAG_040_008
    - GARBAGE_FRAG_040_009
    - GARBAGE_FRAG_040_010
    - GARBAGE_FRAG_040_011
    - GARBAGE_FRAG_040_012
    - GARBAGE_FRAG_040_013
    - sync_function_before
    - unrelated_async_before
    - unrelated_fetch_data
    - UnrelatedAsyncClass
    - unrelated_async_after
    - sync_function_after
    - AnotherAsyncClass
    - utility_coroutine_alpha
    - utility_coroutine_beta
    - AsyncPriorityQueue
    - AsyncWorkerPool
    - RetryHandler
    - async_queue.py
    - async_pool.py
    - async_retry.py
options:
  commit_message: Modify async function return value
