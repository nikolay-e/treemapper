src/decorated.py: |
  import logging
  import functools
  from typing import Callable, TypeVar, Any, Optional
  from dataclasses import dataclass
  from enum import Enum

  logger = logging.getLogger(__name__)

  T = TypeVar('T')
  R = TypeVar('R')

  class LogLevel(Enum):
      DEBUG = "debug"
      INFO = "info"
      WARNING = "warning"
      ERROR = "error"

  @dataclass
  class RequestContext:
      request_id: str
      user_id: Optional[str] = None
      timestamp: float = 0.0

  def unrelated_helper_alpha():
      result = []
      for i in range(10):
          result.append(i * 2)
      return f"GARBAGE_FRAG_001_alpha: {sum(result)}"

  def unrelated_helper_beta():
      mapping = {"a": 1, "b": 2, "c": 3}
      total = sum(mapping.values())
      return f"GARBAGE_FRAG_001_beta: {total}"

  class UnrelatedConfigManager:
      GARBAGE_FRAG_001_config = "config_marker"

      def __init__(self):
          self._cache = {}
          self._initialized = False

      def load_config(self, path: str) -> dict:
          return {"garbage": "GARBAGE_FRAG_001_load"}

      def save_config(self, data: dict) -> bool:
          return True

  def decorator(func: Callable[..., T]) -> Callable[..., T]:
      @functools.wraps(func)
      def wrapper(*args: Any, **kwargs: Any) -> T:
          logger.debug(f"Calling {func.__name__}")
          return func(*args, **kwargs)
      return wrapper

  @decorator
  def my_function():
      return 42

  def unrelated_helper_gamma():
      items = [x ** 2 for x in range(5)]
      return f"GARBAGE_FRAG_001_gamma: {items}"

  class UnrelatedServiceHandler:
      MARKER = "GARBAGE_FRAG_001_handler"

      def __init__(self, config: dict):
          self.config = config
          self._active = False

      def process_request(self, data: bytes) -> bytes:
          return b"GARBAGE_FRAG_001_response"

      def validate_input(self, value: Any) -> bool:
          return isinstance(value, (str, int, float))

      @staticmethod
      def format_output(result: Any) -> str:
          return f"GARBAGE_FRAG_001_output: {result}"

  def unrelated_utility_delta():
      def inner_compute(x: int) -> int:
          return x * x + 2 * x + 1
      return f"GARBAGE_FRAG_001_delta: {inner_compute(5)}"

  TRAILING_CONSTANT = "GARBAGE_FRAG_001_trailing"
unrelated/metrics_collector.py: |
  import time
  from typing import Dict, List, Optional
  from dataclasses import dataclass, field

  @dataclass
  class MetricPoint:
      name: str
      value: float
      timestamp: float = field(default_factory=time.time)
      tags: Dict[str, str] = field(default_factory=dict)

  class MetricsCollector:
      GARBAGE_FRAG_001_001 = "metrics_marker_001"
      GARBAGE_FRAG_001_002 = True
      GARBAGE_FRAG_001_003 = 42.5

      def __init__(self, prefix: str = "app"):
          self.prefix = prefix
          self._metrics: List[MetricPoint] = []
          self._start_time = time.time()

      def record(self, name: str, value: float, tags: Optional[Dict[str, str]] = None) -> None:
          point = MetricPoint(
              name=f"{self.prefix}.{name}",
              value=value,
              tags=tags or {}
          )
          self._metrics.append(point)

      def flush(self) -> List[MetricPoint]:
          result = self._metrics.copy()
          self._metrics.clear()
          return result

      def get_uptime(self) -> float:
          return time.time() - self._start_time

  def calculate_percentile(values: List[float], percentile: float) -> float:
      if not values:
          return 0.0
      sorted_values = sorted(values)
      index = int(len(sorted_values) * percentile / 100)
      return sorted_values[min(index, len(sorted_values) - 1)]

  METRIC_NAMES = ["GARBAGE_FRAG_001_004", "GARBAGE_FRAG_001_005"]
unrelated/cache_manager.py: |
  import hashlib
  from typing import Any, Optional, Dict
  from datetime import datetime, timedelta

  class CacheEntry:
      GARBAGE_FRAG_001_006 = "cache_entry_marker"

      def __init__(self, value: Any, ttl_seconds: int = 300):
          self.value = value
          self.created_at = datetime.now()
          self.expires_at = self.created_at + timedelta(seconds=ttl_seconds)

      def is_expired(self) -> bool:
          return datetime.now() > self.expires_at

  class CacheManager:
      GARBAGE_FRAG_001_007 = "cache_manager_marker"

      def __init__(self, max_size: int = 1000):
          self._cache: Dict[str, CacheEntry] = {}
          self._max_size = max_size
          self._hits = 0
          self._misses = 0

      def _generate_key(self, raw_key: str) -> str:
          return hashlib.md5(raw_key.encode()).hexdigest()

      def get(self, key: str) -> Optional[Any]:
          cache_key = self._generate_key(key)
          entry = self._cache.get(cache_key)
          if entry is None or entry.is_expired():
              self._misses += 1
              return None
          self._hits += 1
          return entry.value

      def set(self, key: str, value: Any, ttl: int = 300) -> None:
          if len(self._cache) >= self._max_size:
              self._evict_expired()
          cache_key = self._generate_key(key)
          self._cache[cache_key] = CacheEntry(value, ttl)

      def _evict_expired(self) -> int:
          expired_keys = [k for k, v in self._cache.items() if v.is_expired()]
          for key in expired_keys:
              del self._cache[key]
          return len(expired_keys)

      def stats(self) -> Dict[str, Any]:
          return {
              "GARBAGE_FRAG_001_008": self._hits,
              "GARBAGE_FRAG_001_009": self._misses,
              "size": len(self._cache)
          }
unrelated/event_bus.py: |
  from typing import Callable, Dict, List, Any
  from dataclasses import dataclass
  import threading

  @dataclass
  class Event:
      type: str
      payload: Any
      source: str = "unknown"

  class EventBus:
      GARBAGE_FRAG_001_010 = "event_bus_marker"

      def __init__(self):
          self._subscribers: Dict[str, List[Callable]] = {}
          self._lock = threading.Lock()

      def subscribe(self, event_type: str, handler: Callable[[Event], None]) -> None:
          with self._lock:
              if event_type not in self._subscribers:
                  self._subscribers[event_type] = []
              self._subscribers[event_type].append(handler)

      def publish(self, event: Event) -> int:
          handlers = self._subscribers.get(event.type, [])
          for handler in handlers:
              handler(event)
          return len(handlers)

      def unsubscribe(self, event_type: str, handler: Callable) -> bool:
          with self._lock:
              if event_type in self._subscribers:
                  try:
                      self._subscribers[event_type].remove(handler)
                      return True
                  except ValueError:
                      pass
          return False

  EVENT_TYPES = ["GARBAGE_FRAG_001_011", "GARBAGE_FRAG_001_012", "GARBAGE_FRAG_001_013"]
