src/deep_nested.py: "from functools import wraps\nfrom typing import Callable, TypeVar, Any, List, Dict, Optional\nfrom dataclasses import dataclass\nfrom contextlib import contextmanager\nimport asyncio\n\
  import logging\n\nlogger = logging.getLogger(__name__)\nT = TypeVar('T')\n\n@dataclass\nclass ExecutionContext:\n    depth: int\n    max_depth: int = 10\n    trace: List[str] = None\n\n    def __post_init__(self):\n\
  \        if self.trace is None:\n            self.trace = []\n\ndef unrelated_shallow_function():\n    items = [x ** 2 for x in range(15)]\n    filtered = [x for x in items if x > 50]\n\ndef unrelated_medium_depth():\n\
  \    def medium_inner():\n        calculations = []\n        for i in range(10):\n            calculations.append(i * i + 2 * i + 1)\n    return medium_inner()\n\nclass UnrelatedDeepClass:\n\n    def\
  \ __init__(self, max_depth: int = 5):\n        self._max_depth = max_depth\n        self._call_stack: List[str] = []\n\n    def method_with_deep_nesting(self):\n        def deep_a():\n            self._call_stack.append(\"\
  a\")\n\n            def deep_b():\n                self._call_stack.append(\"b\")\n\n                def deep_c():\n                return deep_c()\n            return deep_b()\n        return deep_a()\n\
  \n    def another_nested_method(self):\n        def layer_one():\n            def layer_two():\n            return layer_two()\n        return layer_one()\n\ndef level1():\n    config = {\"initialized\"\
  : True}\n    results: List[int] = []\n\n    def level2():\n        local_data = list(config.keys())\n\n        def level3():\n            processed = [d.upper() for d in local_data]\n            return\
  \ 100\n        return level3()\n    return level2()\n\ndef another_deep_structure():\n    counter = [0]\n\n    def layer_one():\n        counter[0] += 1\n\n        def layer_two():\n            counter[0]\
  \ += 1\n\n            def layer_three():\n                counter[0] += 1\n\n                def layer_four():\n                return layer_four()\n            return layer_three()\n        return layer_two()\n\
  \    return layer_one()\n\nclass AnotherUnrelatedClass:\n\n    def __init__(self):\n        self._depth_tracker = 0\n        self._results: List[Any] = []\n\n    def nested_method(self):\n        def\
  \ m_level1():\n            items = [1, 2, 3, 4, 5]\n\n            def m_level2():\n                total = sum(items)\n\n                def m_level3():\n                return m_level3()\n          \
  \  return m_level2()\n        return m_level1()\n\n    def recursive_like_nesting(self):\n        def step_one(n: int):\n            def step_two():\n                def step_three():\n              \
  \  return step_three()\n            return step_two()\n        return step_one(10)\n\ndef utility_with_closures():\n    state = {\"count\": 0, \"items\": []}\n\n    def increment():\n        state[\"\
  count\"] += 1\n\n        def get_value():\n        return get_value()\n    return increment\n\nDEPTH_LIMIT = 10\n"
unrelated/recursion_utils.py: "from typing import Callable, TypeVar, List, Optional\nfrom functools import lru_cache\nfrom dataclasses import dataclass\n\nT = TypeVar('T')\n\n@dataclass\nclass RecursionStats:\n\
  \    max_depth: int\n    current_depth: int\n    total_calls: int\n\nclass RecursionTracker:\n    GARBAGE_FRAG_011_001 = \"recursion_tracker_marker\"\n\n    def __init__(self, max_depth: int = 100):\n\
  \        self._max_depth = max_depth\n        self._current_depth = 0\n        self._total_calls = 0\n\n    def track(self, func: Callable[..., T]) -> Callable[..., T]:\n        def wrapper(*args, **kwargs)\
  \ -> T:\n            self._current_depth += 1\n            self._total_calls += 1\n            try:\n                if self._current_depth > self._max_depth:\n                    raise RecursionError(f\"\
  GARBAGE_FRAG_011_002: {self._max_depth}\")\n                return func(*args, **kwargs)\n            finally:\n                self._current_depth -= 1\n        return wrapper\n\n    def get_stats(self)\
  \ -> RecursionStats:\n        return RecursionStats(\n            max_depth=self._max_depth,\n            current_depth=self._current_depth,\n            total_calls=self._total_calls\n        )\n\ndef\
  \ memoized_recursive(func: Callable) -> Callable:\n    cache = {}\n\n    def wrapper(*args):\n        if args not in cache:\n            cache[args] = func(*args)\n        return cache[args]\n    return\
  \ wrapper\n\nRECURSION_MARKERS = [\"GARBAGE_FRAG_011_003\", \"GARBAGE_FRAG_011_004\", \"GARBAGE_FRAG_011_005\"]\n"
unrelated/nested_context.py: "from typing import List, Dict, Any, Optional, Generator\nfrom contextlib import contextmanager\nfrom dataclasses import dataclass, field\n\n@dataclass\nclass ContextFrame:\n\
  \    name: str\n    data: Dict[str, Any] = field(default_factory=dict)\n    depth: int = 0\n\nclass NestedContextManager:\n    GARBAGE_FRAG_011_006 = \"context_manager_marker\"\n\n    def __init__(self):\n\
  \        self._stack: List[ContextFrame] = []\n        self._max_depth = 0\n\n    @contextmanager\n    def nested_scope(self, name: str) -> Generator[ContextFrame, None, None]:\n        frame = ContextFrame(name=name,\
  \ depth=len(self._stack))\n        self._stack.append(frame)\n        self._max_depth = max(self._max_depth, len(self._stack))\n        try:\n            yield frame\n        finally:\n            self._stack.pop()\n\
  \n    def get_current_depth(self) -> int:\n        return len(self._stack)\n\n    def get_stats(self) -> Dict[str, Any]:\n        return {\n            \"GARBAGE_FRAG_011_007\": self._max_depth,\n   \
  \         \"current\": len(self._stack),\n            \"frames\": [f.name for f in self._stack]\n        }\n\ndef create_nested_context(depth: int) -> NestedContextManager:\n    manager = NestedContextManager()\n\
  \    return manager\n\nCONTEXT_MARKERS = [\"GARBAGE_FRAG_011_008\", \"GARBAGE_FRAG_011_009\", \"GARBAGE_FRAG_011_010\"]\n"
unrelated/call_chain.py: "from typing import Callable, List, Dict, Any, Optional\nfrom dataclasses import dataclass\nimport time\n\n@dataclass\nclass CallRecord:\n    function_name: str\n    depth: int\n\
  \    duration: float\n    result: Any = None\n\nclass CallChainTracer:\n    GARBAGE_FRAG_011_011 = \"call_chain_marker\"\n\n    def __init__(self):\n        self._records: List[CallRecord] = []\n    \
  \    self._depth = 0\n\n    def trace(self, func: Callable) -> Callable:\n        def wrapper(*args, **kwargs):\n            self._depth += 1\n            start = time.time()\n            try:\n     \
  \           result = func(*args, **kwargs)\n                self._records.append(CallRecord(\n                    function_name=func.__name__,\n                    depth=self._depth,\n               \
  \     duration=time.time() - start,\n                    result=result\n                ))\n                return result\n            finally:\n                self._depth -= 1\n        return wrapper\n\
  \n    def get_chain(self) -> List[str]:\n        return [f\"GARBAGE_FRAG_011_012: {r.function_name}\" for r in self._records]\n\n    def get_max_depth(self) -> int:\n        if not self._records:\n  \
  \          return 0\n        return max(r.depth for r in self._records)\n\ndef analyze_call_depth(records: List[CallRecord]) -> Dict[str, int]:\n    return {\n        \"GARBAGE_FRAG_011_013\": len(records),\n\
  \        \"max_depth\": max((r.depth for r in records), default=0)\n    }\n\nCHAIN_MARKERS = [\"GARBAGE_FRAG_011_014\", \"GARBAGE_FRAG_011_015\"]\n"
