name: fragments_011_deeply_nested_functions
initial:
  src/deep_nested.py: |
    from functools import wraps
    from typing import Callable, TypeVar, Any, List, Dict, Optional
    from dataclasses import dataclass
    from contextlib import contextmanager
    import asyncio
    import logging

    logger = logging.getLogger(__name__)
    T = TypeVar('T')

    @dataclass
    class ExecutionContext:
        depth: int
        max_depth: int = 10
        trace: List[str] = None

        def __post_init__(self):
            if self.trace is None:
                self.trace = []

    def unrelated_shallow_function():
        items = [x ** 2 for x in range(15)]
        filtered = [x for x in items if x > 50]
        return f"GARBAGE_FRAG_011_shallow: {sum(filtered)}"

    def unrelated_medium_depth():
        def medium_inner():
            calculations = []
            for i in range(10):
                calculations.append(i * i + 2 * i + 1)
            return f"GARBAGE_FRAG_011_medium: {calculations}"
        return medium_inner()

    class UnrelatedDeepClass:
        MARKER = "GARBAGE_FRAG_011_deepclass"
        CONFIG = {"depth": 5, "marker": "GARBAGE_FRAG_011_config"}

        def __init__(self, max_depth: int = 5):
            self._max_depth = max_depth
            self._call_stack: List[str] = []

        def method_with_deep_nesting(self):
            def deep_a():
                self._call_stack.append("a")

                def deep_b():
                    self._call_stack.append("b")

                    def deep_c():
                        return f"GARBAGE_FRAG_011_deepc: {len(self._call_stack)}"
                    return deep_c()
                return deep_b()
            return deep_a()

        def another_nested_method(self):
            def layer_one():
                def layer_two():
                    return "GARBAGE_FRAG_011_layertwo"
                return layer_two()
            return layer_one()

    def level1():
        config = {"initialized": True}
        results: List[int] = []

        def level2():
            local_data = list(config.keys())

            def level3():
                processed = [d.upper() for d in local_data]
                return 42
            return level3()
        return level2()

    def another_deep_structure():
        counter = [0]

        def layer_one():
            counter[0] += 1

            def layer_two():
                counter[0] += 1

                def layer_three():
                    counter[0] += 1

                    def layer_four():
                        return f"GARBAGE_FRAG_011_layerfour: {counter[0]}"
                    return layer_four()
                return layer_three()
            return layer_two()
        return layer_one()

    class AnotherUnrelatedClass:
        VALUE = "GARBAGE_FRAG_011_anotherclass"

        def __init__(self):
            self._depth_tracker = 0
            self._results: List[Any] = []

        def nested_method(self):
            def m_level1():
                items = [1, 2, 3, 4, 5]

                def m_level2():
                    total = sum(items)

                    def m_level3():
                        return f"GARBAGE_FRAG_011_mlevel3: {total}"
                    return m_level3()
                return m_level2()
            return m_level1()

        def recursive_like_nesting(self):
            def step_one(n: int):
                def step_two():
                    def step_three():
                        return f"GARBAGE_FRAG_011_stepthree: {n}"
                    return step_three()
                return step_two()
            return step_one(10)

    def utility_with_closures():
        state = {"count": 0, "items": []}

        def increment():
            state["count"] += 1

            def get_value():
                return f"GARBAGE_FRAG_011_closure: {state['count']}"
            return get_value()
        return increment

    TRAILING_CONSTANT = "GARBAGE_FRAG_011_trailing"
    DEPTH_LIMIT = 10

  unrelated/recursion_utils.py: |
    from typing import Callable, TypeVar, List, Optional
    from functools import lru_cache
    from dataclasses import dataclass

    T = TypeVar('T')

    @dataclass
    class RecursionStats:
        max_depth: int
        current_depth: int
        total_calls: int

    class RecursionTracker:
        GARBAGE_FRAG_011_001 = "recursion_tracker_marker"

        def __init__(self, max_depth: int = 100):
            self._max_depth = max_depth
            self._current_depth = 0
            self._total_calls = 0

        def track(self, func: Callable[..., T]) -> Callable[..., T]:
            def wrapper(*args, **kwargs) -> T:
                self._current_depth += 1
                self._total_calls += 1
                try:
                    if self._current_depth > self._max_depth:
                        raise RecursionError(f"GARBAGE_FRAG_011_002: {self._max_depth}")
                    return func(*args, **kwargs)
                finally:
                    self._current_depth -= 1
            return wrapper

        def get_stats(self) -> RecursionStats:
            return RecursionStats(
                max_depth=self._max_depth,
                current_depth=self._current_depth,
                total_calls=self._total_calls
            )

    def memoized_recursive(func: Callable) -> Callable:
        cache = {}

        def wrapper(*args):
            if args not in cache:
                cache[args] = func(*args)
            return cache[args]
        return wrapper

    RECURSION_MARKERS = ["GARBAGE_FRAG_011_003", "GARBAGE_FRAG_011_004", "GARBAGE_FRAG_011_005"]

  unrelated/nested_context.py: |
    from typing import List, Dict, Any, Optional, Generator
    from contextlib import contextmanager
    from dataclasses import dataclass, field

    @dataclass
    class ContextFrame:
        name: str
        data: Dict[str, Any] = field(default_factory=dict)
        depth: int = 0

    class NestedContextManager:
        GARBAGE_FRAG_011_006 = "context_manager_marker"

        def __init__(self):
            self._stack: List[ContextFrame] = []
            self._max_depth = 0

        @contextmanager
        def nested_scope(self, name: str) -> Generator[ContextFrame, None, None]:
            frame = ContextFrame(name=name, depth=len(self._stack))
            self._stack.append(frame)
            self._max_depth = max(self._max_depth, len(self._stack))
            try:
                yield frame
            finally:
                self._stack.pop()

        def get_current_depth(self) -> int:
            return len(self._stack)

        def get_stats(self) -> Dict[str, Any]:
            return {
                "GARBAGE_FRAG_011_007": self._max_depth,
                "current": len(self._stack),
                "frames": [f.name for f in self._stack]
            }

    def create_nested_context(depth: int) -> NestedContextManager:
        manager = NestedContextManager()
        return manager

    CONTEXT_MARKERS = ["GARBAGE_FRAG_011_008", "GARBAGE_FRAG_011_009", "GARBAGE_FRAG_011_010"]

  unrelated/call_chain.py: |
    from typing import Callable, List, Dict, Any, Optional
    from dataclasses import dataclass
    import time

    @dataclass
    class CallRecord:
        function_name: str
        depth: int
        duration: float
        result: Any = None

    class CallChainTracer:
        GARBAGE_FRAG_011_011 = "call_chain_marker"

        def __init__(self):
            self._records: List[CallRecord] = []
            self._depth = 0

        def trace(self, func: Callable) -> Callable:
            def wrapper(*args, **kwargs):
                self._depth += 1
                start = time.time()
                try:
                    result = func(*args, **kwargs)
                    self._records.append(CallRecord(
                        function_name=func.__name__,
                        depth=self._depth,
                        duration=time.time() - start,
                        result=result
                    ))
                    return result
                finally:
                    self._depth -= 1
            return wrapper

        def get_chain(self) -> List[str]:
            return [f"GARBAGE_FRAG_011_012: {r.function_name}" for r in self._records]

        def get_max_depth(self) -> int:
            if not self._records:
                return 0
            return max(r.depth for r in self._records)

    def analyze_call_depth(records: List[CallRecord]) -> Dict[str, int]:
        return {
            "GARBAGE_FRAG_011_013": len(records),
            "max_depth": max((r.depth for r in records), default=0)
        }

    CHAIN_MARKERS = ["GARBAGE_FRAG_011_014", "GARBAGE_FRAG_011_015"]

changed:
  src/deep_nested.py: |
    from functools import wraps
    from typing import Callable, TypeVar, Any, List, Dict, Optional
    from dataclasses import dataclass
    from contextlib import contextmanager
    import asyncio
    import logging

    logger = logging.getLogger(__name__)
    T = TypeVar('T')

    @dataclass
    class ExecutionContext:
        depth: int
        max_depth: int = 10
        trace: List[str] = None

        def __post_init__(self):
            if self.trace is None:
                self.trace = []

    def unrelated_shallow_function():
        items = [x ** 2 for x in range(15)]
        filtered = [x for x in items if x > 50]
        return f"GARBAGE_FRAG_011_shallow: {sum(filtered)}"

    def unrelated_medium_depth():
        def medium_inner():
            calculations = []
            for i in range(10):
                calculations.append(i * i + 2 * i + 1)
            return f"GARBAGE_FRAG_011_medium: {calculations}"
        return medium_inner()

    class UnrelatedDeepClass:
        MARKER = "GARBAGE_FRAG_011_deepclass"
        CONFIG = {"depth": 5, "marker": "GARBAGE_FRAG_011_config"}

        def __init__(self, max_depth: int = 5):
            self._max_depth = max_depth
            self._call_stack: List[str] = []

        def method_with_deep_nesting(self):
            def deep_a():
                self._call_stack.append("a")

                def deep_b():
                    self._call_stack.append("b")

                    def deep_c():
                        return f"GARBAGE_FRAG_011_deepc: {len(self._call_stack)}"
                    return deep_c()
                return deep_b()
            return deep_a()

        def another_nested_method(self):
            def layer_one():
                def layer_two():
                    return "GARBAGE_FRAG_011_layertwo"
                return layer_two()
            return layer_one()

    def level1():
        config = {"initialized": True}
        results: List[int] = []

        def level2():
            local_data = list(config.keys())

            def level3():
                processed = [d.upper() for d in local_data]
                return 100
            return level3()
        return level2()

    def another_deep_structure():
        counter = [0]

        def layer_one():
            counter[0] += 1

            def layer_two():
                counter[0] += 1

                def layer_three():
                    counter[0] += 1

                    def layer_four():
                        return f"GARBAGE_FRAG_011_layerfour: {counter[0]}"
                    return layer_four()
                return layer_three()
            return layer_two()
        return layer_one()

    class AnotherUnrelatedClass:
        VALUE = "GARBAGE_FRAG_011_anotherclass"

        def __init__(self):
            self._depth_tracker = 0
            self._results: List[Any] = []

        def nested_method(self):
            def m_level1():
                items = [1, 2, 3, 4, 5]

                def m_level2():
                    total = sum(items)

                    def m_level3():
                        return f"GARBAGE_FRAG_011_mlevel3: {total}"
                    return m_level3()
                return m_level2()
            return m_level1()

        def recursive_like_nesting(self):
            def step_one(n: int):
                def step_two():
                    def step_three():
                        return f"GARBAGE_FRAG_011_stepthree: {n}"
                    return step_three()
                return step_two()
            return step_one(10)

    def utility_with_closures():
        state = {"count": 0, "items": []}

        def increment():
            state["count"] += 1

            def get_value():
                return f"GARBAGE_FRAG_011_closure: {state['count']}"
            return get_value()
        return increment

    TRAILING_CONSTANT = "GARBAGE_FRAG_011_trailing"
    DEPTH_LIMIT = 10

assertions:
  must_include:
    - level3
    - deep_nested.py
    - return 100
  must_not_include:
    - GARBAGE_FRAG_011_shallow
    - GARBAGE_FRAG_011_medium
    - GARBAGE_FRAG_011_deepclass
    - GARBAGE_FRAG_011_config
    - GARBAGE_FRAG_011_deepc
    - GARBAGE_FRAG_011_layertwo
    - GARBAGE_FRAG_011_layerfour
    - GARBAGE_FRAG_011_anotherclass
    - GARBAGE_FRAG_011_mlevel3
    - GARBAGE_FRAG_011_stepthree
    - GARBAGE_FRAG_011_closure
    - GARBAGE_FRAG_011_trailing
    - GARBAGE_FRAG_011_001
    - GARBAGE_FRAG_011_002
    - GARBAGE_FRAG_011_003
    - GARBAGE_FRAG_011_004
    - GARBAGE_FRAG_011_005
    - GARBAGE_FRAG_011_006
    - GARBAGE_FRAG_011_007
    - GARBAGE_FRAG_011_008
    - GARBAGE_FRAG_011_009
    - GARBAGE_FRAG_011_010
    - GARBAGE_FRAG_011_011
    - GARBAGE_FRAG_011_012
    - GARBAGE_FRAG_011_013
    - GARBAGE_FRAG_011_014
    - GARBAGE_FRAG_011_015
    - unrelated_shallow_function
    - unrelated_medium_depth
    - UnrelatedDeepClass
    - another_deep_structure
    - AnotherUnrelatedClass
    - utility_with_closures
    - RecursionTracker
    - NestedContextManager
    - CallChainTracer
    - recursion_utils.py
    - nested_context.py
    - call_chain.py
options:
  commit_message: Change innermost function return value
