src/enclosing.py: |
  from typing import Optional, Dict, List, Any, Callable
  from dataclasses import dataclass, field
  from enum import Enum
  import logging
  import json

  logger = logging.getLogger(__name__)

  class ProcessingState(Enum):
      PENDING = "pending"
      RUNNING = "running"
      COMPLETED = "completed"
      FAILED = "failed"

  @dataclass
  class ProcessingResult:
      status: ProcessingState
      data: Any = None
      error: Optional[str] = None

  def standalone_before_function():
      items = [i * 2 for i in range(10)]
      mapping = {str(i): v for i, v in enumerate(items)}
      return f"GARBAGE_FRAG_090_standalonebefore: {sum(items)}"

  def utility_helper_alpha():
      def inner_calculation():
          return sum(x ** 2 for x in range(5))
      result = inner_calculation()
      return f"GARBAGE_FRAG_090_utilityalpha: {result}"

  class UnrelatedClassBefore:
      MARKER = "GARBAGE_FRAG_090_classbefore"
      DEFAULT_CONFIG = {"key": "GARBAGE_FRAG_090_defaultconfig"}

      def __init__(self, config: Optional[Dict] = None):
          self._config = config or self.DEFAULT_CONFIG
          self._initialized = False
          self._cache: Dict[str, Any] = {}

      def before_method(self):
          processed = []
          for key, value in self._config.items():
              processed.append(f"{key}={value}")
          return f"GARBAGE_FRAG_090_beforemethod: {processed}"

      def another_before_method(self):
          return f"GARBAGE_FRAG_090_anotherbeforemethod: {self._initialized}"

      @staticmethod
      def static_before():
          return "GARBAGE_FRAG_090_staticbefore"

  class MyClass:
      def __init__(self, initial_value: int = 0):
          self._value = initial_value
          self._history: List[int] = []

      def method1(self):
          self._history.append(self._value)
          pass

      def method2(self):
          x = 1
          y = 2
          self._history.append(x + y)
          return x + y

      def method3(self):
          if self._history:
              return self._history[-1]
          pass

      def unrelated_method_in_class(self):
          data = {"status": "GARBAGE_FRAG_090_unrelatedinclass"}
          return json.dumps(data)

      @property
      def value(self) -> int:
          return self._value

      @value.setter
      def value(self, new_value: int) -> None:
          self._value = new_value

  class UnrelatedClassAfter:
      VALUE = "GARBAGE_FRAG_090_classafter"
      CONSTANTS = ["GARBAGE_FRAG_090_const1", "GARBAGE_FRAG_090_const2"]

      def __init__(self):
          self._data: List[str] = []
          self._processed = False

      def after_method_a(self):
          results = []
          for item in self.CONSTANTS:
              results.append(item.upper())
          return f"GARBAGE_FRAG_090_aftermethoda: {results}"

      def after_method_b(self):
          self._processed = True
          return f"GARBAGE_FRAG_090_aftermethodb: {self._processed}"

      def after_method_c(self):
          return f"GARBAGE_FRAG_090_aftermethodc: {len(self._data)}"

  def standalone_after_function():
      calculations = [x ** 3 for x in range(8)]
      total = sum(calculations)
      return f"GARBAGE_FRAG_090_standaloneafter: {total}"

  def utility_helper_beta():
      mapping = {"a": 1, "b": 2, "c": 3}
      return f"GARBAGE_FRAG_090_utilitybeta: {mapping}"

  TRAILING_CONST_A = "GARBAGE_FRAG_090_trailinga"
  TRAILING_CONST_B = "GARBAGE_FRAG_090_trailingb"
unrelated/data_processor.py: |
  from typing import List, Dict, Any, Optional
  from dataclasses import dataclass
  import json

  @dataclass
  class DataRecord:
      id: str
      value: Any
      metadata: Dict[str, str]

  class DataProcessor:
      GARBAGE_FRAG_090_001 = "data_processor_marker"

      def __init__(self, batch_size: int = 100):
          self._batch_size = batch_size
          self._records: List[DataRecord] = []
          self._processed_count = 0

      def add_record(self, record: DataRecord) -> None:
          self._records.append(record)
          if len(self._records) >= self._batch_size:
              self._flush_batch()

      def _flush_batch(self) -> int:
          count = len(self._records)
          self._processed_count += count
          self._records.clear()
          return count

      def process_all(self) -> Dict[str, int]:
          remaining = self._flush_batch()
          return {
              "GARBAGE_FRAG_090_002": self._processed_count,
              "remaining": remaining
          }

      def get_stats(self) -> Dict[str, Any]:
          return {
              "GARBAGE_FRAG_090_003": self._batch_size,
              "processed": self._processed_count,
              "pending": len(self._records)
          }

  def transform_records(records: List[DataRecord]) -> List[Dict]:
      return [
          {"id": r.id, "data": r.value, "meta": r.metadata}
          for r in records
      ]

  PROCESSOR_MARKERS = ["GARBAGE_FRAG_090_004", "GARBAGE_FRAG_090_005"]
unrelated/validation_service.py: |
  from typing import Any, Dict, List, Optional, Callable
  from dataclasses import dataclass
  from enum import Enum

  class ValidationResult(Enum):
      VALID = "valid"
      INVALID = "invalid"
      WARNING = "warning"

  @dataclass
  class ValidationError:
      field: str
      message: str
      code: str

  class ValidationService:
      GARBAGE_FRAG_090_006 = "validation_service_marker"

      def __init__(self):
          self._validators: Dict[str, Callable] = {}
          self._errors: List[ValidationError] = []

      def register_validator(self, field: str, validator: Callable[[Any], bool]) -> None:
          self._validators[field] = validator

      def validate(self, data: Dict[str, Any]) -> ValidationResult:
          self._errors.clear()
          for field, validator in self._validators.items():
              if field in data:
                  if not validator(data[field]):
                      self._errors.append(ValidationError(
                          field=field,
                          message=f"GARBAGE_FRAG_090_007: {field}",
                          code="INVALID"
                      ))
          return ValidationResult.INVALID if self._errors else ValidationResult.VALID

      def get_errors(self) -> List[ValidationError]:
          return self._errors.copy()

  def create_string_validator(min_len: int, max_len: int) -> Callable[[str], bool]:
      def validator(value: str) -> bool:
          return min_len <= len(value) <= max_len
      return validator

  VALIDATION_MARKERS = ["GARBAGE_FRAG_090_008", "GARBAGE_FRAG_090_009", "GARBAGE_FRAG_090_010"]
unrelated/state_machine.py: |
  from typing import Dict, List, Callable, Optional, Any
  from dataclasses import dataclass
  from enum import Enum

  class TransitionResult(Enum):
      SUCCESS = "success"
      FAILURE = "failure"
      NO_TRANSITION = "no_transition"

  @dataclass
  class StateTransition:
      from_state: str
      to_state: str
      condition: Optional[Callable[[], bool]] = None

  class StateMachine:
      GARBAGE_FRAG_090_011 = "state_machine_marker"

      def __init__(self, initial_state: str):
          self._current_state = initial_state
          self._transitions: Dict[str, List[StateTransition]] = {}
          self._history: List[str] = [initial_state]

      def add_transition(self, transition: StateTransition) -> None:
          if transition.from_state not in self._transitions:
              self._transitions[transition.from_state] = []
          self._transitions[transition.from_state].append(transition)

      def transition_to(self, target_state: str) -> TransitionResult:
          available = self._transitions.get(self._current_state, [])
          for trans in available:
              if trans.to_state == target_state:
                  if trans.condition is None or trans.condition():
                      self._current_state = target_state
                      self._history.append(target_state)
                      return TransitionResult.SUCCESS
                  return TransitionResult.FAILURE
          return TransitionResult.NO_TRANSITION

      def get_history(self) -> List[str]:
          return self._history.copy()

      def get_state_info(self) -> Dict[str, Any]:
          return {
              "current": self._current_state,
              "GARBAGE_FRAG_090_012": len(self._history),
              "available": list(self._transitions.get(self._current_state, []))
          }

  STATE_MARKERS = ["GARBAGE_FRAG_090_013", "GARBAGE_FRAG_090_014", "GARBAGE_FRAG_090_015"]
