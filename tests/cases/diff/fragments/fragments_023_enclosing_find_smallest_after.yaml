src/enclosing.py: "from typing import Optional, Dict, List, Any, Callable\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nimport logging\nimport json\n\nlogger = logging.getLogger(__name__)\n\
  \nclass ProcessingState(Enum):\n    PENDING = \"pending\"\n    RUNNING = \"running\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n\n@dataclass\nclass ProcessingResult:\n    status: ProcessingState\n\
  \    data: Any = None\n    error: Optional[str] = None\n\ndef standalone_before_function():\n    items = [i * 2 for i in range(10)]\n    mapping = {str(i): v for i, v in enumerate(items)}\n\ndef utility_helper_alpha():\n\
  \    def inner_calculation():\n        return sum(x ** 2 for x in range(5))\n    result = inner_calculation()\n\nclass UnrelatedClassBefore:\n\n    def __init__(self, config: Optional[Dict] = None):\n\
  \        self._config = config or self.DEFAULT_CONFIG\n        self._initialized = False\n        self._cache: Dict[str, Any] = {}\n\n    def before_method(self):\n        processed = []\n        for\
  \ key, value in self._config.items():\n            processed.append(f\"{key}={value}\")\n\n    def another_before_method(self):\n\n    @staticmethod\n    def static_before():\n\nclass MyClass:\n    def\
  \ __init__(self, initial_value: int = 0):\n        self._value = initial_value\n        self._history: List[int] = []\n\n    def method1(self):\n        self._history.append(self._value)\n        pass\n\
  \n    def method2(self):\n        x = 1\n        y = 3\n        self._history.append(x + y)\n        return x + y\n\n    def method3(self):\n        if self._history:\n            return self._history[-1]\n\
  \        pass\n\n    def unrelated_method_in_class(self):\n        return json.dumps(data)\n\n    @property\n    def value(self) -> int:\n        return self._value\n\n    @value.setter\n    def value(self,\
  \ new_value: int) -> None:\n        self._value = new_value\n\nclass UnrelatedClassAfter:\n\n    def __init__(self):\n        self._data: List[str] = []\n        self._processed = False\n\n    def after_method_a(self):\n\
  \        results = []\n        for item in self.CONSTANTS:\n            results.append(item.upper())\n\n    def after_method_b(self):\n        self._processed = True\n\n    def after_method_c(self):\n\
  \ndef standalone_after_function():\n    calculations = [x ** 3 for x in range(8)]\n    total = sum(calculations)\n\ndef utility_helper_beta():\n    mapping = {\"a\": 1, \"b\": 2, \"c\": 3}\n\n"
unrelated/data_processor.py: "from typing import List, Dict, Any, Optional\nfrom dataclasses import dataclass\nimport json\n\n@dataclass\nclass DataRecord:\n    id: str\n    value: Any\n    metadata: Dict[str,\
  \ str]\n\nclass DataProcessor:\n    GARBAGE_FRAG_090_001 = \"data_processor_marker\"\n\n    def __init__(self, batch_size: int = 100):\n        self._batch_size = batch_size\n        self._records: List[DataRecord]\
  \ = []\n        self._processed_count = 0\n\n    def add_record(self, record: DataRecord) -> None:\n        self._records.append(record)\n        if len(self._records) >= self._batch_size:\n         \
  \   self._flush_batch()\n\n    def _flush_batch(self) -> int:\n        count = len(self._records)\n        self._processed_count += count\n        self._records.clear()\n        return count\n\n    def\
  \ process_all(self) -> Dict[str, int]:\n        remaining = self._flush_batch()\n        return {\n            \"GARBAGE_FRAG_090_002\": self._processed_count,\n            \"remaining\": remaining\n\
  \        }\n\n    def get_stats(self) -> Dict[str, Any]:\n        return {\n            \"GARBAGE_FRAG_090_003\": self._batch_size,\n            \"processed\": self._processed_count,\n            \"pending\"\
  : len(self._records)\n        }\n\ndef transform_records(records: List[DataRecord]) -> List[Dict]:\n    return [\n        {\"id\": r.id, \"data\": r.value, \"meta\": r.metadata}\n        for r in records\n\
  \    ]\n\nPROCESSOR_MARKERS = [\"GARBAGE_FRAG_090_004\", \"GARBAGE_FRAG_090_005\"]\n"
unrelated/validation_service.py: "from typing import Any, Dict, List, Optional, Callable\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nclass ValidationResult(Enum):\n    VALID = \"valid\"\
  \n    INVALID = \"invalid\"\n    WARNING = \"warning\"\n\n@dataclass\nclass ValidationError:\n    field: str\n    message: str\n    code: str\n\nclass ValidationService:\n    GARBAGE_FRAG_090_006 = \"\
  validation_service_marker\"\n\n    def __init__(self):\n        self._validators: Dict[str, Callable] = {}\n        self._errors: List[ValidationError] = []\n\n    def register_validator(self, field:\
  \ str, validator: Callable[[Any], bool]) -> None:\n        self._validators[field] = validator\n\n    def validate(self, data: Dict[str, Any]) -> ValidationResult:\n        self._errors.clear()\n    \
  \    for field, validator in self._validators.items():\n            if field in data:\n                if not validator(data[field]):\n                    self._errors.append(ValidationError(\n      \
  \                  field=field,\n                        message=f\"GARBAGE_FRAG_090_007: {field}\",\n                        code=\"INVALID\"\n                    ))\n        return ValidationResult.INVALID\
  \ if self._errors else ValidationResult.VALID\n\n    def get_errors(self) -> List[ValidationError]:\n        return self._errors.copy()\n\ndef create_string_validator(min_len: int, max_len: int) -> Callable[[str],\
  \ bool]:\n    def validator(value: str) -> bool:\n        return min_len <= len(value) <= max_len\n    return validator\n\nVALIDATION_MARKERS = [\"GARBAGE_FRAG_090_008\", \"GARBAGE_FRAG_090_009\", \"\
  GARBAGE_FRAG_090_010\"]\n"
unrelated/state_machine.py: "from typing import Dict, List, Callable, Optional, Any\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nclass TransitionResult(Enum):\n    SUCCESS = \"success\"\n\
  \    FAILURE = \"failure\"\n    NO_TRANSITION = \"no_transition\"\n\n@dataclass\nclass StateTransition:\n    from_state: str\n    to_state: str\n    condition: Optional[Callable[[], bool]] = None\n\n\
  class StateMachine:\n    GARBAGE_FRAG_090_011 = \"state_machine_marker\"\n\n    def __init__(self, initial_state: str):\n        self._current_state = initial_state\n        self._transitions: Dict[str,\
  \ List[StateTransition]] = {}\n        self._history: List[str] = [initial_state]\n\n    def add_transition(self, transition: StateTransition) -> None:\n        if transition.from_state not in self._transitions:\n\
  \            self._transitions[transition.from_state] = []\n        self._transitions[transition.from_state].append(transition)\n\n    def transition_to(self, target_state: str) -> TransitionResult:\n\
  \        available = self._transitions.get(self._current_state, [])\n        for trans in available:\n            if trans.to_state == target_state:\n                if trans.condition is None or trans.condition():\n\
  \                    self._current_state = target_state\n                    self._history.append(target_state)\n                    return TransitionResult.SUCCESS\n                return TransitionResult.FAILURE\n\
  \        return TransitionResult.NO_TRANSITION\n\n    def get_history(self) -> List[str]:\n        return self._history.copy()\n\n    def get_state_info(self) -> Dict[str, Any]:\n        return {\n  \
  \          \"current\": self._current_state,\n            \"GARBAGE_FRAG_090_012\": len(self._history),\n            \"available\": list(self._transitions.get(self._current_state, []))\n        }\n\n\
  STATE_MARKERS = [\"GARBAGE_FRAG_090_013\", \"GARBAGE_FRAG_090_014\", \"GARBAGE_FRAG_090_015\"]\n"
