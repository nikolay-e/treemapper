name: python_034_pydantic_model_usage
initial:
  schemas.py: |
    from pydantic import BaseModel, EmailStr, Field, validator
    from typing import Optional, List
    from datetime import datetime
    from enum import Enum

    class UserRole(str, Enum):
        ADMIN = "admin"
        MODERATOR = "moderator"
        USER = "user"
        GUEST = "guest"

    class AddressSchema(BaseModel):
        street: str = Field(..., min_length=1)
        city: str = Field(..., min_length=1)
        state: str = Field(..., min_length=2)
        postal_code: str
        country: str = "USA"

        class Config:
            orm_mode = True

    class UserSchema(BaseModel):
        name: str = Field(..., min_length=1, max_length=100)
        email: EmailStr
        age: int = Field(..., ge=0, le=150)
        role: UserRole = UserRole.USER
        address: Optional[AddressSchema] = None
        is_active: bool = True

        class Config:
            orm_mode = True

        @validator("name")
        def validate_name(cls, v):
            if not v.strip():
                raise ValueError("Name cannot be empty")
            return v.strip()

    class UserCreateSchema(BaseModel):
        name: str = Field(..., min_length=1)
        email: EmailStr
        age: int = Field(..., ge=18)
        password: str = Field(..., min_length=8)

        @validator("password")
        def validate_password_strength(cls, v):
            if not any(c.isupper() for c in v):
                raise ValueError("Password must contain uppercase")
            return v

  api.py: |
    from schemas import UserSchema, UserCreateSchema

    class UserEndpoint:
        def __init__(self, repository):
            self.repository = repository

        def get_user(self, user_id: int):
            return self.repository.find_by_id(user_id)

    def validate():
        pass

  unrelated/cache_layer.py: |
    GARBAGE_PYTHON_034_001 = "cache layer marker"
    GARBAGE_PYTHON_034_002 = "cache ttl constant"

    class CacheBackend:
        GARBAGE_PYTHON_034_003 = "backend class marker"

        def __init__(self, host: str = "localhost"):
            self.host = host

        def get(self, key: str):
            return None

  unrelated/queue_manager.py: |
    GARBAGE_PYTHON_034_004 = "queue manager marker"
    GARBAGE_PYTHON_034_005 = "queue size constant"

    class MessageQueue:
        GARBAGE_PYTHON_034_006 = "queue class marker"

        def __init__(self, name: str):
            self.name = name

        def publish(self, message: dict) -> bool:
            return True

  unrelated/rate_limiter.py: |
    GARBAGE_PYTHON_034_007 = "rate limiter marker"
    GARBAGE_PYTHON_034_008 = "rate limit constant"

    class RateLimiter:
        GARBAGE_PYTHON_034_009 = "limiter class marker"

        def __init__(self, requests_per_second: int = 100):
            self.requests_per_second = requests_per_second

        def is_allowed(self, client_id: str) -> bool:
            return True

changed:
  schemas.py: |
    from pydantic import BaseModel, EmailStr, Field, validator, root_validator
    from typing import Optional, List
    from datetime import datetime
    from enum import Enum

    class UserRole(str, Enum):
        ADMIN = "admin"
        MODERATOR = "moderator"
        USER = "user"
        GUEST = "guest"

    class AddressSchema(BaseModel):
        street: str = Field(..., min_length=1)
        city: str = Field(..., min_length=1)
        state: str = Field(..., min_length=2)
        postal_code: str
        country: str = "USA"
        is_primary: bool = False

        class Config:
            orm_mode = True

        def full_address(self) -> str:
            return f"{self.street}, {self.city}, {self.state} {self.postal_code}"

    class UserSchema(BaseModel):
        name: str = Field(..., min_length=1, max_length=100)
        email: EmailStr
        age: int = Field(..., ge=0, le=150)
        role: UserRole = UserRole.USER
        address: Optional[AddressSchema] = None
        is_active: bool = True
        is_verified: bool = False
        created_at: datetime = Field(default_factory=datetime.utcnow)

        class Config:
            orm_mode = True
            use_enum_values = True

        @validator("name")
        def validate_name(cls, v):
            if not v.strip():
                raise ValueError("Name cannot be empty")
            return v.strip()

        def is_admin(self) -> bool:
            return self.role == UserRole.ADMIN

    class UserCreateSchema(BaseModel):
        name: str = Field(..., min_length=1)
        email: EmailStr
        age: int = Field(..., ge=18)
        password: str = Field(..., min_length=8)
        role: UserRole = UserRole.USER

        @validator("password")
        def validate_password_strength(cls, v):
            if not any(c.isupper() for c in v):
                raise ValueError("Password must contain uppercase")
            if not any(c.isdigit() for c in v):
                raise ValueError("Password must contain digit")
            return v

    class UserUpdateSchema(BaseModel):
        name: Optional[str] = None
        age: Optional[int] = Field(None, ge=0)
        is_active: Optional[bool] = None

assertions:
  must_include:
    - class UserSchema
    - class UserCreateSchema
    - class UserUpdateSchema
    - BaseModel
    - EmailStr
    - "@validator"
    - is_verified
  must_not_include:
    - GARBAGE_PYTHON_034_001
    - GARBAGE_PYTHON_034_002
    - GARBAGE_PYTHON_034_003
    - GARBAGE_PYTHON_034_004
    - GARBAGE_PYTHON_034_005
    - GARBAGE_PYTHON_034_006
    - GARBAGE_PYTHON_034_007
    - GARBAGE_PYTHON_034_008
    - GARBAGE_PYTHON_034_009
    - CacheBackend
    - MessageQueue
    - RateLimiter
    - cache_layer.py
    - queue_manager.py
    - rate_limiter.py
