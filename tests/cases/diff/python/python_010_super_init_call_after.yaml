base.py: |
  from typing import Dict, Any, Optional, List
  from dataclasses import dataclass, field
  from datetime import datetime
  from abc import ABC, abstractmethod
  import logging

  logger = logging.getLogger(__name__)

  @dataclass
  class ConfigValidationError:
      field: str
      message: str

  class ConfigValidator:
      def validate_timeout(self, value: int) -> Optional[str]:
          if value < 0:
              return "Timeout must be non-negative"
          if value > 3600:
              return "Timeout cannot exceed 1 hour"
          return None

      def validate_retries(self, value: int) -> Optional[str]:
          if value < 0:
              return "Retries must be non-negative"
          if value > 10:
              return "Too many retries"
          return None

  class BaseConfig(ABC):
      _validator = ConfigValidator()

      def __init__(self, config: Dict[str, Any]):
          self.debug = config.get("debug", False)
          self.timeout = config.get("timeout", 30)
          self.retries = config.get("retries", 3)
          self.log_level = config.get("log_level", "INFO")
          self.created_at = datetime.now()
          self._raw_config = config
          self._validation_errors: List[ConfigValidationError] = []
          self._validate()

      def _validate(self) -> None:
          if error := self._validator.validate_timeout(self.timeout):
              self._validation_errors.append(ConfigValidationError("timeout", error))
          if error := self._validator.validate_retries(self.retries):
              self._validation_errors.append(ConfigValidationError("retries", error))

      @property
      def is_valid(self) -> bool:
          return len(self._validation_errors) == 0

      @property
      def errors(self) -> List[ConfigValidationError]:
          return self._validation_errors.copy()

      def get(self, key: str, default: Any = None) -> Any:
          return self._raw_config.get(key, default)

      def to_dict(self) -> Dict[str, Any]:
          return {
              "debug": self.debug,
              "timeout": self.timeout,
              "retries": self.retries,
              "log_level": self.log_level,
          }

      @abstractmethod
      def validate_specific(self) -> None:
          pass

      def setup_logging(self) -> None:
          level = getattr(logging, self.log_level.upper(), logging.INFO)
          logging.basicConfig(level=level)
          if self.debug:
              logger.setLevel(logging.DEBUG)

  class DatabaseConfig(BaseConfig):
      def __init__(self, config: Dict[str, Any]):
          super().__init__(config)
          self.host = config.get("host", "localhost")
          self.port = config.get("port", 5432)
          self.database = config.get("database", "app")
          self.pool_size = config.get("pool_size", 5)

      def validate_specific(self) -> None:
          if self.pool_size < 1:
              self._validation_errors.append(
                  ConfigValidationError("pool_size", "Pool size must be at least 1")
              )

      def get_connection_string(self) -> str:
          return f"postgresql://{self.host}:{self.port}/{self.database}"
app.py: |
  from typing import Dict, Any, Optional, List
  from dataclasses import dataclass
  from base import BaseConfig, ConfigValidationError

  @dataclass
  class AppSettings:
      name: str
      version: str
      environment: str

  class AppConfig(BaseConfig):
      def __init__(self, config: Dict[str, Any]):
          super().__init__(config)
          self.app_name = config.get("name", "app")
          self.version = config.get("version", "1.0.0")
          self.environment = config.get("environment", "development")
          self.allowed_hosts: List[str] = config.get("allowed_hosts", ["localhost"])
          self.cors_origins: List[str] = config.get("cors_origins", [])

      def validate_specific(self) -> None:
          if self.environment not in ("development", "staging", "production"):
              self._validation_errors.append(
                  ConfigValidationError("environment", "Invalid environment")
              )
          if not self.allowed_hosts:
              self._validation_errors.append(
                  ConfigValidationError("allowed_hosts", "At least one host required")
              )

      def is_production(self) -> bool:
          return self.environment == "production"

      def get_settings(self) -> AppSettings:
          return AppSettings(
              name=self.app_name,
              version=self.version,
              environment=self.environment
          )
garbage_secrets.py: |
  GARBAGE_MARKER_SECRETS_001 = "secrets garbage"
  UNRELATED_SECRET_KEY_002 = "not-a-real-secret"

  class SecretManager:
      GARBAGE_SECRET_CLASS_003 = "secret class marker"

      def __init__(self, vault_url: str = ""):
          self.vault_url = vault_url

      def get_secret(self, name: str) -> Optional[str]:
          return None

      def rotate_secret(self, name: str) -> bool:
          return False

  class EncryptionService:
      GARBAGE_ENCRYPT_MARKER_004 = "encrypt marker"

      def encrypt(self, data: bytes) -> bytes:
          return data

      def decrypt(self, data: bytes) -> bytes:
          return data
garbage_feature_flags.py: |
  GARBAGE_MARKER_FLAGS_005 = "feature flags garbage"
  UNRELATED_FLAG_DEFAULT_006 = True

  class FeatureFlagManager:
      GARBAGE_FLAG_CLASS_007 = True

      def __init__(self):
          self._flags: Dict[str, bool] = {}

      def is_enabled(self, flag_name: str) -> bool:
          return self._flags.get(flag_name, False)

      def set_flag(self, flag_name: str, enabled: bool) -> None:
          self._flags[flag_name] = enabled

  def format_flag_name(name: str) -> str:
      GARBAGE_FORMAT_FLAG_008 = "format flag marker"
      return f"feature_{name}"
