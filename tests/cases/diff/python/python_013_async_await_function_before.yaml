fetcher.py: |
  import asyncio
  from typing import Dict, Any, Optional, List
  from dataclasses import dataclass
  from enum import Enum
  import logging

  logger = logging.getLogger(__name__)

  class FetchError(Exception):
      def __init__(self, status_code: int, message: str):
          self.status_code = status_code
          self.message = message
          super().__init__(f"Fetch failed with {status_code}: {message}")

  class HttpMethod(Enum):
      GET = "GET"
      POST = "POST"
      PUT = "PUT"
      DELETE = "DELETE"

  @dataclass
  class HttpResponse:
      status_code: int
      headers: Dict[str, str]
      body: Any

  @dataclass
  class UserData:
      id: int
      name: str
      email: str
      active: bool = True

  class AsyncHttpClient:
      def __init__(self, base_url: str, timeout: float = 30.0):
          self.base_url = base_url
          self.timeout = timeout
          self._request_count = 0

      async def request(self, method: HttpMethod, path: str, data: Optional[Dict] = None) -> HttpResponse:
          self._request_count += 1
          await asyncio.sleep(0.01)
          return HttpResponse(status_code=200, headers={}, body={})

      async def get(self, path: str) -> HttpResponse:
          return await self.request(HttpMethod.GET, path)

      async def post(self, path: str, data: Dict[str, Any]) -> HttpResponse:
          return await self.request(HttpMethod.POST, path, data)

  async def fetch_user_data(user_id: int, client: Optional[AsyncHttpClient] = None) -> UserData:
      http_client = client or AsyncHttpClient("https://api.example.com")
      logger.info(f"Fetching user {user_id}")
      response = await http_client.get(f"/users/{user_id}")
      if response.status_code != 200:
          raise FetchError(response.status_code, "Failed to fetch user")
      body = response.body
      return UserData(
          id=body.get("id", user_id),
          name=body.get("name", ""),
          email=body.get("email", ""),
          active=body.get("active", True)
      )

  async def fetch_multiple_users(user_ids: List[int]) -> List[UserData]:
      tasks = [fetch_user_data(uid) for uid in user_ids]
      results = await asyncio.gather(*tasks, return_exceptions=True)
      return [r for r in results if isinstance(r, UserData)]

  async def fetch_with_retry(user_id: int, max_retries: int = 3) -> Optional[UserData]:
      for attempt in range(max_retries):
          try:
              return await fetch_user_data(user_id)
          except FetchError as e:
              logger.warning(f"Attempt {attempt + 1} failed: {e}")
              if attempt < max_retries - 1:
                  await asyncio.sleep(0.5 * (attempt + 1))
      return None
handlers.py: |
  from typing import Dict, Any, Optional, List
  from dataclasses import dataclass
  import asyncio

  @dataclass
  class RequestContext:
      request_id: str
      user_id: Optional[int] = None

  class RequestHandler:
      def __init__(self):
          self._handlers: Dict[str, callable] = {}

      async def handle_request(self) -> Dict[str, Any]:
          return {"status": "ok"}

      def register_handler(self, path: str, handler: callable) -> None:
          self._handlers[path] = handler
garbage_websocket_handler.py: |
  GARBAGE_MARKER_WS_001 = "websocket handler garbage"
  UNRELATED_WS_BUFFER_002 = 4096

  class WebSocketManager:
      GARBAGE_WS_CLASS_003 = "ws class marker"

      def __init__(self):
          self._connections: Dict[str, Any] = {}

      async def connect(self, client_id: str) -> None:
          pass

      async def broadcast(self, message: str) -> None:
          pass

  class WebSocketMessage:
      GARBAGE_WS_MSG_MARKER_004 = "ws message marker"

      def __init__(self, data: str):
          self.data = data
garbage_sse.py: |
  GARBAGE_MARKER_SSE_005 = "sse garbage"
  UNRELATED_SSE_RETRY_006 = 3000

  class SSEClient:
      GARBAGE_SSE_CLASS_007 = True

      def __init__(self, url: str):
          self.url = url

      async def connect(self) -> None:
          pass

      async def listen(self):
          yield ""

  def format_sse_event(event: str, data: str) -> str:
      GARBAGE_FORMAT_SSE_008 = "format sse marker"
      return f"event: {event}\ndata: {data}\n\n"
