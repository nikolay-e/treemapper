name: python_006_generic_container_added
initial:
  types.py: |
    from typing import List, Optional, Callable, Any, Dict, Union
    from dataclasses import dataclass
    from abc import ABC, abstractmethod

    @dataclass
    class ProcessingResult:
        success: bool
        value: Optional[Any] = None
        error: Optional[str] = None

    class ItemProcessor(ABC):
        @abstractmethod
        def process(self, item: Any) -> ProcessingResult:
            pass

    class StringProcessor(ItemProcessor):
        def __init__(self, transform: Optional[Callable[[str], str]] = None):
            self.transform = transform or (lambda x: x)

        def process(self, item: Any) -> ProcessingResult:
            if not isinstance(item, str):
                return ProcessingResult(success=False, error="Not a string")
            return ProcessingResult(success=True, value=self.transform(item))

    def process_items(items: List[str]) -> Optional[str]:
        if not items:
            return None
        return items[0]

    def process_all(items: List[Any], processor: ItemProcessor) -> List[ProcessingResult]:
        return [processor.process(item) for item in items]

    def filter_successful(results: List[ProcessingResult]) -> List[Any]:
        return [r.value for r in results if r.success]

    def map_items(items: List[Any], func: Callable[[Any], Any]) -> List[Any]:
        return [func(item) for item in items]

    def reduce_items(items: List[Any], func: Callable[[Any, Any], Any], initial: Any) -> Any:
        result = initial
        for item in items:
            result = func(result, item)
        return result

    class TypeRegistry:
        def __init__(self):
            self._types: Dict[str, type] = {}

        def register(self, name: str, cls: type) -> None:
            self._types[name] = cls

        def get(self, name: str) -> Optional[type]:
            return self._types.get(name)

        def create(self, name: str, *args: Any, **kwargs: Any) -> Optional[Any]:
            cls = self.get(name)
            return cls(*args, **kwargs) if cls else None

  garbage_serialization.py: |
    GARBAGE_MARKER_SERIAL_001 = "serialization garbage"
    UNRELATED_SERIAL_VERSION_002 = "1.0.0"

    class JsonSerializer:
        GARBAGE_JSON_CLASS_003 = "json class marker"

        def serialize(self, obj: Any) -> str:
            import json
            return json.dumps(obj)

        def deserialize(self, data: str) -> Any:
            import json
            return json.loads(data)

    class PickleSerializer:
        GARBAGE_PICKLE_MARKER_004 = "pickle marker"

        def serialize(self, obj: Any) -> bytes:
            import pickle
            return pickle.dumps(obj)

  garbage_validation.py: |
    GARBAGE_MARKER_VALID_005 = "validation garbage"
    UNRELATED_MAX_LENGTH_006 = 255

    class Validator:
        GARBAGE_VALID_CLASS_007 = True

        def validate(self, value: Any, rules: Dict[str, Any]) -> bool:
            return True

        def validate_string(self, value: str, min_length: int = 0, max_length: int = 255) -> bool:
            return min_length <= len(value) <= max_length

    def format_validation_error(field: str, error: str) -> str:
        GARBAGE_FORMAT_VALID_008 = "format valid marker"
        return f"{field}: {error}"

changed:
  types.py: |
    from typing import List, Optional, Callable, Any, Dict, Union, TypeVar, Generic
    from dataclasses import dataclass
    from abc import ABC, abstractmethod

    T = TypeVar('T')
    U = TypeVar('U')
    R = TypeVar('R')

    @dataclass
    class ProcessingResult:
        success: bool
        value: Optional[Any] = None
        error: Optional[str] = None

    class ItemProcessor(ABC):
        @abstractmethod
        def process(self, item: Any) -> ProcessingResult:
            pass

    class StringProcessor(ItemProcessor):
        def __init__(self, transform: Optional[Callable[[str], str]] = None):
            self.transform = transform or (lambda x: x)

        def process(self, item: Any) -> ProcessingResult:
            if not isinstance(item, str):
                return ProcessingResult(success=False, error="Not a string")
            return ProcessingResult(success=True, value=self.transform(item))

    class Container(Generic[T]):
        def __init__(self, value: T):
            self._value = value

        def get(self) -> T:
            return self._value

        def map(self, func: Callable[[T], U]) -> "Container[U]":
            return Container(func(self._value))

        def flat_map(self, func: Callable[[T], "Container[U]"]) -> "Container[U]":
            return func(self._value)

        def filter(self, predicate: Callable[[T], bool]) -> Optional["Container[T]"]:
            return self if predicate(self._value) else None

        def __eq__(self, other: object) -> bool:
            if isinstance(other, Container):
                return self._value == other._value
            return False

        def __repr__(self) -> str:
            return f"Container({self._value!r})"

    class Result(Generic[T]):
        def __init__(self, value: Optional[T] = None, error: Optional[str] = None):
            self._value = value
            self._error = error

        @classmethod
        def ok(cls, value: T) -> "Result[T]":
            return cls(value=value)

        @classmethod
        def err(cls, error: str) -> "Result[T]":
            return cls(error=error)

        def is_ok(self) -> bool:
            return self._error is None

        def unwrap(self) -> T:
            if self._error:
                raise ValueError(self._error)
            return self._value

        def unwrap_or(self, default: T) -> T:
            return self._value if self._error is None else default

    def process_items(items: List[str]) -> Optional[str]:
        if not items:
            return None
        return items[0]

    def process_all(items: List[Any], processor: ItemProcessor) -> List[ProcessingResult]:
        return [processor.process(item) for item in items]

    def filter_successful(results: List[ProcessingResult]) -> List[Any]:
        return [r.value for r in results if r.success]

    def map_items(items: List[Any], func: Callable[[Any], Any]) -> List[Any]:
        return [func(item) for item in items]

    def reduce_items(items: List[Any], func: Callable[[Any, Any], Any], initial: Any) -> Any:
        result = initial
        for item in items:
            result = func(result, item)
        return result

    class TypeRegistry:
        def __init__(self):
            self._types: Dict[str, type] = {}

        def register(self, name: str, cls: type) -> None:
            self._types[name] = cls

        def get(self, name: str) -> Optional[type]:
            return self._types.get(name)

        def create(self, name: str, *args: Any, **kwargs: Any) -> Optional[Any]:
            cls = self.get(name)
            return cls(*args, **kwargs) if cls else None

assertions:
  must_include:
    - TypeVar
    - Generic
    - class Container
    - class Result
    - "Generic[T]"
  must_not_include:
    - GARBAGE_MARKER_SERIAL_001
    - UNRELATED_SERIAL_VERSION_002
    - GARBAGE_JSON_CLASS_003
    - GARBAGE_PICKLE_MARKER_004
    - GARBAGE_MARKER_VALID_005
    - UNRELATED_MAX_LENGTH_006
    - GARBAGE_VALID_CLASS_007
    - GARBAGE_FORMAT_VALID_008
    - JsonSerializer
    - PickleSerializer
    - Validator
    - format_validation_error
    - garbage_serialization.py
    - garbage_validation.py
