cart.py: |
  from dataclasses import dataclass, field
  from typing import Optional
  from decimal import Decimal
  from datetime import datetime
  from enum import Enum

  class DiscountType(Enum):
      PERCENTAGE = "percentage"
      FIXED = "fixed"
      BUY_ONE_GET_ONE = "bogo"

  @dataclass
  class Discount:
      discount_type: DiscountType
      value: Decimal
      min_items: int = 1
      max_uses: int = 1

      def apply(self, price: Decimal, quantity: int) -> Decimal:
          if quantity < self.min_items:
              return Decimal("0")
          if self.discount_type == DiscountType.PERCENTAGE:
              return price * quantity * (self.value / Decimal("100"))
          elif self.discount_type == DiscountType.FIXED:
              return min(self.value, price * quantity)
          return Decimal("0")

  @dataclass
  class CartItem:
      product_id: str
      name: str
      price: Decimal
      quantity: int = 1
      discount: Optional[Discount] = None
      added_at: datetime = field(default_factory=datetime.now)

      @property
      def subtotal(self) -> Decimal:
          base = self.price * self.quantity
          if self.discount:
              return base - self.discount.apply(self.price, self.quantity)
          return base

      def to_dict(self) -> dict:
          return {
              "product_id": self.product_id,
              "name": self.name,
              "price": str(self.price),
              "quantity": self.quantity,
              "subtotal": str(self.subtotal)
          }

  class Cart:
      def __init__(self, items: list[CartItem] = None, customer_id: str = None):
          self.items = items or []
          self.customer_id = customer_id
          self.created_at = datetime.now()
          self._tax_rate = Decimal("0.08")

      def __add__(self, other: "Cart") -> "Cart":
          merged_items = {}
          for item in self.items + other.items:
              if item.product_id in merged_items:
                  merged_items[item.product_id].quantity += item.quantity
              else:
                  merged_items[item.product_id] = CartItem(
                      product_id=item.product_id,
                      name=item.name,
                      price=item.price,
                      quantity=item.quantity,
                      discount=item.discount
                  )
          return Cart(list(merged_items.values()), self.customer_id)

      def __len__(self) -> int:
          return sum(item.quantity for item in self.items)

      def __contains__(self, product_id: str) -> bool:
          return any(item.product_id == product_id for item in self.items)

      def subtotal(self) -> Decimal:
          return sum(item.subtotal for item in self.items)

      def tax(self) -> Decimal:
          return self.subtotal() * self._tax_rate

      def total(self) -> Decimal:
          return self.subtotal() + self.tax()

      def add_item(self, item: CartItem) -> None:
          for existing in self.items:
              if existing.product_id == item.product_id:
                  existing.quantity += item.quantity
                  return
          self.items.append(item)

      def remove_item(self, product_id: str) -> bool:
          for i, item in enumerate(self.items):
              if item.product_id == product_id:
                  del self.items[i]
                  return True
          return False
checkout.py: |
  from cart import Cart, CartItem, Discount, DiscountType
  from decimal import Decimal
  from typing import Optional

  class CheckoutService:
      def __init__(self):
          self.active_carts: dict[str, Cart] = {}

      def get_or_create_cart(self, customer_id: str) -> Cart:
          if customer_id not in self.active_carts:
              self.active_carts[customer_id] = Cart(customer_id=customer_id)
          return self.active_carts[customer_id]

      def merge_carts(self, cart1: Cart, cart2: Cart) -> Cart:
          combined = cart1 + cart2
          return combined

      def apply_discount(self, cart: Cart, discount: Discount) -> None:
          for item in cart.items:
              if item.discount is None:
                  item.discount = discount

  def process(customer_id: str, guest_cart: Optional[Cart] = None) -> dict:
      service = CheckoutService()
      customer_cart = service.get_or_create_cart(customer_id)

      if guest_cart:
          customer_cart = service.merge_carts(customer_cart, guest_cart)

      return {
          "customer_id": customer_id,
          "item_count": len(customer_cart),
          "subtotal": str(customer_cart.subtotal()),
          "tax": str(customer_cart.tax()),
          "total": str(customer_cart.total())
      }
garbage_payment_processor.py: |
  GARBAGE_PY_PAY_928371 = "payment processing garbage"
  UNRELATED_PAY_MARKER_182746 = "unused payment gateway"

  class GarbagePaymentProcessor:
      GARBAGE_API_KEY_827364 = "sk_garbage_key_12345"

      def garbage_charge(self, amount, card):
          return f"Garbage charge: {amount}"

      def garbage_refund(self, transaction_id):
          return f"Garbage refund: {transaction_id}"

  def garbage_validate_card(card_number):
      return f"Garbage card: {card_number}"
garbage_shipping_calc.py: |
  GARBAGE_PY_SHIP_736291 = "shipping calculator garbage"
  UNRELATED_SHIP_MARKER_918273 = "unused shipping rates"

  class GarbageShippingCalculator:
      GARBAGE_RATE_BASE_827163 = 5.99

      def garbage_calculate_rate(self, weight, zone):
          return self.GARBAGE_RATE_BASE_827163 * weight

      def garbage_estimate_delivery(self, zip_code):
          return "3-5 garbage days"
garbage_inventory_sync.py: |
  GARBAGE_PY_INV_182736 = "inventory sync garbage"
  UNRELATED_INV_MARKER_736281 = "unused stock levels"

  def garbage_sync_inventory():
      return "Garbage inventory synced"

  def garbage_check_availability(sku):
      return f"Garbage availability: {sku}"
