decorators.py: |
  import functools
  import time
  import logging
  from typing import Callable, TypeVar, Any, Optional, Dict
  from dataclasses import dataclass
  from datetime import datetime, timedelta
  import threading

  logger = logging.getLogger(__name__)

  F = TypeVar('F', bound=Callable[..., Any])

  @dataclass
  class RateLimitState:
      calls: int = 0
      window_start: datetime = None

      def reset(self) -> None:
          self.calls = 0
          self.window_start = datetime.now()

  class RateLimitExceeded(Exception):
      def __init__(self, retry_after: float):
          self.retry_after = retry_after
          super().__init__(f"Rate limit exceeded. Retry after {retry_after:.1f}s")

  def rate_limit(calls_per_second: int = 10, burst: int = 0):
      def decorator(func: F) -> F:
          state = RateLimitState()
          lock = threading.Lock()
          last_call = [0.0]
          burst_tokens = [burst]

          @functools.wraps(func)
          def wrapper(*args: Any, **kwargs: Any) -> Any:
              with lock:
                  now = time.time()
                  elapsed = now - last_call[0]

                  burst_tokens[0] = min(burst, burst_tokens[0] + elapsed * calls_per_second)

                  if burst_tokens[0] >= 1:
                      burst_tokens[0] -= 1
                  elif elapsed < 1.0 / calls_per_second:
                      sleep_time = 1.0 / calls_per_second - elapsed
                      time.sleep(sleep_time)

                  last_call[0] = time.time()
                  return func(*args, **kwargs)
          return wrapper
      return decorator

  def retry(max_attempts: int = 3, delay: float = 1.0, backoff: float = 2.0, exceptions: tuple = (Exception,)):
      def decorator(func: F) -> F:
          @functools.wraps(func)
          def wrapper(*args: Any, **kwargs: Any) -> Any:
              current_delay = delay
              last_exception = None
              for attempt in range(max_attempts):
                  try:
                      return func(*args, **kwargs)
                  except exceptions as e:
                      last_exception = e
                      if attempt < max_attempts - 1:
                          logger.warning(f"Attempt {attempt + 1} failed: {e}. Retrying in {current_delay}s")
                          time.sleep(current_delay)
                          current_delay *= backoff
              raise last_exception
          return wrapper
      return decorator

  def timed(name: Optional[str] = None):
      def decorator(func: F) -> F:
          func_name = name or func.__name__

          @functools.wraps(func)
          def wrapper(*args: Any, **kwargs: Any) -> Any:
              start = time.perf_counter()
              try:
                  return func(*args, **kwargs)
              finally:
                  elapsed = time.perf_counter() - start
                  logger.info(f"{func_name} took {elapsed:.3f}s")
          return wrapper
      return decorator

  def cached(ttl_seconds: int = 300):
      def decorator(func: F) -> F:
          cache: Dict[str, tuple] = {}
          lock = threading.Lock()

          @functools.wraps(func)
          def wrapper(*args: Any, **kwargs: Any) -> Any:
              key = str((args, sorted(kwargs.items())))
              with lock:
                  if key in cache:
                      value, expires_at = cache[key]
                      if datetime.now() < expires_at:
                          return value
                  result = func(*args, **kwargs)
                  cache[key] = (result, datetime.now() + timedelta(seconds=ttl_seconds))
                  return result
          return wrapper
      return decorator
api.py: |
  from typing import Dict, Any, Optional, List
  import time
  import random

  class APIError(Exception):
      def __init__(self, status_code: int, message: str):
          self.status_code = status_code
          self.message = message
          super().__init__(message)

  class APIClient:
      def __init__(self, base_url: str, api_key: str):
          self.base_url = base_url
          self.api_key = api_key
          self._request_count = 0

      def call_api(self, endpoint: str, method: str = "GET", data: Optional[Dict] = None) -> Dict[str, Any]:
          self._request_count += 1
          time.sleep(0.01)
          return {"endpoint": endpoint, "method": method, "status": "success"}

      def get(self, endpoint: str) -> Dict[str, Any]:
          return self.call_api(endpoint, "GET")

      def post(self, endpoint: str, data: Dict[str, Any]) -> Dict[str, Any]:
          return self.call_api(endpoint, "POST", data)

      def get_request_count(self) -> int:
          return self._request_count
garbage_metrics.py: |
  GARBAGE_MARKER_METRICS_001 = "metrics garbage"
  UNRELATED_METRIC_INTERVAL_002 = 60

  class MetricsCollector:
      GARBAGE_METRICS_CLASS_003 = "metrics class marker"

      def __init__(self):
          self._metrics: Dict[str, List[float]] = {}

      def record(self, name: str, value: float) -> None:
          if name not in self._metrics:
              self._metrics[name] = []
          self._metrics[name].append(value)

      def get_average(self, name: str) -> Optional[float]:
          values = self._metrics.get(name, [])
          return sum(values) / len(values) if values else None

  class PrometheusExporter:
      GARBAGE_PROM_MARKER_004 = "prometheus marker"

      def export(self) -> str:
          return ""
garbage_tracing.py: |
  GARBAGE_MARKER_TRACE_005 = "tracing garbage"
  UNRELATED_TRACE_SAMPLE_006 = 0.1

  class TraceContext:
      GARBAGE_TRACE_CLASS_007 = True

      def __init__(self, trace_id: str):
          self.trace_id = trace_id
          self.spans: List[Dict] = []

      def start_span(self, name: str) -> Dict:
          span = {"name": name, "start": time.time()}
          self.spans.append(span)
          return span

  def format_trace_id(trace_id: str) -> str:
      GARBAGE_FORMAT_TRACE_008 = "format trace marker"
      return f"trace-{trace_id}"
