money.py: |
  from typing import Optional, Union
  from decimal import Decimal, ROUND_HALF_UP
  from functools import total_ordering

  SUPPORTED_CURRENCIES = {"USD", "EUR", "GBP", "JPY", "CHF", "CAD", "AUD"}

  class CurrencyMismatchError(Exception):
      def __init__(self, currency1: str, currency2: str):
          self.currency1 = currency1
          self.currency2 = currency2
          super().__init__(f"Cannot operate on {currency1} and {currency2}")

  class InvalidCurrencyError(Exception):
      pass

  @total_ordering
  class Money:
      def __init__(self, amount: Union[int, float, Decimal], currency: str = "USD"):
          if currency not in SUPPORTED_CURRENCIES:
              raise InvalidCurrencyError(f"Unsupported currency: {currency}")
          self._amount = Decimal(str(amount)).quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)
          self._currency = currency

      @property
      def amount(self) -> Decimal:
          return self._amount

      @property
      def currency(self) -> str:
          return self._currency

      def __str__(self) -> str:
          return f"{self._currency} {self._amount:.2f}"

      def __repr__(self) -> str:
          return f"Money({self._amount!r}, {self._currency!r})"

      def __eq__(self, other: object) -> bool:
          if not isinstance(other, Money):
              return NotImplemented
          return self._amount == other._amount and self._currency == other._currency

      def __lt__(self, other: "Money") -> bool:
          if self._currency != other._currency:
              raise CurrencyMismatchError(self._currency, other._currency)
          return self._amount < other._amount

      def __hash__(self) -> int:
          return hash((self._amount, self._currency))

      def __bool__(self) -> bool:
          return self._amount != 0

      def __neg__(self) -> "Money":
          return Money(-self._amount, self._currency)

      def __abs__(self) -> "Money":
          return Money(abs(self._amount), self._currency)

      def __add__(self, other: "Money") -> "Money":
          if self._currency != other._currency:
              raise CurrencyMismatchError(self._currency, other._currency)
          return Money(self._amount + other._amount, self._currency)

      def __sub__(self, other: "Money") -> "Money":
          if self._currency != other._currency:
              raise CurrencyMismatchError(self._currency, other._currency)
          return Money(self._amount - other._amount, self._currency)

      def __mul__(self, factor: Union[int, float, Decimal]) -> "Money":
          return Money(self._amount * Decimal(str(factor)), self._currency)

      def __rmul__(self, factor: Union[int, float, Decimal]) -> "Money":
          return self.__mul__(factor)

      def is_positive(self) -> bool:
          return self._amount > 0

      def is_negative(self) -> bool:
          return self._amount < 0

      def round_to(self, decimals: int = 0) -> "Money":
          factor = Decimal(10) ** -decimals
          rounded = self._amount.quantize(factor, rounding=ROUND_HALF_UP)
          return Money(rounded, self._currency)
calculator.py: |
  from money import Money, CurrencyMismatchError
  from typing import List, Optional
  from decimal import Decimal

  class MoneyCalculator:
      def __init__(self, default_currency: str = "USD"):
          self.default_currency = default_currency

      def sum_money(self, m1: Money, m2: Money) -> Money:
          if m1.currency != m2.currency:
              raise CurrencyMismatchError(m1.currency, m2.currency)
          return Money(m1.amount + m2.amount, m1.currency)

      def sum_all(self, amounts: List[Money]) -> Optional[Money]:
          if not amounts:
              return None
          result = amounts[0]
          for m in amounts[1:]:
              result = self.sum_money(result, m)
          return result

      def apply_discount(self, amount: Money, discount_percent: float) -> Money:
          discount = amount.amount * Decimal(str(discount_percent / 100))
          return Money(amount.amount - discount, amount.currency)

      def apply_tax(self, amount: Money, tax_rate: float) -> Money:
          tax = amount.amount * Decimal(str(tax_rate / 100))
          return Money(amount.amount + tax, amount.currency)

      def split_evenly(self, amount: Money, parts: int) -> List[Money]:
          if parts <= 0:
              raise ValueError("Parts must be positive")
          per_part = amount.amount / parts
          return [Money(per_part, amount.currency) for _ in range(parts)]
garbage_shipping.py: |
  GARBAGE_MARKER_SHIPPING_001 = "shipping garbage marker"
  UNRELATED_SHIPPING_RATE_002 = 15.99

  class ShippingCalculator:
      GARBAGE_SHIPPING_CLASS_003 = "class marker"

      def __init__(self, base_rate: float = 5.0):
          self.base_rate = base_rate

      def calculate_cost(self, weight: float, distance: float) -> float:
          return self.base_rate + (weight * 0.5) + (distance * 0.01)

      def get_delivery_estimate(self, distance: float) -> int:
          if distance < 100:
              return 1
          elif distance < 500:
              return 3
          return 7

  class CarrierIntegration:
      GARBAGE_CARRIER_MARKER_004 = "carrier marker"

      def get_rates(self, origin: str, destination: str) -> List[dict]:
          return []
garbage_audit.py: |
  GARBAGE_MARKER_AUDIT_005 = "audit garbage"
  UNRELATED_AUDIT_CONST_006 = "audit_log"

  class AuditLogger:
      GARBAGE_AUDIT_CLASS_007 = True

      def __init__(self):
          self.entries = []

      def log_action(self, user_id: int, action: str, details: dict) -> None:
          self.entries.append({"user": user_id, "action": action, "details": details})

      def get_user_history(self, user_id: int) -> List[dict]:
          return [e for e in self.entries if e["user"] == user_id]

  def format_audit_entry(entry: dict) -> str:
      GARBAGE_FORMAT_MARKER_008 = "format marker"
      return f"{entry['user']}: {entry['action']}"
