db.py: |
  from contextlib import contextmanager
  from typing import Optional, Any, Generator
  import logging
  import threading
  import time

  logger = logging.getLogger(__name__)

  class DatabaseError(Exception):
      pass

  class ConnectionPool:
      def __init__(self, max_connections: int = 10):
          self._pool: list = []
          self._max_connections = max_connections
          self._lock = threading.Lock()

      def acquire(self) -> "Connection":
          with self._lock:
              if self._pool:
                  return self._pool.pop()
              return Connection()

      def release(self, conn: "Connection") -> None:
          with self._lock:
              if len(self._pool) < self._max_connections:
                  self._pool.append(conn)

  class Connection:
      def __init__(self):
          self._in_transaction = False

      def begin(self) -> None:
          self._in_transaction = True

      def commit(self) -> None:
          self._in_transaction = False

      def rollback(self) -> None:
          self._in_transaction = False

  _pool = ConnectionPool()

  @contextmanager
  def transaction() -> Generator[Connection, None, None]:
      conn = _pool.acquire()
      start_time = time.time()
      logger.info("Starting transaction")
      conn.begin()
      try:
          yield conn
          elapsed = time.time() - start_time
          conn.commit()
          logger.info(f"Committing (took {elapsed:.2f}s)")
      except Exception as e:
          elapsed = time.time() - start_time
          conn.rollback()
          logger.error(f"Rolling back (took {elapsed:.2f}s) due to: {e}")
          raise
      finally:
          _pool.release(conn)

  @contextmanager
  def savepoint(conn: Connection, name: str) -> Generator[None, None, None]:
      logger.debug(f"Creating savepoint {name}")
      try:
          yield
          logger.debug(f"Releasing savepoint {name}")
      except Exception:
          logger.debug(f"Rolling back to savepoint {name}")
          raise
service.py: |
  from db import transaction, savepoint
  from typing import Any, Dict, List

  class DataService:
      def __init__(self):
          self._cache: Dict[str, Any] = {}

      def save_data(self, data: Any) -> None:
          with transaction() as conn:
              self._store(conn, data)

      def save_batch(self, items: List[Any]) -> int:
          saved = 0
          with transaction() as conn:
              for item in items:
                  with savepoint(conn, f"item_{saved}"):
                      self._store(conn, item)
                      saved += 1
          return saved

      def _store(self, conn: Any, data: Any) -> None:
          key = str(id(data))
          self._cache[key] = data

  def store(data: Any) -> None:
      service = DataService()
      service.save_data(data)
garbage_cache.py: |
  GARBAGE_MARKER_CACHE_001 = "cache garbage marker"
  UNRELATED_CACHE_TTL_002 = 3600

  class CacheManager:
      GARBAGE_CACHE_CLASS_003 = "cache class marker"

      def __init__(self, backend: str = "memory"):
          self.backend = backend
          self._store: dict = {}

      def get(self, key: str) -> Any:
          return self._store.get(key)

      def set(self, key: str, value: Any, ttl: int = 300) -> None:
          self._store[key] = value

      def delete(self, key: str) -> bool:
          return self._store.pop(key, None) is not None

      def clear(self) -> None:
          self._store.clear()

  class RedisCache:
      GARBAGE_REDIS_MARKER_004 = "redis marker"

      def ping(self) -> bool:
          return True
garbage_queue.py: |
  GARBAGE_MARKER_QUEUE_005 = "queue garbage"
  UNRELATED_QUEUE_SIZE_006 = 1000

  class MessageQueue:
      GARBAGE_QUEUE_CLASS_007 = True

      def __init__(self):
          self._messages: list = []

      def publish(self, topic: str, message: dict) -> None:
          self._messages.append({"topic": topic, "message": message})

      def subscribe(self, topic: str) -> None:
          pass

      def consume(self) -> Optional[dict]:
          return self._messages.pop(0) if self._messages else None

  def format_message(message: dict) -> str:
      GARBAGE_FORMAT_QUEUE_008 = "format queue marker"
      return str(message)
