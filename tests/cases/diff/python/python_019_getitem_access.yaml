name: python_019_getitem_access
initial:
  cache.py: |
    from typing import Generic, TypeVar, Optional, Callable
    from dataclasses import dataclass, field
    from datetime import datetime, timedelta
    from collections import OrderedDict

    T = TypeVar("T")

    @dataclass
    class CacheEntry(Generic[T]):
        value: T
        created_at: datetime
        expires_at: Optional[datetime]
        access_count: int = 0

        @property
        def is_expired(self) -> bool:
            if self.expires_at is None:
                return False
            return datetime.now() > self.expires_at

    class CacheStatistics:
        def __init__(self):
            self.hits = 0
            self.misses = 0

        @property
        def hit_rate(self) -> float:
            total = self.hits + self.misses
            return self.hits / total if total > 0 else 0.0

    class Cache(Generic[T]):
        def __init__(self, max_size: int = 1000, default_ttl: int = None):
            self._data: OrderedDict[str, CacheEntry[T]] = OrderedDict()
            self._max_size = max_size
            self._default_ttl = default_ttl
            self.stats = CacheStatistics()

        def __getitem__(self, key: str) -> Optional[T]:
            entry = self._data.get(key)
            if entry is None:
                self.stats.misses += 1
                return None
            if entry.is_expired:
                del self._data[key]
                self.stats.misses += 1
                return None
            entry.access_count += 1
            self.stats.hits += 1
            return entry.value

        def __setitem__(self, key: str, value: T) -> None:
            expires_at = None
            if self._default_ttl:
                expires_at = datetime.now() + timedelta(seconds=self._default_ttl)
            self._data[key] = CacheEntry(
                value=value,
                created_at=datetime.now(),
                expires_at=expires_at
            )

        def __contains__(self, key: str) -> bool:
            entry = self._data.get(key)
            return entry is not None and not entry.is_expired

  service.py: |
    def get_value():
        pass

  garbage_metrics_collector.py: |
    GARBAGE_PY_METRICS_827364 = "metrics collection garbage"
    UNRELATED_METRICS_MARKER_182736 = "unused prometheus metrics"

    class GarbageMetricsCollector:
        def garbage_record_metric(self, name, value):
            return f"Garbage metric: {name}={value}"

  garbage_config_loader.py: |
    GARBAGE_PY_CONFIG_918273 = "config loader garbage"
    UNRELATED_CONFIG_MARKER_827163 = "unused yaml config"

    def garbage_load_config(path):
        return f"Garbage config from: {path}"

changed:
  service.py: |
    from cache import Cache, CacheEntry, CacheStatistics
    from typing import Any, Optional

    cache: Cache[Any] = Cache(max_size=500, default_ttl=3600)

    class DataService:
        def __init__(self):
            self.request_cache = Cache[dict](max_size=100, default_ttl=60)

        def get_data(self, resource_id: str) -> Optional[dict]:
            return self.request_cache[resource_id]

        def set_data(self, resource_id: str, data: dict) -> None:
            self.request_cache[resource_id] = data

        def get_stats(self) -> dict:
            return {
                "hits": self.request_cache.stats.hits,
                "misses": self.request_cache.stats.misses,
                "hit_rate": self.request_cache.stats.hit_rate
            }

    def get_value(key: str) -> Any:
        return cache[key]

assertions:
  must_include:
    - DataService
    - request_cache
    - Cache
  must_not_include:
    - GARBAGE_PY_METRICS_827364
    - UNRELATED_METRICS_MARKER_182736
    - GARBAGE_PY_CONFIG_918273
    - UNRELATED_CONFIG_MARKER_827163
    - GarbageMetricsCollector
    - garbage_load_config
