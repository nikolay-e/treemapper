name: selection_new_function_added
initial:
  src/services/user_service.py: |
    from typing import Optional, List, Dict, Any
    from dataclasses import dataclass, field
    from datetime import datetime
    from enum import Enum
    import hashlib
    import logging

    logger = logging.getLogger(__name__)

    class UserStatus(Enum):
        ACTIVE = "active"
        INACTIVE = "inactive"
        SUSPENDED = "suspended"
        PENDING = "pending"

    @dataclass
    class User:
        id: Optional[str] = None
        username: str = ""
        email: str = ""
        status: UserStatus = UserStatus.PENDING
        created_at: datetime = field(default_factory=datetime.now)
        metadata: Dict[str, Any] = field(default_factory=dict)

    class UserService:
        def __init__(self, repository):
            self.repository = repository
            self._cache: Dict[str, User] = {}

        def func1(self, user_id: str) -> Optional[User]:
            if user_id in self._cache:
                return self._cache[user_id]
            user = self.repository.find_by_id(user_id)
            if user:
                self._cache[user_id] = user
            return user

        def func2(self, user: User) -> User:
            if not user.username:
                raise ValueError("Username is required")
            if not user.email:
                raise ValueError("Email is required")
            user.id = self._generate_user_id(user)
            saved = self.repository.save(user)
            self._cache[saved.id] = saved
            return saved

        def _generate_user_id(self, user: User) -> str:
            data = f"{user.username}:{user.email}:{datetime.now().isoformat()}"
            return hashlib.sha256(data.encode()).hexdigest()[:16]

        def update_status(self, user_id: str, status: UserStatus) -> Optional[User]:
            user = self.func1(user_id)
            if not user:
                return None
            user.status = status
            return self.func2(user)

        def deactivate_user(self, user_id: str) -> Optional[User]:
            return self.update_status(user_id, UserStatus.INACTIVE)

        def list_active_users(self) -> List[User]:
            all_users = self.repository.find_all()
            return [u for u in all_users if u.status == UserStatus.ACTIVE]

  src/unrelated/garbage_account_service.py: |
    # GARBAGE_ALGO_ACCOUNT_NEWF001
    GARBAGE_ALGO_ACCOUNT_VERSION_NEWF002 = "1.0.0"

    class GarbageAccountService:
        GARBAGE_ALGO_ACCOUNT_CACHE_NEWF003 = {}

        def func1_garbage(self, account_id):
            return f"GARBAGE_ALGO_FUNC1_NEWF004_{account_id}"

        def func2_garbage(self, account):
            return f"GARBAGE_ALGO_FUNC2_NEWF005_{account}"

        def new_function_garbage(self, data):
            x = "GARBAGE_ALGO_X_NEWF006"
            y = "GARBAGE_ALGO_Y_NEWF007"
            return f"{x}_{y}_{data}"

        def create_garbage_account(self, name):
            return {"garbage": "GARBAGE_ALGO_CREATED_NEWF008"}

  src/unrelated/garbage_profile_service.py: |
    # GARBAGE_ALGO_PROFILE_NEWF009
    GARBAGE_ALGO_PROFILE_ENABLED_NEWF010 = True

    class GarbageProfileService:
        GARBAGE_ALGO_PROFILE_STATE_NEWF011 = "idle"

        def func1_profile(self, profile_id):
            return f"GARBAGE_ALGO_PROFILE_F1_NEWF012_{profile_id}"

        def func2_profile(self, profile):
            return f"GARBAGE_ALGO_PROFILE_F2_NEWF013_{profile}"

        def new_function_profile(self, x, y):
            return f"GARBAGE_ALGO_NEW_PROFILE_NEWF014_{x}_{y}"

        def update_garbage_profile(self, profile_id, data):
            return {"garbage": "GARBAGE_ALGO_UPDATED_NEWF015"}

  src/unrelated/garbage_session_service.py: |
    # GARBAGE_ALGO_SESSION_NEWF016
    GARBAGE_ALGO_SESSION_TTL_NEWF017 = 3600

    class GarbageSessionService:
        GARBAGE_ALGO_SESSION_STORE_NEWF018 = {}

        def func1_session(self, session_id):
            return f"GARBAGE_ALGO_SESSION_F1_NEWF019_{session_id}"

        def func2_session(self, session):
            return f"GARBAGE_ALGO_SESSION_F2_NEWF020_{session}"

        def create_garbage_session(self, user_id):
            return {"garbage": "GARBAGE_ALGO_SESSION_NEWF021"}

        def destroy_garbage_session(self, session_id):
            return f"GARBAGE_ALGO_DESTROYED_NEWF022_{session_id}"

changed:
  src/services/user_service.py: |
    from typing import Optional, List, Dict, Any
    from dataclasses import dataclass, field
    from datetime import datetime
    from enum import Enum
    import hashlib
    import logging

    logger = logging.getLogger(__name__)

    class UserStatus(Enum):
        ACTIVE = "active"
        INACTIVE = "inactive"
        SUSPENDED = "suspended"
        PENDING = "pending"

    @dataclass
    class User:
        id: Optional[str] = None
        username: str = ""
        email: str = ""
        status: UserStatus = UserStatus.PENDING
        created_at: datetime = field(default_factory=datetime.now)
        metadata: Dict[str, Any] = field(default_factory=dict)

    class UserService:
        def __init__(self, repository):
            self.repository = repository
            self._cache: Dict[str, User] = {}

        def func1(self, user_id: str) -> Optional[User]:
            if user_id in self._cache:
                return self._cache[user_id]
            user = self.repository.find_by_id(user_id)
            if user:
                self._cache[user_id] = user
            return user

        def new_function(self, username: str, email: str, metadata: Optional[Dict] = None) -> User:
            x = self._validate_username(username)
            y = self._validate_email(email)
            if not x or not y:
                raise ValueError("Invalid username or email")
            user = User(username=username, email=email, metadata=metadata or {})
            return self.func2(user)

        def _validate_username(self, username: str) -> bool:
            return len(username) >= 3 and username.isalnum()

        def _validate_email(self, email: str) -> bool:
            return "@" in email and "." in email

        def func2(self, user: User) -> User:
            if not user.username:
                raise ValueError("Username is required")
            if not user.email:
                raise ValueError("Email is required")
            user.id = self._generate_user_id(user)
            saved = self.repository.save(user)
            self._cache[saved.id] = saved
            return saved

        def _generate_user_id(self, user: User) -> str:
            data = f"{user.username}:{user.email}:{datetime.now().isoformat()}"
            return hashlib.sha256(data.encode()).hexdigest()[:16]

        def update_status(self, user_id: str, status: UserStatus) -> Optional[User]:
            user = self.func1(user_id)
            if not user:
                return None
            user.status = status
            return self.func2(user)

        def deactivate_user(self, user_id: str) -> Optional[User]:
            return self.update_status(user_id, UserStatus.INACTIVE)

        def list_active_users(self) -> List[User]:
            all_users = self.repository.find_all()
            return [u for u in all_users if u.status == UserStatus.ACTIVE]

assertions:
  must_include:
    - new_function
    - _validate_username
    - _validate_email
  must_not_include:
    - GARBAGE_ALGO_ACCOUNT_NEWF001
    - GARBAGE_ALGO_ACCOUNT_VERSION_NEWF002
    - GARBAGE_ALGO_ACCOUNT_CACHE_NEWF003
    - GARBAGE_ALGO_FUNC1_NEWF004
    - GARBAGE_ALGO_FUNC2_NEWF005
    - GARBAGE_ALGO_X_NEWF006
    - GARBAGE_ALGO_Y_NEWF007
    - GARBAGE_ALGO_CREATED_NEWF008
    - GarbageAccountService
    - new_function_garbage
    - func1_garbage
    - func2_garbage
    - GARBAGE_ALGO_PROFILE_NEWF009
    - GARBAGE_ALGO_PROFILE_ENABLED_NEWF010
    - GARBAGE_ALGO_PROFILE_STATE_NEWF011
    - GARBAGE_ALGO_PROFILE_F1_NEWF012
    - GARBAGE_ALGO_PROFILE_F2_NEWF013
    - GARBAGE_ALGO_NEW_PROFILE_NEWF014
    - GARBAGE_ALGO_UPDATED_NEWF015
    - GarbageProfileService
    - new_function_profile
    - func1_profile
    - func2_profile
    - GARBAGE_ALGO_SESSION_NEWF016
    - GARBAGE_ALGO_SESSION_TTL_NEWF017
    - GARBAGE_ALGO_SESSION_STORE_NEWF018
    - GARBAGE_ALGO_SESSION_F1_NEWF019
    - GARBAGE_ALGO_SESSION_F2_NEWF020
    - GARBAGE_ALGO_SESSION_NEWF021
    - GARBAGE_ALGO_DESTROYED_NEWF022
    - GarbageSessionService
    - func1_session
    - func2_session
